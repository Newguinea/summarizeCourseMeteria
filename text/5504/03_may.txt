on the tour.

What?

He is, right.

That's what it's called.

J ja.

Ja.

Mhm.

That you What?

OK, I think we'll get started now, everyone.

So Hi, everybody.

Uh, my name is Michael.

Um I'm not sure why you introduced me at all,

but I am a post doctoral research fellow at U

W A.

Um, I've been working here for a few years.

Um, my area of research is natural language processing.

So if you've heard of chat JP t you might

be familiar with the area.

It's kind of getting computers to understand written language, that

kind of thing Like Siri Google, um, chat JP t

that kind of thing.

And I've used graphs quite a bit as part of

that.

So I've developed a number of applications using Neo, for

example, Um, it has a very nice synergy with natural

language processing because it's very good for capturing unstructured text

and that kind of thing.

Um, I'm not gonna be showing that here, but I'm

just kind of outlining that, I guess.

Um, so before that, I was a PhD student here

at U W A.

Funnily enough, wa was my supervisor.

Um, and if anyone's looking for a PhD supervisor in

the future.

She's an absolutely fantastic one.

So I highly recommend that, um and, uh, yeah, so

in terms of the lecture, um, So I think this

is the second year now that we're doing the graph

databases, Um, I actually did the teaching for this last

year.

Um, so these slides are the ones that I developed,

and it's a really good time to be getting into

them, um, graph databases, because they're definitely taking off.

Um, they're a really nice alternative to relational databases, as

far as I'm concerned.

Anyway, I've really enjoyed using them, and I think they

offer a lot of advantages.

And obviously, they're quite cool to look at as well,

Which doesn't hurt.

It doesn't hurt.

Um, so OK, so today's lecture.

Um, I'm not sure how it went last week, but

we're gonna be splitting it up into two parts.

So the first hour or so, uh, is the kind

of traditional lecture kind of thing where we're just gonna

go through slides and I'm gonna introduce concepts and that

kind of thing.

You can, of course, ask questions during that.

You're very welcome to, um and then the second half

at one PM, we're gonna start looking at a more

interactive kind of tutorial with neo four J.

I'll be showing some of these concepts in practise.

Basically, the idea is to make it a little bit

more interactive and kind of, you know, I'll I'll be

asking you questions and we'll kind of work together to

understand what we're talking about now.

So, uh, this week's lecture is all about cipher, So

Cipher is a query language for neo four.

It's a very good example of a query language for

graphs in general.

Um, it's one of the most popular ones.

If you've ever worked with relational databases, which I'm sure

many of you have, um, you'll be familiar with SQL.

Cipher is kind of like the equivalent of that, but

for graphs and in particular near four J.

So, in terms of the structure, uh, it's kind of

broken into three parts.

I guess we're gonna start with a recap of the

property graph model, which I think you would have looked

at last week.

Uh, then I'm gonna introduce what cipher is, and then

we're gonna be talking about the creating, reading, updating and

deleting using cipher.

OK, so we'll start out with the recap and the

intro.

So the property graph model, Um, so as you hopefully

will remember from last week, the property graph model is

a model that represents a graph.

It contains nodes and relationships.

Uh, nodes must or may have zero or more.

Properties like key value pairs.

Uh, they can be labelled with one or more labels.

Uh, relationships can have names, and they're also directed, and

they can also contain properties as well.

So I got a picture example here.

So this is like a social media thing where you've

got Ruth, who follows Billy, who follows Harry, and you

can see the sort of you can see my mouse.

No, I should have got a laser pointer.

Um, you've got labels there and yellow sort of users

that could be a label.

Uh, you've got the labels on the relationships as well,

like follows, and you have properties as well.

Uh, in this case, the properties would be like the

name of the person and not shown here is that

you can also have properties on the relationships as well.

So here's another example.

Uh, This is another kind of social media graph.

This one just has a slightly different format.

I guess the point of this is to to show

that, you know, not every single property graph looks exactly

the same.

You can model it differently.

It's just so you may come across different ways of

representing the same thing.

So in this case, the, uh, the property is actually

on the side there, next to the the node, like

the name Michael is next to the the label of

person.

There, for example, so different ways of representing the same

thing.

So there's, for example, what it looks like if you

want to label each of the things in that graph

labels, properties and so on.

So far, uh, we haven't looked at much other than

diagrams of graphs, so those are the diagrams I just

mentioned.

So diagrams are really good for visualising graphs, but to

actually create manipulate and query data, we need to have

a query language, Just like with SQL, you can look

at tables, but to actually do anything with them, you

need to be able to read from them, create them,

update them and so on That's where CIPA fits in.

So cipher is a graph database query language specific to

neo for um, I'm not sure it might be used

for other databases as well.

But there are, of course, plenty of other query languages

as well for graphs.

So you've got Gremlin, which isn't used by Amazon.

Neptune.

You've got sparkle, which is used also by Amazon Neptune,

and there's a few other listed there as well.

They're all kind of similar.

They have different syntax, but the idea behind them all

is the same.

So cipher is designed to be easily read and understood.

The language is structured in a way that resembles the

way that we would describe graphs in English.

It's kind of the design methodology behind it.

And generally speaking, we use we think of cipher as

a language that looks for specific patterns in a database

in a graft database.

So find things like this kind of thing.

So now I'm gonna ask you all a question.

Um, if you take the graph here, the question is,

how would you describe the graph below in plain English,

Um, if anyone wants to have a stab at that,

let me know if you were to just look at

it and, yeah, so you can see Jennifer is friends

with Michael since 2018.

Jennifer works for, and Jennifer likes.

Yeah, perfect.

So that's exactly right.

And keeping that in mind is kind of how we

structure our cipher queries.

It's kind of thinking about it in plain English.

That's the whole philosophy behind Cipher.

So that's pretty much exactly what you just said.

So now, in terms of representing, uh, nodes and relationships

in cipher So this is kind of the more syntactical

level stuff.

Um, don't worry if you don't remember it right now,

because, of course, once you start using cipher, it'll become,

you know, you'll know it like the back of your

hand in no time.

So nodes and relationships in cipher are represented using, as

which I'm sure you're familiar with, um, just plain text

nodes are surrounded by round brackets.

So, for example, here's a note, uh, label.

So that might be a person, for example.

That's all surrounded by round brackets.

And then, if you want to have properties, uh, then

you just use those curly brackets there.

So in this case, We're getting a node with a

specific property with a specific value, and that's the pattern

that we're looking for.

For example, uh, you might go, You're looking for a

person with the name of Michael.

That's an example of a no represented in cyclo, and

likewise, there's a bit more complicated one there where we've

got two properties.

You just separate them using Commons, basically.

So in this case, we're looking for a person, and

it has to have the name of Steve, but also

the hair colour of brown.

And it will only match people who match that exact

criteria.

So some more examples.

So here's a person name of Michael Person name of

Jennifer, uh, technology type of graphs, company name.

It's all the same idea.

A node is, you know, round brackets, properties in code

brackets.

Relationships, on the other hand, are represented by square brackets,

so you can also have properties in them as well.

So in this case, we've got same thing properties in

the curly brackets, But now the relationship is represented with

the square brackets, so an example of this might be

is friends with.

That's the name of the label type of relationship, and

then the property is since and the value is 2050.

So here's some examples again.

So he's friends with since 2016 likes works for, and

then you've got the sort of graph version of that

at the bottom.

You always need a uh yes.

I think if you take the colon out, it will

just give you a syntax error.

As far as I understand, you can have relationships without

any particular label as well.

I think so.

You don't necessarily need to have a type in your

query.

So I guess those are the two different parts of

nodes and relationships.

The cool part of cipher is actually adding them together

to form a pattern.

So we can use this not, uh, notation to represent

a pattern in the cipher query.

And then we can connect the nodes and the edges

using hyphens and specify the direction using an accent or

less than a greater than simple same thing.

So here's an example of what that might look like.

I'm not sure if you can see that yellow.

Uh, it looks alright.

I can't see it on my screen.

Um, so person of the name of Jennifer, and then

you've got the relationship works for, and then you've got

the company with the name of and that pattern will

match that particular graph.

And that's an example of something you could care for

in cipher if you wanted to.

So the important thing to remember is just using these

hyphens and accents.

The accent, of course, specifies the direction that you're looking

for, so you can either go forwards or backwards.

You could also match both ways as well.

You could take the accent out, and then it would

match that direction.

So just like most other query languages, uh, cipher is

composed of clauses.

So a cipher query the way that it's kind of

working behind the scenes, I guess you could say, is

that it anchors one or more parts of a pattern

to specific locations in a graph using predicates.

And then it sort of flexes the unanchored parts around

to find local matches in terms of what that means.

It's basically a way of, I guess, thinking about it,

um, in terms of it being efficient, I guess it

looks for a specific part, and then it kind of

branches out from there.

Um, it's hard to describe without a picture, I guess.

But the important thing to keep in mind is it's

doing it efficiently.

It's not just like searching through a massive list that

starts at a specific part of your pattern and kind

of branches out from there.

The simplest cipher queries in general would be the ones

that are just a match clause, followed by return.

If you were to do that in sequel, it would

be like a select, um, statement, for example.

So here's an example.

Uh, the first example query of today.

So I guess I'll ask you this instead of me

just telling you.

Um, so here's an example.

Query.

So a person named Jim et cetera, uh, does anyone

want to have a stab at what that means in

plain English?

What does the query actually look for?

Yeah, yeah, perfect.

That's exactly right.

So, yeah, find all people that gym knows.

So that's the pattern that we're looking for there.

So that's the, uh, I guess, the first part of

today's lecture just looking at the kind of introduction part.

Now we're gonna look into a bit more about how

to create data.

So we're starting with these Create read update to lead

actions.

That's kind of the structure of today's lecture.

So of course, there's the first thing that you need

to do before you can even do anything is to

have data in your database to do anything with.

So that's where creating comes in.

Generally speaking, there are two ways to create data.

There's actually three.

Now I'll mention these two first.

So, firstly, you can create new data just using cipher

clauses using the create statement or the merge.

Those both work, and I'll go into those in a

bit.

Another way you can do it is if you already

have a CS B data set.

You can import it using what is known as the

Load CS B Command.

There are other ways to do this as well.

Um, in the lab for this week, you're gonna be

looking at the near four J E.

T l tool.

That's extract transform load.

Uh, that allows you to actually load in data from

an existing SQL database like post or something uh, without

needing C SPS.

So really, those three ways and you'll you'll see that

way when you do the lab.

So to create new data using create, we use the

create course.

So what it does is it can create new nodes

and new relationships.

For example, if we were to run the first one,

create N, it will simply create a node.

It won't have any specific label.

It will just be a node.

It would just be basically a circle in the graph,

I guess a node in the graph with nothing in

it.

It'd be like creating a table without any columns, I

guess, if you were to look at the sequel equivalent.

Another way, of course, is you include a pattern inside

that create statement.

So you have P person named Sally that will create

a node with those specific, that specific label of person

and that particular property, where the name is equal to

selling you can kind of merge them as well or

join them up.

So create a person named Sally, then create another one

that's p two and then et cetera, et cetera.

I guess one thing to keep in mind here is

that this n uh, the P P here, the p

two These are actually just variables that you can refer

to later in the same, uh, query.

Once you execute this query, those variables will disappear.

They're just basically references that you can use later, and

we should see that a bit more.

I think in the next slide we'll see what that

actually means.

So another thing you can do, of course, is create

relationships between nodes that already exist.

But of course, to do this, you will need to

actually find the data that you want to connect, and

that's where the match courts can come in.

So in this case, we are matching for a person

whose name is Michael.

We're also matching for a book with the name of

Lord of the Rings.

And we're assigning those two, um, the two things that

are matched by those patterns to the variables P and

B.

Then, in the next part of the query, we are

doing a create statement to create a relationship between P

and D with the, uh, type of red.

So essentially you can imagine this would be creating a

little relationship in the graph that says Michael has read

Lord of the Rings, the return statement at the end

is optional.

You might like to have a look at what it

actually did at the end, in which case you can

do return, and then it will return the rows or

return the different parts of the query.

Or you could just take it out.

If you don't care about that, it's up to you.

Another way you can create data instead of a create

clause is to use merge.

So merge.

Yep.

I knew it.

Yeah.

Yeah, that's a great question.

Um, so because graphs have a very flexible schema, you

don't need to actually create any schema before adding data

in so I could create this.

That's the I could run this three straight away without

having done any preparation beforehand.

I don't need to have created a label called person.

It just sort of automatically adds it into the database.

Um, and that comes with, you know, positives and negatives.

I guess if you put the name, let's say you

misspelt the word person, for example, it would actually be

a different type of node, a different label of node.

So you have to be careful when you're entering your

data because there's no fixed schema that you have to

adhere to.

So merge, on the other hand, is very useful when

you want to create data in your table on the

table in your database.

But you aren't sure whether it's already there or not.

So merge is kind of like a combination between match

and create.

It's like a almost like a shortcut.

I guess it avoids you having to write a big,

long query, so merge allows us to avoid duplicating the

same data.

Another thing about merge is that it is all or

nothing.

So if any specific part of the pattern that you

specify doesn't exist, it's gonna create the whole thing, and

I'll show you an example of that.

So, for example, the first one merged person named Sally

that will only create that particular node with that particular

property if it doesn't or already exist.

So if there's a person with the name of like

Bob or something, it will create it.

But if there's a person with the name of Sally,

it won't no matter what the other properties are.

Second one, for example, will require there to be a

person with the name of Sally and the age of

45.

If that doesn't exist in the database with those exact

properties, then it will create it.

Otherwise it won't.

And then you can get also using, um, you can

start using merge for relationships as well.

So, for example, we're doing a match for the person

called Charlie Sheen.

We're looking for a movie there with the title of

Wall Street.

And what we're doing here with the Merge is we

are only creating this relationship if it doesn't already exist.

So no matter how many times we run this query,

it will only ever there will only ever be one

relationship between Charlie Sheen and Wall Street.

So it can be useful if you're not sure about

that.

Yeah, So if we can create multiple have multiple s

coming from the same.

Yes, So with create, if you don't use merge, you

just go create.

It will literally create it.

It doesn't do any checks on whether it already exists.

So if I change this word merge to create and

run the query 10 times I would literally have 10

edges between Charlie and Wall Street, all exactly the same

data, so merge can be very useful.

Um, so yeah.

Uh, so the Shakespeare graph?

Um, I'm not sure if you've seen this yet before,

but basically, it's a graph that captures three different domains

in one graph.

Might be a bit small there, but basically it's just

creating it It It's a graph that captures a lot

of different data.

It's not actually that relevant what the data is, to

be honest, because the next slide is more about how

to create it.

But essentially, it's just a a little bit of a

more complicated example of a graph.

Um, it's got different data.

It's got, like, theoretical, uh, theatrical stuff, literary stuff, geospatial,

all integrated into one graph.

You've got different relationships between things, that sort of thing.

In terms of creating the graph, we might like to

use a simple, uh, not simple a single cipher statement,

and that's what that might look like there.

Obviously you're not expected to read the whole thing, but

it is essentially just one single query.

You can run that it will create the entire graph.

However, if any one of those statements fails, it won't.

The entire thing will be basically stopped and you won't

have any data.

So it's nice in that regard.

Like if you aren't sure whether your data is completely

or whether your query is completely correct, et cetera, it's

just not gonna run at all if there's any kind

of errors in there.

So that's one way of creating data.

Just use a use to create clause and just put

everything into it.

And then later.

Of course, once we've already created that, we could go

ahead and use additional credit standards, and we also might

like to use merge instead.

If we're not sure what we've already added in there,

we could just change it to a merge, and then

it will make sure that whatever we add in there

is not going to be duplicated Now.

There's another tool, uh, that we often use with neo

four called the Arrow Tool.

Um, you might need to use for the project.

I'm not sure.

Um, at least we did last year.

I don't know if the projects the same, to be

honest, but the A tool is a really nice tool

for creating a graph model.

It's like a Web app.

Basically, you just kind of go on there.

You can create different nodes, different edges and so on.

It's nice for, like toy data sets or whatever, where

you just have a small number of nodes.

The reason we like this tool is because there's an

export feature, and it literally just exports it to a

cipher query that you can run and create the same

thing within the four G.

So if you ever need to sort of play around

with data, if you want to try out some queries,

but you don't have a data set or something like

that, you can go ahead and just run this.

Um, try it out.

Just create some nodes, create some relationships, export it, put

it into the four G, and then you can start

running queries.

Now, as I mentioned, uh, the second way of importing

data is to use load CS B.

So this is really good if we already have a

CS b dataset.

So quite often you'll have, like, a table or something

that you've got in a CS B form, and you

might want to actually import it into near four j

as a graph.

But of course, C SBS are tables.

They're not graphs.

So there's a bit of kind of, I guess, data

wrangling to transform the schema from a table into a

graph.

And the first step is to consider How do we

actually do that?

How do we translate a table into a graph?

So we're taking tables.

We're transforming them into nodes and relationship.

And here's an example of a relational database.

This is the North Wind data set.

It's basically a data set of products suppliers.

I think employees, customers, that kind of thing.

Um, you can see there's quite a lot of stuff

in there, but generally the process that we use to

transform tables to graphs is quite consistent across data sets.

So this is kind of the schema.

Uh, we'll actually be looking at this in the second

part as well of the lecture.

So what we want to do here is actually translate

this into a graph.

And generally speaking, what we do is we take a

row.

We turn that into a node, we take a table

name, we turn that into a label name, and then

we take any kind of foreign keys in the data

and we turn that into a relationship in the graph,

I'll share an example of that.

So this is kind of a, I guess, a description

of what we would do.

So the orders table, uh, which is kind of on

the right there.

Every row of that can become a node in the

graph.

So if you imagine our near a four j database,

we would have a node representing every single order like

at the bottom.

That's kind of the scheme of what our graph would

look like.

Likewise, for products we take each row, we turn that

into a node representing a product.

We then take supplier, turn each row into a node,

representing a supplier and so on and so on.

So that's the kind of tables aspect.

So we're taking the tables and we're turning those into

notes.

Then the next step is to actually take the relationships

between the tables and turn those into relationships.

For example, there's a relationship between suppliers and products.

We can turn that into a graph relationship instead.

So down the bottom you've got this little relationship called

supplies, likewise products and categories.

You can then say that the product is a part

of a category employees and orders, et cetera, et cetera.

So one interesting thing is that the order details is

actually a separate table.

Unlike, for example, suppliers.

The products just has a relationship between them, but order

details is its own table that could still become a

relationship as well.

We could even put properties onto that relationship if we

wanted to as well.

So there's many ways of actually designing this.

But generally that's a good process to follow, and then

once we've kind of I guess that kind of explains

how to do it.

But then, once we have the CS V data sets

and everything, we can actually just import them using Load

CS V.

Like I mentioned.

And the query to do that is on the left.

Um, basically, what it's doing is it's loading the CS

V.

It's going through every single row.

It's using a merge to make sure it's not creating

any duplication.

And then at the end, it's doing a bit of

an update on that row and basically setting all the

properties of the node that it's created to be.

All the columns from that particular road and we'll see

an example of that in the second half of the

lecture as well.

Ok, Does anyone have any questions about that?

Uh, creating or anything like that?

Any questions so far?

Previous slides.

Where?

Sally.

And then he and he specified the age.

Will that update every instance of that person in 45?

Um, OK, so you've got You've got a node in

there.

That's got yeah.

Uh, OK, yeah.

No.

Merge will never update.

Merge will only create, um, so it's not gonna change

any existing data.

Now, let me go back to that bit.

Um, so this one here?

Yeah.

So what it's gonna do is it will check whether

there is a pattern that matches that exact pattern.

So if there's any nodes where the person's name is

Sally and the age of is 45 doesn't matter what

the other properties are.

There could be other things, like birthday or whatever if

that already exists.

Like if it finds a person called Sally who's age

is 45 it won't create any more notes.

After that, it will just basically do nothing.

If there was, for example, a person named Sally whose

age was 44.

It wouldn't do anything to that particular note.

It would just create a new one whose name was

Sally and the age of 45.

So you'd have two salaries, Basically, you'd have a 44

year old Sally and a 45 year old Sally.

No.

No, it no.

It will only create new data.

It will never update existing data.

It doesn't sort of overwrite anything or anything like that.

It's just there to kind of substitute, uh, the create

the match and create.

It's kind of a, I guess, a shortcut for that.

If that makes sense.

So there's no updating.

Uh, any other questions?

So far?

No.

OK, ok, so So now we've done create.

Uh, there's three left reading, updating and deleting.

These are a little bit simpler.

Um, well, generally, I guess.

Um, So reading.

Uh, yeah.

So queering and stuff.

So in cipher, I kind of mentioned this before a

little bit, so we begin our queries from one or

more well known starting points in the graph.

So down notes This is kind of how it's working

behind the scenes, I guess, um and then ciphers using

any labels and property predicates provided in the match and

Ware clauses, along with metadata supplied by indexes and constraints

in order to find the starting points.

From a usability perspective, I guess it's not that important

to notice.

It's just kind of how it works under the hood.

It's the way that it becomes efficient.

I guess so.

Match we've already seen match We use that in a

create match is at the heart of pretty much every

single cipher query.

For the most part, um, kind of serves as the

specification by example.

So Match is basically saying that we're drawing the data

that we're interested in by connecting the nodes and edges

using hyphens and accents as we've seen already.

For example, all the people that Jim knows.

If we were to write a query, that's what it

would look like.

And we're looking for the node labelled person with the

name whose property is Jim, et cetera, et cetera.

It's kind of looking for this specific pattern.

That's what match is doing.

The anchor point, once again for efficiency is the, uh,

the person whose name is Jim.

That's kind of where it starts, so if you think

of how Neo Forge is executing this.

It will begin looking at the very first part of

the query.

Then it will branch out from there.

That saves a lot of time, as as opposed to

looking through literally every single pattern that exists in the

graph, for example, it kind of intelligently starts from a

certain point and branches out from there.

Then it obviously goes down all the relationships whose type

his nose and then it looks at people.

So that's one half of a read query.

Pretty much every read query is gonna have a match.

The next part is actually returning data out of that.

So return is a another part of the query that

looks at which nodes, relationships and properties from the match

data should be returned.

And for those of you familiar with SQL, you'll know

select.

It's very similar to select pretty much the same.

To be honest, um, if you're familiar with using aliases,

I guess as well it's kind of similar.

So, for example, in the query above, we are interested

in returning the nodes bound by the A identifier.

So in this case, like I mentioned before, we can

assign variables to specific parts of our pattern.

So here we Oops, we're looking for Oops.

Here we go.

All per person whose name is Jim knows A, which

is a also has the person label.

The only part of this we actually care about is

who does Jim know?

So we can assign a variable called a to this

part of the query that the person part, um And

then in our return statement, we say we return it.

Hey, we're just gonna get a list of all the

people that Jim knows.

That's why we're using the variables so we don't care

about the rest of that.

So we might like to extend that, for example as

well.

So that's pretty simple.

It's just all people who gym knows.

So here's another question.

This one gets a little bit more complicated.

Um, so who wants to have a guess or not

Really a guess who wants to tell me, uh, what

this might mean In plain English.

It's a bit more complicated, but yeah, pretty much.

Yeah.

Um, I've got it written down here, mutual friends, but

yeah, that's more or less the same thing.

It's a friend, not a friend knows kind of thing.

Oh, it's like, Is it the same thing?

It's It's like a person knows someone.

And then that other person also knows that same person.

Yeah.

So mutual friends?

Yep.

So that query uh, right.

So the way that works behind the scenes, I guess.

Or not really behind the scenes.

But we're basically looking for a few different patterns here

with our match.

We're looking for all people named Jim, who knows another

person.

Um, I couldn't fit it all on one slide, I

guess.

But you can see that also extends to that same

pattern.

So it's Jim knows a person who knows someone else.

And then the second part of that is we're also

matching for all persons that A knows.

Uh, that person that Jim, it's a bit complicated.

Basically, Person A knows person c and they also know

person b, who also knows person C.

It's a bit Yeah, a bit tricky to wrap your

head around, I guess.

But hopefully that makes sense.

And then you're just returning the names of those people

to B and C.

So, another way of writing this instead of using the

properties in here.

See how we've got like a person whose name is

Jim, et cetera.

Using those square, uh, curly brackets.

Another way of doing it is to use a we

just like with SQL.

You can do a where clause where is basically just

allowing you to specify specific properties you're looking for.

So this is exactly kind of equivalent to the one

we just saw.

Instead of saying, Person whose name is Jim, we're just

going match or people et cetera.

And then we're using a aware to kind of separate

that out a little bit.

Whether you do this or the other one, it's up

to you, I guess.

Um, I guess it's personal preference.

For the most part, you might find as you write

more complicated queries, it becomes better to use a aware

clause because it's easier to specify everything in one place.

You can also sort of modify properties as well.

If you wanted to do like the upper case name

equals Jim, for example, that would need to go in

a workhouse.

You couldn't do that in a property, as far as

I can tell.

So that's just something to keep in mind.

So where is technically not a clause in its own

right?

But it's part of a match optional match or with

so you can't use ware by itself.

It needs to be part of the match statement.

I guess that's just how cipher works in general.

So Wa adds constraints to the patterns described so operators

can be used in a workforce, just as they can

in SQL.

Like I just mentioned, you could do up case.

Or you could look for a specific age being less

than a certain number, that kind of thing you could

imagine.

This works with dates, et cetera, looking for dates within

specific ranges, et cetera.

You're just using operators the same way you use them

in SQL, basically.

So where can also be used as a way of

performing string matching?

So you might like to go something like where the

name starts with a particular thing.

So in this first query, it's like where the name

starts with the word pet, and then it ends with

Peter.

Uh, sorry ends with ER so you would get the

word Peter in there.

You'd also get any other names where there's letters in

between the PE T and the ER et cetera.

You can also use other string things like, for example,

ends width we've just seen and contains, like the name

might contain a particular thing in there.

And if you're interested, um, May four j has pretty

good documentation, all all of these things as well.

So in terms of all the different string matching things

you can do, there's quite a lot in there.

You can also use regular expressions as well, if you

want to get a bit more sort of advanced with

queries, that kind of thing.

So with is kind of an interesting one.

Um, this is a clause that doesn't come up too

often, but it is good to know width can be

used to manipulate output before it's sort of passed through

to the next part of the query.

It's not always useful, uh, but it can be sometimes.

So in this case we've got we're looking for all

persons that that all people that know someone called Jim

the wid statement basically takes the variables that we've just

declared, and it passes them through to the next part

of the query, which is like the Wa Clause, for

example, um so with P 22, upper p one dot

name is basically saying we're passing through the P two

from the first part.

We're also passing through the upper case of P one

dot name Something interesting about width is that any variables

that you don't put in the width statement will not

be accessible later as well.

So we don't have access to K anymore.

We don't have access to P one, et cetera.

The only variables you can use from this point on

will be P two and upper case name.

And then you can combine that with where to get

a bit more advanced with your queries.

So in this case, we're looking for all people.

Um, where the upper case name of the person that

knows Jim starts with AC.

You could probably write this without where it's just kind

of an ex, uh, without the width.

It's just kind of an example.

I guess it's just good to know.

So that's all reading.

Uh, that's pretty much all the read queries and everything

like that.

Uh, the next part would be updating data, so we

kind of saw this a little bit with the creation

of the data from the CS V SI.

Think there was a set in there as well where

we were setting the values to the row, uh, from

the safe way.

But basically, updating a near four J or with sci-fi

is just a matter of using the word set.

And it's pretty similar to SQL you kind of.

First you get the data that you wanna update, then

you run the set, and that will just auto, you

know, automatically set it to whatever you specify.

For example, if we start with the person whose name

is Jennifer, we assign that to the variable of P.

Then we set p dot birth date to a specific

date.

It's gonna update that mhm that does not necessarily need

to already exist like the birth date could be.

It could be a new property that you're setting there,

Um, like with the whole flexible scheme of thing, it

doesn't matter what the birth date is.

It doesn't matter if it already exists, or if there

is no birthday, it will just set it to that

value and then, uh, deletion.

So deletion is also pretty similar.

Just like updating.

We first have to query the data we wanna delete,

and then we just delete it using the delete statement.

So, for example, we first find the person whose name

is Jennifer.

Then we just delete that that will no longer be

in the graph.

After running that we could also use a pattern like

P one nose, p two et cetera, and then just

delete the relationship between them.

That's another way of using that, too.

We've also got a thing called detach delete, which is

really useful to know.

So sometimes you want to delete a node.

But you also want to delete anything related to it

as well.

For example, like if I deleted a person called Jennifer

from the graph, I don't want relationships between Jennifer and

all the other people in that graph.

You would want to delete those as well.

Um, in fact, neo four, I won't even let you

delete them without using detach delete.

It's not gonna let you basically have edges that point

to nothing after you've deleted a node.

That's where detached the light comes in so we can

delete both the nodes and all the out comming and

ongoing relationships using detached deletes.

So this is useful.

Uh, if the node has any relationships at all, because

we can't do a delete without detached delete.

So here's an example.

We're just taking Jennifer.

We are deleting anyone that she knows called Bob.

Once we do the detached delete, that relationship between them

is also gonna be disappeared, but also deleted.

Jennifer will stay there, but the relationship will be gone.

Another thing we can do kind of under updating, I

guess, is that we can remove properties using the remove

keyword.

For example, we might remove someone's name.

So matching a person called Jennifer.

We do p dot name.

They remove that it's gone.

It's kind of like set, except you're just removing the

property entirely.

You can also try to remove properties that may not

even exist.

I'm not actually sure what would happen then.

I think it would basically just try to remove it,

see that it doesn't exist, and nothing would happen as

far as I know.

Um, but yeah, it's good to know how to remove

properties.

OK, uh, does anyone have any questions so far about

updating, deleting that kind of thing.

Yeah.

Yeah, that's right.

No.

So as far as I know, it won't actually let

you delete a note If there are relationships, um, it'll

give you some error, like, cannot delete because relationships exist

or something.

So the only way to delete those we'll be using

to touch, in which case it will remember.

Yeah.

You could do that as well.

Probably.

Yeah.

Unless you wanna be really specific, I guess.

But if you do it the first way where you

just delete or every single relationship separately, it's just a

longer query.

I suppose so.

And with, uh, with, um, keyword with clause.

So I believe in this case.

Paul is trying to do this.

If by chance, anyone hasn't put the person's name with

a small C, it's just converting that into upper case

just to make sure that it finds all things start.

Um, yes, yes.

So OK, so this one is going for p one

dot name.

If the upper case of that is capital C or

starts with Capital C, then it will match.

So in this case, yeah.

If there was a person called Chris or something with

a lower case C, it would get that.

And it would also get Chris with an upper case.

So it's kind of a Yeah, it's It's making sure

that no matter whether it's lower case or upper case,

it gets, it gets converted, and then it matches.

Yeah, Any other questions?

So far, I think we've got a little bit of

time on our hands.

So if anyone has any questions delete is that similar

in Cascade?

Uh, yeah, it's pretty much the same thing as far

as I understand.

So Casco delete will delete all table.

Uh, it will delete rows and also relationships between them,

right?

Like foreign keys?

Yeah.

Um, whether it cascades, yeah.

I'm not sure.

To the extent to which it will cascade.

I think it just deletes immediate relationships around it.

Um, from my understanding with SQL like Cusco delete could

delete multiple.

You could, Yeah.

If you had something that had multiple relationships at multiple

places, it would delete every single one, right?

So, yeah, I'm not sure I'll have to look into

it, but I suspect detached delete Just alerts the immediate

neighbours around it as far as I know.

Um, one other thing I'm not sure if I'm gonna

see this in the next part of the tutorial, but

detach delete is really good.

If you just want to delete your graph, you just

go match and detach.

Delete n.

It just completely clears it.

You don't have to worry about like an airport complaining

about existing stuff, etcetera.

It's a good way to it.

It's good to know, because it's very easy to delete

a graph that way, if you want.

That's and that's everything.

Sorry.

Yeah.

So Match n will match everything.

Yeah, that's right.

Yeah, exactly.

So yeah.

So if we look at this one here, so match

rs p person, for example, P is just the variable

that we're assigning.

So if we just had match bracket P close bracket

that would literally match every single node in the graph

because we're not specifying a label or anything, we're just

saying all nodes, So match p detached delete P would

delete every single node and every single relationship and is

just the standard one that we use, I guess for

notes, it's up to you so you can also manage,

like, square bra variables that would like all the Uh,

yeah, you should be able to Yeah.

So you could You could match for relationships.

I think separately as well.

If you just wanted to look at relationships, you could

do a match.

Square bracket.

Yeah, OK, I'll just go through a recap of those

cipher clauses then, um, so we've seen match that looks

for specific patterns we've seen Return des describe it.

Defines what we want to include in the query result.

We've seen where where you kind of like, similar to,

uh, I guess you're providing criteria for filtering.

We've also seen create, which creates nodes and relationships.

I'm not sure that we actually looked at create unique,

but it's pretty similar to merge.

I think merge is the standard nowadays, anyway, uh, so

merge ensures that supplied pattern exists, and it will not

create it if it already exists.

So you're avoiding duplication.

Uh, the width is going to be chaining subsequent query

parts and forwarding results from one part to another, so

you can use it to kind of gate The variables.

Make sure that you're not putting too many variables.

At the end of your query, you can also do

things within the width and then pass them on to

the next part, et cetera.

We've also seen Set, which is updating properties on nodes

or relationships we've seen delete to be able to delete

data remove to take properties away.

Uh, we haven't looked at four each, but there's a

way you can kind of iterate over graphs as well.

Um, looks at so you can update based on a

particular array.

I guess, uh, union is another one, uh, that merges

results from two or more queries.

I don't think we're gonna be looking at that one

much, but it's just good to keep in mind.

I guess you can actually combine the queries together and

get a result set similar to sequel.

And there's also the word start as well, which specifies

one or more specific starting points.

There's a spelling mistake there, uh, in the graph, but

I think at this point it's deprecated anyway.

So it's just something to keep in mind, I suppose.

But, yeah, there's quite a few clauses.

Um, best place to look at all of these would

be the neo four J documentation or the cipher documentation,

and that gives you a really good list as well

as really good examples of all of these in use

as well.

So, uh, in summary, we've got a few slides of

the summary.

Just because there's three parts, uh, we've revisited the property

graph model.

We've started to look at CIPHER.

So cipher is a query language near four.

It allows us to do those create, read, update, delete

actions just like any other query language like cipher, Uh,

SQL et cetera.

It's designed to look like an ask representation of a

graph.

It's kind of you're creating patterns that sort of look

a bit like a graph, I guess.

But in text form and in the next lectures, I

ignore that part that was supposed to be from before.

It used to be three different videos.

Um, so yep, next bit.

So we looked at creating data in a graph database

using create merge load CS B.

Like I mentioned, we now also have the near four

J e.

T l tool that you'll be looking, uh, looking at

in the lab as well.

That allows you to connect to a SQL database that's

running and pull data from that automatically.

Um, we then have create, which is used to create

new data from scratch merge, which avoids duplication loads.

CS V allows us to read from CS V files

and finally we've looked at read, update, delete and some

of the other clauses available in near four J.

I think next week, unless it's changed, I think you'll

be looking at graph data science, which is pretty exciting.

That looks at path, funny algorithms and that kind of

thing.

It's, um it's a really nice use case of graph

databases, so it looks like it's about 12 50 now.

So I think at this stage, uh, are there any

questions about the lecture at all in case anyone has

any, Any questions?

I think I'm not sure how you would have done

this last week, but I think we'll just go for

a break for a little bit like 5 10 minute

break.

Uh, we'll come back at one.

I think one PM.

So, yeah, about 10 minutes.

Um, I'll get the tutorial and everything set up so

we can look at the graph together and everything.

Uh, if you have any questions in the meantime, feel

free to just come and come down and ask.

I'll see you in 10 minutes.

No, I wonder And sorry.

Um, so for the project that we're doing, we're doing

a crime.

Um, if we've got a back table for crime, and

often we've got a a foreign table called crime type,

is it safe to say in the every day you

would bring in the prime time as a property of

crime as opposed to creating it as a different mode?

Um, I'm not as familiar with the project, unfortunately, but

generally speaking, there's multiple ways you can arrange your database.

Your graph database.

Um, it really depends on what your scheme.

It looks like, I suppose, uh, whether you go with

you can do a property, you can also do a

node that connects if you generally, the reason you would

create a node is if you have other information to

store on that note.

But it there's lots of crimes related to that one

node.

Yeah.

Are you modelling crime as a note?

Well, I was thinking of not modelling.

Yeah, so I was modelling crime as a node.

The crime top should be a property within how many

crime types are there?

Uh, seven, right?

Um, it's up to you like there's pros and cons

of making it a property versus making it a node.

If you made it a node, you would have seven

notes, right?

Each one would represent a specific type of thing.

Um, doing it that way would make your queries a

bit longer because you would have to connect.

You know, the queries would become more complicated, Yes, but

it would have the advantage of never accidentally putting the

wrong, slightly wrong property in, If that makes sense, if

you have them as properties.

Yes, then you would need to make sure that every

time you enter the property value it needs to be

exactly the same.

Like in terms of the string is needs to be

exactly the same as all the other ones, right?

OK, so it's it's kind of a trade off.

I guess it's it's up to you to kind of

decide which would be better in terms of designing the

database.

OK, so it's the way in which you're representing a

mode.

Do you want to represent the mode as as an

actual instance of crime, or do you want to know

as a as a generic, and this It's very similar.

Like, even if you did this as a relational database,

you probably have the same kind of considerations that you

need to make.

So yeah, yeah, Thank you.

I'm not really clear with the explain a bit more.

Um, yeah, so All right.

So if you think about with it's kind of like

a you can use it as a bridge between two

parts of the queer sort of a.

So, at this point, you do the match statement.

The width will kind of take the variables from that

match statement.

Like p two.

You can then do some other stuff to it if

you want.

Like you can convert it to upper case you could

do.

I don't know.

Um, there's plenty of other string functions you could use

in there as well, et cetera.

The values out of the width statement are then passed

to the next part of the query.

It can be useful sometimes.

Not always.

It's just kind of good to know.

Um, so in this case, once you've done the wid

statement, you can then use P two and you can

also use upper case name as part of the next

part of the query.

But you're not gonna have access to the other ones

that you've already specified before.

So it's it's kind of so in this case, like

we just, uh, you could in this.

Yeah, you just like, uh, yes.

So the return statement in this case is just returning

a particular property value, so two don't know.

So if you did this in the four day you

would see in the output, you would just see the

names of people you wouldn't see any nodes or anything

like that.

So, like only the upper like is it like or

is it just in this query?

No, it's just using it to check.

So you're converting it to upper case, and then you're

using that to check whether the upper case version of

the name starts with C.

But obviously it's not returned or anything.

It's just kind of making sure the person's name starts

with either lower case or upper case C.

OK?

Yeah.

And, uh, one more question.

Yeah, so for this one, the is P two, right?

So I'm not sure which one is gonna be only

the node or the Yeah.

So it'll it'll delete the node whose name is Bob?

Because that's the P two there.

Um, and that person with the name of Bob needs

to needs to be part of that pattern as well.

So it's only gonna delete the person whose name is

Bob, who is known by Jennifer.

So the relationship and the it will delete the Yeah,

it will delete the node.

And it will also delete the relationship as well.

It shouldn't delete Jennifer.

As far as I know, It shouldn't do that because

it's not, um, Jennifer could be related to other stuff

as well, so it wouldn't delete that it would just

be the relationship.

Yeah.

Thank you.

No worries.

Yeah.

So we detach to lead, right?

We have a situation where we have multiple notes.

All got the same name.

Yeah.

So all of the name Gim at different ages.

So it all it like different nodes, and we detach

to leave that.

Not with any of the name gim.

We had to leave all the nodes with the name

gim and then the relationship.

Yeah.

So your pattern is you're matching for, um, a node.

You call in when name is Jin.

It will delete all of those people whose name is

Jim regardless of what the other properties are.

Because your pattern doesn't care about what those properties are.

Relationship pointing to other modes in that point.

Yeah.

So any any incoming or outgoing relationships from a person

whose name is Jim will also be deleted as well.

Yeah.

What do you have?

You they basically You?

Yeah.

Yes, on.

Yeah.

Think Yeah, of course.

You awesome like that.

So anyway, one population I And how the fact the

pharmacy in the you have so cool that programme a

hold?

Yeah, yeah, thanks so much.

Right?

Right.

OK, so that is the same, right?

I did.

Yeah.

Like maybe yeah can do anything.

That's, um um OK, everyone, um I think I'm gonna

get back into the tutorial now.

That was so much.

Everyone ready?

Consider.

Yeah.

Um, can you guys hear me in the back by

any chance?

Yeah, just make sure the mics gone.

Yeah, yeah, yeah.

Not.

Um So you're asking birds, like, specific use cases for

graphs kind of thing?

Or do do people just put all their data in

a graph?

It depends on the use case.

So, like knowledge graphs, for example, uh, the primary example

of a graph storing pretty much everything like there's plenty

of companies that have heaps of data in a knowledge

graph that they use to ask questions.

For example, Um, I think, for example, Google search.

When you do that, you see how you do a

Google search, and there's like a a pain on the

right that has the details of things like If you

type in Perth, it'll give you year, year built like

population, et cetera.

That's all in a graph.

Um, so, yeah, there's there's two ways you can use

it, really.

I mean, you can use it as kind of a

a place to store all your data.

Combining everything together, which is one big advantage of graphs

is that it's very easy to to integrate different systems

together with relationships.

Um, or you can use them for specific use cases

as well, just like with tables.

OK, um, everyone.

So what we're gonna do is we're gonna go through

a little tutorial.

Um, we're gonna be looking at basically doing what we

did in the lecture, but doing it a bit more

practically in near four G.

Uh, So what we're gonna be doing is looking at

the North Wind data set, which I kind of I

think I showed that during the lecture a little bit

with the products and suppliers and et cetera.

That's obviously a tabular data.

Uh, data set.

We're gonna be importing that into near four J.

And if you ever want to follow along or you

wanna do this again later at home, um, you can

do this command here, play North Wind.

It's one of the demos that comes with near four

days, so you can just run that, and it kind

of walks you through all the different steps.

Uh, but we'll write some of our own queries as

well.

So first step is I guess the first step really

is to look at the tables and get an idea

of what we're actually working with.

So there's a bit of a diagram on the left

there.

It's a bit simpler than the one I showed in

the lecture.

It's just got three tables this time, like categories, suppliers,

products, and you can see all the different columns on

those tables as well.

Now the CS B files.

They're hosted by N four G.

Um, I downloaded them.

So this is what they kind of look like.

So this is suppliers, for example.

You've got supplier ID company name, uh, contact, name, contact

title, et cetera.

Is it?

It's just like a small table in CS v format.

So we're gonna take this, and we're gonna put it

into the four day and sort of connect it up

and start querying it that kind of thing.

So, uh, in terms of doing that, So these are

the sort of commands that we're using.

Um so if I click on that kind of puts

it into the little thing at the top for me,

So I don't have to write it all myself, which

is good.

So it starts out with the load CS B with

headers.

It's that load CS B command we saw earlier.

We're basically taking the CS.

B and we're loading it, and then we're gonna create,

uh, products nodes for each of the rows in the

table.

So, traditionally, we would just go set an ankle row.

We'd forget about all this stuff, and we'd just go.

Let CS b with headers.

That's gonna take the data.

We then create a product for every single row in

the data.

And then we just set the value of all the

properties for our node to whatever was in the columns.

For example, uh, if you go back to the suppliers

thing, it's gonna create a product node for this first

row, it's gonna have the value of the property of

company.

Name will be set to exotic liquids.

The property of contact name, et cetera, will be Charlotte

and so on.

Now this.

I think Query has a bit of extra stuff in

there.

It's doing a bit more sort of conversion of data

types and that kind of thing, which, of course you

can do it can be quite useful.

In this case.

It's setting the unit price to be a float, which

we need Sometimes, you know, I think it would be

a string by default.

Probably.

We obviously want that to be a float because it's

a numerical value, so knowing this kind of stuff is

pretty useful.

So two float two integer.

I think there's other ones as well.

They're always good to use.

And you can do that after setting the row.

It's just gonna right over the top of that.

So in our case, we're gonna end up with unit

Price being a float.

We're gonna end up with units in stock being an

integer units on, auto being an integer and so on.

Now, I've already run this.

So I'm not gonna run this again.

Um, yeah.

Is there a question?

No, no.

All right.

Yeah.

Feel free to ask questions during this as well, because

this is quite, you know, need to be quite informal.

Um, so next step, we've got categories as well.

We're just gonna load that in exactly the same way.

There's no special conversions we wanna do here.

We're just gonna load them in, uh, categories.

Is this table here?

I think the pictures in a format like a base

64 or something.

That's why it looks like that.

So we run that, and then we run the one

for suppliers as well, and that's exactly the same thing.

So once we run all of those things, we will

have a graph basically, or at least we'll have nodes

in a graph.

We're not gonna have relationships because we haven't created those

yet, But we'll have nodes.

And the most simple sort of cipher query we can

run is just match in return in.

So if you run that, we're gonna get all of

the nodes in the data basically, and they're colour coded

based on the particular label of the notes.

So I think products orange suppliers are red categories are

blue, et cetera.

So this is Neo Forge's graph view that allows you

to kind of see it in a graph based representation.

I think the important thing to note, though, is that

the actual results are really a table of Jason.

It's it's kind of good to know the difference, I

suppose.

So, uh, let's look at the text version.

So if you were to ever use this outside of

the neo four J browser, if you were to run

this query, maybe you want to use it for some

Web application or something.

The actual query result is this.

It's the sort of table of results in Json format.

That's what Neo gives you.

It's just this graph representation.

Usually people use this as a way to visualise their

results which can be nice, but it is good to

know the difference between us.

So this is the visualisation of the result.

This is the result.

OK, so so that's that.

There's a graph so far.

It's not much of a graph.

It's more like a collection of nodes.

At this point, we might also like to do a

A account, just like we do with, uh, sequel.

We just return count of in.

And that just tells us how many nodes there are.

Yeah.

Um, why don't we do one with properties like we

did in the lecture?

Or maybe labels, for example?

So this is just the count of every single node

in the data so far in the database.

Why don't we just look for I don't know suppliers,

the number of suppliers?

So we just like we saw we do a colon

and then the label that we wanna look for So

n supplier Return Count N.

We have 29 suppliers, so that's relatively straightforward.

It's just sort of matching, returning counting, et cetera.

OK, so of course, it's not that useful to just

have a collection of notes.

Um, there's no relationships in there yet.

So the next part of the tutorial that's actually creating

relationships between the data?

So how do we do that?

Uh, use the useful thing about this data Is that

just like any relational database, it has foreign keys in

the tables.

So, um, if we look at the product, let's go

look at the product table just in here.

So this is the product table as a CS.

B before we loaded it into the neo four J.

The way that we can get the suppliers that are

related to these products is using this foreign key supply

rating So normally in a SQL database, this would just

be a like a reference to the table.

And that's how you know, when you write the query,

you can do the join queries, et cetera.

You can join based on that supplier ID, and then

you can get the suppliers of a particular product and

so on.

We want to actually use that foreign key in our

query, and that's how we're gonna create those relationships.

So the query is something like this.

So we're matching all products and all categories, so we'll

have.

The results will be all of those things, but we're

looking for specific combinations of categories and products where the

category ID from the product table is equal to the

category ID from the category table.

Which, of course, is the primer K in this title,

the category and any patterns matching those will create a

part of relationship between product and category, and that's one

way you might like to create relationships in your data.

You could also change it to merge.

If you wanted to make sure that a product should

only ever have one category, for example, or vice versa,

you could do merge and then, you know that would

prevent duplication.

Make sure that that particular pattern is only ever created

once.

But I don't think that's what we want here.

So now we've just created 77 relationships in our data

using that query.

And now, of course, if we were to query for

that same pattern, let's go match.

Uh, let's, for example, we'll look at all the suppliers

of particular products or something.

What was the name of the relationship bit part of?

So we'll match all products that are part of a

specific supplier.

I hope that's the right way around.

And then maybe we'll, uh, sign a variable to the

relationship as well.

We'll just return everything.

So we'll go PR and s returning that product.

Uh, that match looks like I did get it the

wrong way around.

Change that around.

OK, that's it.

Thanks, sir.

Also the wrong way around, I think supply as part

of a product.

Hm?

Anyone Tell me what I've done wrong here, cos I'm

not sure what was the thing we created?

Oh, category.

That's what it was.

Yeah.

Yeah.

OK, cool.

Get ahead of myself.

I guess, um so product should be part of a

category, So products I was just like sl It gives

you s to C.

Yeah.

Cool.

There we go.

Yeah, that's that's been so this is a graph representation

of that thing.

We just queried for PR and C, and it's starting

to look a bit more like an actual graph, which

is good.

So you can see all of the relationships here.

So all of these different products in orange are part

of these particular categories in blue.

That looks a lot better.

So yeah, it's fun to play around with the visualisation,

cos it it works pretty well.

Um and yeah, if we were to look at that

result in terms of what it is actually what the

results actually are it kind of looks like this.

So it's like a Jason thing.

It's just returning rows.

Every row kind of matches that particular pattern.

Yeah.

Gra one.

Yeah.

Um, in this data set, it's not set up that

way.

But you could definitely have multiple relationships.

Yeah.

So, uh, yeah, you can definitely have multiple relationships between

things.

So, for example, this product could be part of two

categories, in which case there'd just be a line between

the product and the other category as well.

This this graph, I guess, is kind of unusual in

that it's everything only has one relationship, but you can

definitely have more than one.

OK, so that's products and categories.

Uh, now we just need to join up with products

and supplies, which is this one.

It's exactly the same query just with products and suppliers

instead.

And we're using the foreign key from the other tables,

et cetera.

So we'll just go ahead and run that.

And now we could try that same query, the one

that I tried to write before that was wrong.

There it is, uh, also need to change the relationship

with type to supplies because that's what we created.

So a supplier supplies a product and we match with

that pattern.

There we go.

So once again, there's only one relationship for each one.

But you still get the idea where it's you can

visualise all of the different things in the data.

OK, now, another way of doing this.

If you wanna just look at your entire graph, which

is what some people wanna do, you can just do,

match and return in.

I don't think I've shown this yet, so match and

return and we'll just return literally the entire graph, which

is nice, because then you can start to see some

of them do actually have multiple relationships like this particular

product is supplied by a particular company, and then it's

part of a particular category, et cetera, so you can

get that by doing this command.

If your graph is large, probably don't do it, because

it will be quite slow, but you can also change

the limits in their photo as well so that you're

only returning, like, 50 notes or whatever.

Um, have we seen the connect result Nodes?

Has anyone tried using that before?

Yeah, cool.

So you're all familiar with that?

So if I turn this off, I would only literally

get the nodes in the results so I wouldn't get

the relationships automatically put there by near four.

G.

It's just good to know, Um, so our actual results

would just be the nodes in this case.

So if I turn that off, um, the graph will

not show the relationships anymore, because it's not gonna Yeah,

or four day is not gonna put them there for

me to see.

Cool.

All right.

Um, I've got a list of things here that we

could look at.

Um, why don't we try to query some particular properties

now?

I think we haven't done that yet.

So all suppliers in Germany, for example, So I'll start

out with I just got a supplier.

So does anyone want to tell me how to look

for oil supplies in Germany?

Uh, let me just to make it easier, right?

So you can see the actual property values down the

bottom.

If that helps.

Um, see how it's got, like, a supplier.

And then all the, like, ID address city and stuff.

So how do we query all suppliers in Germany?

Where?

Yeah, Yeah, Both.

Good.

Um, I'll do both.

So we works.

Curly brackets also work, so yeah.

So what's the property?

Country?

Yeah.

Cool.

And then Germany in here.

And then what?

Just cool.

Here we go.

So that's all suppliers in Germany.

It's not much of a result in terms of the

graph.

Obviously, it's just three things.

Probably makes more sense to look at that as a

table, but that's good.

That's the way of doing it.

Another way, like you mentioned, was to use Ware.

So let me do this.

I'll just get rid of this and then figure out

how to.

Right?

So where?

So what are we doing here?

Yeah, country equals Germany.

Oh, you made a mistake.

Yeah, Perfect.

Cool.

Exactly the same thing.

Um, it's up to you.

Which one you use?

They're both valid.

They're both good.

Personally, my preference is if you have a lot of

different things you're querying for, I probably would put them

in the wear.

Um, because it just looks better to me, but it

doesn't matter that much.

All right, um, see if there's a more complicated one

we could do.

Uh, what about the names of all categories?

So we're looking for So right now we're actually just

returning the node for Germany.

We're returning literally everything about the, uh, suppliers.

How do we return specific values?

Let's say we want to look at the names of

every category.

Uh, what should we put in this query?

So all we want to know is the names we

don't want to see everything else.

Yeah.

So match see category in here.

Yeah.

Cool.

Perfect.

All right.

Yeah.

I don't think I explicitly mentioned that.

So that's that's good.

So, just like with SQL, you can return property values.

You can return entire nodes, in which case, they're just

gonna be like a sort of adjacent thing.

We saw that before, where you've got every single thing

about the node.

That's what will happen if we don't specify a specific

property.

And, of course, if we're just returning property values, we're

not gonna get the graph visualisation because there's no actual

nodes.

It's just values, so that can be useful to know.

Cool.

All right.

Um, probably get a bit more advanced here, so Alright,

I'm gonna hope that you didn't say that.

Let's say all products that a particular, uh, customer ordered,

so I'll start out with the match.

Obviously.

Um, so yeah, a query.

Where?

Actually, let's find a specific customer so we can query

for that person.

Uh, why don't we just start by listing all the

company all all the customer names or something so we

can get an idea of what the query is?

Uh, is it pain?

Contact me.

What about him?

Sorry.

Really.

Have I not added it yet?

Oh, OK.

I think if I can do that, I thought I

had So I've got product suppliers and category.

I don't have customers yet.

Hm.

Oh, OK.

There's customers in here as well.

I don't think I have the data in here, though.

Unfortunately, I'd have to connect to get that.

It doesn't matter too much.

We don't really need to do customers.

Uh, why don't we go for instead?

Maybe a list of all of the products that are

particular things supplies, maybe.

Actually, you know what?

I'm gonna connect to unifier so I can get the

customer data in?

Well, not Oh, no.

That's why I loaded some of the data before cos

I wasn't sure about unify here.

Never mind.

That's fine.

We'll work around it.

Um, OK.

Um Hm.

OK, I might just skip ahead to the next bit

in, in that case, because we can't get the customer

stuff.

Yeah, that's a shame.

Is it just me, by the way, or is anyone

else not to get on to Unify?

Hm?

Give me a second.

I'll try and sort this out.

It would be nice to get the customer data in

there and right.

So yeah, if you don't mind just talking amongst yourself

for a minute, I'm gonna connect to Hotspot and just

get it from there.

So seems to be loading.

OK, cool.

Good Internet works.

Alright, so we've loaded in the customer data now, Uh,

I just What I did just then was run this,

um, query down here so loading in all of the

data for the customer's table.

I'll also load in some orders as well.

It's the same exact query that we run before, basically,

just, you know, loading in from the table and then

setting the value to do the row.

And that way we'll get some Oh, OK, The orders

doesn't work for some reason.

Took the s out, maybe.

Hm.

Ok, alright.

So why don't we find all customers in a particular

area?

We'll just do it all customers.

For now, just to make sure they're there, you know?

Mm.

Oh, I know what I did.

I put it there.

That is all right.

Cool.

So now we've got customers in our data as well.

Um, I'm not sure what happened with orders, to be

honest, uh, that's normally we load a list of orders

unless the internet just died temporarily while it was loading

or something.

Give it another go.

There we go.

So that's just created all the orders between customers and

a particular product.

So now we should be able to, in theory, write

a query that looks for all orders made by all

customers.

So we go for 00 for order.

Um, I guess at this point, I'll also introduce something

else you can do with the four J.

You don't necessarily need to specify a relationship in here

another way.

You can do it is to instead of doing that,

something you can just go for a double hyphen like

this.

And what that does basically, is it matches any type

of relationship between two different notes.

I know that there's only one type, which is the,

like, made an order or whatever type it is.

Um, so it's fine.

It'll just return all of those.

It can be a bit of a shortcut.

It's good to know.

Uh, so below that, uh, do the same thing again

with an s.

Hopefully I will get a list of customer orders from

that.

Unless it's the other way round.

Probably because a customer makes an order.

Not the other round.

Yeah.

Has anyone got any idea why that doesn't work?

By any chance?

Oh, good.

I keep doing that.

Yeah, that's exactly right.

So OK, relationship.

It's not having to scroll down.

There we go.

Thanks for that.

Alright.

Now, hopefully we'll get a list of all the It's

gotta be a double dash in there, not a single

one, because we're using the shortcut.

I just realised this is gonna be a big graph.

OK?

My laptop is struggling, but we do now have a

list A A graph representing all of the orders made

by specific by every customer.

Pretty much so, if you look at Thomas Hardy, we

can see all of the things that he ordered.

For example, um, now, I think we'll just continue with

the tutorial.

At this point, I'll just bring it back up again.

So go back to where we were.

Um, interestingly, I didn't run these indexes, but these can

be useful for speeding up the query time.

Um, I haven't run them.

It still works.

Obviously, it's just it makes them a bit quicker to

run.

Uh, OK, and then customer orders.

I think we've just done this right order details.

So the next bit is the relationships between the products

and the orders.

I run this.

So it's looking for the I think this table is

the order details between the products and the orders that

appear.

So all of that information, I think I showed this

in the lecture with the table.

I'll just bring that back up again just so I

can see it.

Um, North wind, this one here, I'm sure if you

can see that.

So let's look a bit.

It's all right.

It's basically just a table with all the the details

pertaining to a specific order.

Um, and we're gonna be creating that.

But we're gonna be putting those things into a relationship

instead of a table like it is here, Um, in

order details there so you can see how we've got

in this case, we're not putting the properties into a

node, but we're actually putting them into a relationship.

And this is something you can do with graphs.

You know, just just because you have properties doesn't mean

you need to put them on nodes.

You can also put them inside the relationships.

And sometimes that actually makes more sense from a design

perspective.

So here we're gonna be creating relationships between the products

and the orders.

Um, once again, using the foreign keys to make sure

that we're putting them into the right place.

And then we're creating a relationship called a between them.

And we're actually setting the details, uh, to the row.

So all the the columns from the rows actually get

put onto the relationship here, not onto notes, and then

I think we're doing some more conversion of making sure

that it gets converted to an integer as well, so

that we can query it now.

Hopefully, this data will actually work this time.

No, I have a feeling that the North wind is

now H T P s, um, I have an old

version of for So that's probably why it's doing that.

There we go.

So it's created 30 13,000 properties.

It's created relationships, et cetera.

So that's good.

So now we should be able to actually get the

order details out, and I think that's the next part

here.

So this query a little bit more complicated, I guess,

than the previous.

So we're looking for all orders that a customer purchased

and then the order details of that particular product so

you can see we've got a We've got a pattern

that's getting a bit longer.

Now we're getting into this sort of something connected to

something else connected to something else.

Your pattern can be as long as you want.

Basically, it's also looking for the category that that particular

order was part of, or that product was part of,

and then in the return, we're just returning the contact

name of the person and the number of, uh products

that they purchased there.

There we go.

So it's in the it's the person and also the

total products that they purchased in that particular query.

Cool, right, Get to the last part here.

Now It's just nothing, right, OK, so I'll go back

to my little list of things.

Um, there we go.

That one is pretty complicated.

Um, OK, we do have updates and things like that,

but maybe we should get a bit more advanced with

one of these queries.

Um, let's look at two upper again.

This is interesting because we saw two upper in the

lecture as well, where we're converting something to an upper

case.

So in this case, we're looking for all orders made

by a customer, the product that those orders were in,

and then the upper case name of the person.

That's pretty straightforward.

It's just the the upper case name of every person

who's ordered something.

Basically, that's an example of that.

Or we could just go ahead and return the entire

graph all customers that have placed an order on a

product.

I think it's quite laggy because it's huge Here we

go.

OK, It's, uh so you can see if you're not

careful with limits, it it can get very laggy.

So you have to be careful with that.

Yeah.

So, um alright, does anyone have any particular queries that

they think might be interesting that we can try and

kind of work on to build, knowing what's kind of

in the data?

Anyone have anything they want to try in particular?

Uh, yes.

There's distinct.

There's definitely distinct.

Uh, some I think you can do.

There are aggregation functions in near four as well.

Um, you can do some.

I wonder if you've got that query.

Whoop that one there.

Yeah, so you can do some.

You can definitely aggregate a near four g.

Um, you could do some count.

Average, I think, might be one as well.

There's a There's quite a lot of different aggregation functions

in there.

Um, so, yeah, those can be really useful, and you

can see the distinct there as well.

I wonder what would happen if we took that out.

Let me just try that.

So that's a table.

The interesting thing about distinct, as far as I understand,

is that It's looking for the entire road to be

distinct, so you can see that we've got 63 records.

If I took that out, I'm pretty sure it will

be the same or not 100%.

Yeah, it's exactly the same.

So I'm not sure if that's the same as sequel,

where you use distinct and it's looking for.

I'm pretty sure it is, though the entire row has

to be completely distinct.

So in our case, removing the word distinct there actually

ends up with the exact same number of rows because

there's no rows where we've got the same customer name

and the same total products purchased distinct generally will be

more interesting or more useful if you just want to

return a single value.

Like, for example, if we have two people called Maria

Lanson.

Um and we only just want to return every unique

name.

Then we could just use distinct customer name.

Um, so that's yeah, useful tonight, I think, Um, any

other questions about sort of reading data so far?

Any queries anyone wants to try or anything like that?

No.

Cool.

Alright.

In that case, I think we'll keep going.

We do have some more advanced queries here, like I

might have sort of show them here.

So customers who ordered two categories at the same time

so you can look for a customer who made an

order, a product, a category you can see it can

get quite long and sort of, I guess, complicated.

In a way, Um, it starts to get a bit

hectic after a while, but these queries are reasonably easy

to write once you kind of understand the cipher and

everything behind them.

So it's all customers who ordered who ordered some product

in the category of beverage and then also AC, a

product in the category of produce as well.

There has to be.

Both of those things have to exist for the customer's

name to be returned.

So if we were to run this, we should only

find customers who actually ordered two different A product from

beverages one or more products and beverages and one or

more products and produce as well.

I don't even know if there's any people who did

that.

Yes, quite a few people.

I think it's pretty common in this data set for

people to order many different types of products.

Uh, we've also got things like customers who ordered two

categories at any point in time.

So this first time was the same time because we're

actually using references from the previous part of the match.

So I'll just show the first one again.

So it's a customer who made a particular order, and

that's denoted by the O.

That same order in here also has to have another

product, which is a category of produce.

So this is the same time it has to be

the same exact order, whereas the second one is without

using a reference from the previous one, the previous match

statement.

In which case we're just looking at any person who

ordered beverages at some point and produce at another point.

So it's good to know the difference, I guess between

those, um, what was I gonna say?

I just thought of something that was useful, man.

No, man.

It'll come to me later, OK?

So that's that's all reading.

There's a lot of stuff you can do with cipher.

The best way to do this, I think, And the

best way to learn is to, I guess, do the

labs because the labs have a lot of questions in

them.

In terms of how to run all these things, it's

all kinda to me, at least from my experience.

Learning by doing is the best way for me to

learn.

You know, just try out the North Wind demo.

You could just do play North Wind like I did

here, um, try out some queries.

You know, you might like to look at, you know,

trying to think of a question you might want to

ask the data set and then writing a query, that

kind of thing, that's always good to try.

And then you can go with trial and error and

find out what works and see if you can do

something in particular that you're interested in.

So we can, of course, do update delete match as

well.

Uh, sorry.

Deleting using matches, et cetera.

So say we've got a category, so C category.

Um, let's just return.

Say, I just wanna show you something with this.

So this is a list of all the categories.

If you go on the table, we can see that

we've actually still got this primary key now in a

graft database.

We don't need this at all.

This is completely irrelevant data at this point because we've

already got relationships between.

I guess category ID you could argue is OK, but

you don't really need it in a graph database.

Foreign keys, especially.

You definitely don't need it in your database.

Like if you've got a supplier representing a category as

a category.

ID, you don't need that because you've got relationships already.

So something you might like to do is just remove

the primary keys and the foreign keys that just happen

to be there because you pulled them out of the

table.

So in that case, that's where we might like to

use the remove.

Um, So if we do match the see category, we

just want to remove the property we can do.

Remove C dot category ID.

It just makes our graph a little bit cleaner.

We could we could return it as well if we

wanted to.

Just make sure it worked.

And that'll just take that property out.

Uh, oops.

Ah, Good catch there.

Yep.

Perfect.

So you can see neo four k doesn't really It's

not very temperamental about errors and stuff.

If you put the wrong thing.

You could put that in.

It would just not do anything and you wouldn't even

know.

So you have to be careful to write your queries

properly, I guess because it doesn't always give you errors.

Um, I don't think you'd ever be in a position

where your database doesn't work anymore.

You could remove the category I DS now because it's

no longer being used.

The only reason we needed those category I DS was

to create the relationships in the first place.

Um, I'm not exactly sure How about the internal surgeon

here for, but yeah, I I know that these particular

keys are no longer in use.

Um, they're just kind of They're just like any other

property at this point, if that makes sense, Um, but

yeah, you can't like I mentioned before with the delete.

You can't delete a node that has outgoing relationships without

using detach delete.

Because we could try that, Actually, let's do that because

we're at the end, anyway.

Um, C category.

Let's just try to delete to see, hopefully this won't

work.

Because if it did, yeah, this is what happens if

you try to delete without detach.

And there are relationships.

It will just basically say it has relationships.

You must first delete the relationships.

Um, but of course, the way around that is to

use the touch.

Uh, it's Yeah.

Might as well do this now.

So that just removes all categories and all relationships attached

to those categories.

You can see it just took out 77 of those.

So now there's nothing to do with categories and a

graph.

Um, so yeah, Any questions about that?

Yeah.

Um, so yeah, that's updating.

Deleting.

We've seen that you can delete specific things.

Like you want to delete the product with the name

of tofu.

I'm I'm sure you can sort of understand how to

do that using Yeah, it's already here.

So just looking for specific patterns and deleting it from

the graph.

And you can, of course, use the set to update

specific products as well.

And just before we go, I'll show you just deleting

an entire graph like I mentioned match in detach delete

in, and that will just destroy everything.

And now your graph is pretty much empty.

So don't do that unless you actually want to delete

your graph because it won't come back.

Cool.

Yep.

Yeah, there's a better view on it because I can't

anymore because the guys can't.

So you should find hopefully, after running that that only

the product with the product name of tofu will be

deleted.

Yep.

Sorry.

What was that?

Uh, the X at the top.

You mean this one here?

Uh, good.

Yeah.

Good catch.

No, it's not.

It doesn't.

It's Yeah, it's irrelevant at this point because you don't

even use it in the next part of the query.

So you could take that out and it would be

exactly the same.

Yeah.

Uh, any other questions?

Otherwise we'll probably wrap it up there.

I think it's almost 1 45.

So Yep.

Did you get the thing deleted?

Oh, yeah.

Good point.

Yeah, you got Yeah, because they probably had relationships.

Alright.

In that case, uh, thanks everyone for coming.

Um, Hope you enjoyed it.

Yeah, maybe prefer to take a look at the lab.

And good luck with everything.

Thank you.

All right.

See you later.

Give us.

Yeah.

Yeah.

Oh, yeah.

A graph.

Q.

Well, I don't think it's actually a graph.

Um, it's not like cipher.

I think as far as I know, it's for Web

applications and kind of like an API sort of language.

As far as I know, it's designed to kind of

look like a graph, though in the output.

Not 100% sure, but I'm pretty.

Yeah.

No, surprisingly not, um, I I built my h TCP

API s and stuff, but I haven't really used graph

Q too much, but I know it is pretty popular,

so Yeah.

Yeah.

So that's my research area.

Yeah.

So, um oh, you're taking the unit, right?

How are you finding it?

Yeah, Alright, that's great.

Um, so I I work on, like, information extraction.

So taking information out of text.

So, like named entity recognition.

If you come across that, Yeah, that kind of thing.

Um, I do knowledge graphs out of text as well.

Um, so, like, visualising data as a graph and asking

questions of graph in natural language, that kind of thing.

So, like, yeah, So you basically you're taking text.

You're doing name recognition, relation, extraction.

You're turning that into a knowledge graph, which you can

then query.

So all of that information that's actually captured in the

text.

You can then ask questions of it.

Yeah, I normally use near four J for mine.

Um, so, yeah, that's where the relationship is.

Between this and graphs, I guess it's Yeah.

It's a good way to represent texts as well.

No.

Yeah.

I think that um, yeah.

Um, honestly, it's been a while since I looked at

the project, because I Yeah, I'm not really involved with

it so much this year.

Um, but yeah, feel free to reach out to we

or one of the lab demonstrators, like or because the

problem is in our, uh, data.

Yeah, the one the The fact table is all the

column.

And it is the, uh, using the for the dimension.

So the fact table is actually just the numbers, right?

Yeah, it's It's a it's a it's a It's a

backless back table which has a column say crime count

on top, which has only got one for every crime,

the crime, because there's no actual measure of values in

our fact.

Right.

OK, so you're thinking about how to represent that as

a graph.

Is that that's why that's why I was That's why

I originally asked that question in In, In the in

the brain.

I guess another question which I find interesting was you

said you can delete I DS which are properties.

If you define a relationship in the graph based on

those I DS, then you later delete that ID.

Does that delete your relationship?

No.

So the reason we can do that is because so

when we loaded the c SPS.

Yes, we're using that ID to know where to put

the relationships.

Yes, but it doesn't actually capture that in the That's

what my underlying question, because in a in a relational

database, if you happen to you, can do that stuff

up the data.

So at this point, after you've already created the relationships

with neo four, you don't really need the ID anymore.

So my my my question was, is the i DS

or the relationships defined in the metadata within the near

it?

Probably It probably would be, I would imagine.

I don't exactly know the internal storage.

That's what it be.

The same thing, though it wouldn't be the category ID

property.

No, no, but it it sort of a relationship between

a row in this table and a row in this

table in a sorry in a relational database.

You do that through a foreign key.

And so it would be stored somewhere, but it wouldn't

be related to the category.

ID.

It's a it's a separate thing.

That's what I was asking.

So so you you basically matching this row with this

row?

Not through I ds and it will intellect.

So in other words, it's got its own internal primary

keys that it keeps inside for and you can't get

to see it.

All you get to see is the properties.

Pretty much, Yeah, I'm not 100% sure about the storage,

but yeah, it it will give you something like that.

It's kind of good.

I I come from an Oracle database.

I'm an oracle DB a So I work in the

industry since 97 98.

So I'm just This is my first year class level.

Cool.

But, um, yeah, I I deal with data base all

the time, So that's why I'm curious about it now.

I'll go look it up.

Yeah, Another one is, um yeah, as you said, it

does.

Summation.

Does it have analytical functionality?

uh, there's graph data science, which is pretty useful.

No, no.

Like in Have you used oracle or not?

Really?

No.

So in Oracle, you can do things like dense rank,

so you can actually do a select statement and you

can actually rank it.

And you can petition the data so you can petition

the data by, say, for an example a month.

But then you want to order that month by by

date.

OK, so you can go 1 to 10 and then

it will go back to 1 to 10 and things

like that, you can do that in Oracle.

Not sure I have to have a look.

I wonder if it has that type of power.

It does have a lot of different libraries and things.

There's a library called a, which is like advanced procedures

for cipher that has a lot of the extra you

can add on API data.

Science is another plug in, so there's many plugins you

can use.

A is a good one for analytical stuff.

You probably I think, see it next week, as far

as I know.

Not 100% sure, but OK, nice to meet you.

My name is Rodney, by the way.

Oh, nice to meet you.

Good to meet you.

Yeah.

Sorry.

My, like the dimension table.

We have, uh, the old, um practises.

Hm.

Uh, new fact to work.

We all have the key.

So we use the for the so our factor.

We it actually should be the, um, the real thing

in the dimension table.

Not just a key.

Um, I'm not quite sure what you're asking.

Sorry.

So that the keys probably wouldn't need to be stored.

Actually, in the graph is that if that answers your

question, I'm not sure.

Um, because because you use, uh, you I the all

the e CV into the new four g.

So all the CV you should like, for example, in

all the effect table on the dimension tables.

But this fact table, we only got the other dimension

tables.

Key key numbers, but not the real thing of the

dimension table.

Like the day is just a 1234.

But not the real days.

Right?

I think you used the You would use the key.

Yeah, So I have to use the, uh, make sure

the track use the real not just the I'm sure

there'd be a way to structure your query so that

you're loading in.

Yeah.

So you would use the keys as a way to

know how to link the data together like we did

in the in the lecture.

It was kind of you get.