这是个课堂录音，你来说说老师说了什么
page_content="I would like that.  I do that last night.  Yeah.  What can I do?  OK, Good afternoon, everyone.  Um, hope you all had a nice week.  Let's get started.  I So let me try to operate on both computers.  Difference that else.  Uh, see what I can log into, right?  It's what I want.  Yeah.  So you got tell.  Yeah, It Yes, you.  And past 10.  Yeah, OK, just bear with me.  I'm trying to get, um, both screen working.  I know.  Yeah, I see that text.  12.  Yeah.  So she got we ready?  Thank you.  Mhm.  You fine.  How many?  How do I present this You so much.  OK, so I'm trying to get two screen working so  I can do a bit of demo while I go  through the lecture slides.  All right, So, um, we've done quite a few things,  uh, in the past couple of weeks, uh, in terms  of graph databases and I've seen in the labs this  morning, um, everyone is, uh, geared up and, uh, imported  using the e c l to, um, using for, um,  you know, basically converting your relational, uh, star schema, uh,  into a graph database.  So that's only one way of doing that.  Um, so I will use today's lecture to introduce two  other ways.  One.  Um, actually, I think Michael did the, uh, load CS  v last week.  Um, so I will, um, use this lecture to introduce  something called, uh, awesome procedures.  Uh, in CIA.  Uh, so a PC, um, is a very useful, uh,  library, uh, for importing data and do all sorts of  queries.  That is, um, solving the limitation of C A.  Um so it's a community plug in, but it's very  powerful.  So I'll use that to introduce how you can import  Dina mic relationships.  Uh, rather than just a single relationship at a time,  Uh, into your, uh, new four j database.  So, um, having said that, we have basically, um, at  a higher level, three different ways of loading your data,  uh, inside a graph database.  So given a relational database design that you already have,  you could easily use the e t l tool, the  new J E T l tool, uh, without any programming.  Basically, so you can just load things very quickly into  your graph database.  That's what I call quick, fast prototyping.  So if you really want to try something out, and  then test out some queries and, um, see how things  work.  Um, maybe at the same time, trying to criticise this  relational database design.  Um, that's the way to go.  That's your very first step.  Um, And then once you, um you know, explore a  little bit you find maybe I should create some new  notes.  Maybe I should create some relationships, new relationships.  What do I do?  You don't necessarily go back to your relational database again.  Instead, you will create a CS v file.  Or maybe the CS V could be generated or created  using python create a CS V file using low CS  V um, coupled with, um, some advanced functionalities in a  O.  C.  Um, you will be importing extra data, uh, into your,  uh, graph database.  So that definitely shows, You know, the the the key  differences, um, between, um, relational and, uh, graph database relational  database.  You have to design your schema and get it fixed  up front.  Um, once you have to, you know, make changes.  You have to redesign everything and reload everything.  Right?  So but graph database is additive.  You can progressively add new things in, uh, without, uh,  interrupting the the overall structure of your graph database.  Certainly.  It's at the cost of, uh, integrity.  Um, because sometimes things if you don't check it programming,  uh, or using certain, uh, gatekeepers in your programme you  might run into, uh, inconsistencies.  But that's something that you need to keep in mind.  So my task today is to introduce advanced cipher, um,  and then this awesome, uh, library of, uh, procedures that  you can make use of.  So I will try to use both screens.  Uh, so one side is the slides, and the other  side is the demo.  We'll see whether we can go through this number of  slides as we go along.  Uh, but the very first part is we still stay  in CIA.  Uh, the plane cipher.  We will try to introduce, uh, functions, uh, for aggregation,  Um, and other, uh, reasonably useful, uh, cipher clauses.  Uh, so you can see that the first, uh, section  and this is, you know, recap, cipher, aggregation.  And then we move on to a O.  C.  And then after that, uh, we'll introduce, um, even more  advanced concepts such as pass expansion, uh, in cipher and  then also, um, how we do, uh, pass expanding or  using the A PC pass expander, uh, to, uh, search  multiple hobs away, Uh, in your, uh, um, graph database.  And then we introduce, um, virtual nodes and virtual patterns  or virtual path.  Um, and then ultimately, uh, virtual graph.  So the nodes are a virtual node which are not  physically, um, um, exist in your, uh, in your, uh,  graph database.  OK, so let's get started.  Um, the first, uh, database I'll use, um is called,  um it's about people and cities.  So if we navigate to the path of where the  datas are, uh, so remember, uh, when we introduce low  CS V.  We have to, um, put our CS.  V file, uh, in a default folder, um, so that  new four G can find it.  So I'll just quickly navigate to my default folder.  Um, sorry I've got So that's on my hard disc  and then users.  And then this is my new four j home.  So under the new four J home, I have the  data relay data, and then, um, I have, uh, DB  MS.  So one of the databases that I created yesterday I  think, um, is this one and then I go to  import, Uh, so this is about the, uh, the other  the words relations that I want to demo.  But let me go back to they have the one,  um So that's the trouble of finding you know, where  these datas are because the database is, um, identified using  a unique identifier rather than a proper name.  Um, so maybe maybe it's today, this one that I  worked on, so I've got to import.  Sorry, there's a bit of OK, yes, this one.  It has the information about C DS.  Um, so I have people live in, um, cities, Uh,  so you can open it up in an excel, and  then, um, take a look at the data first.  So the first column, um, is person's name, and then  the second column is C.  T.  So it really is the person identifier.  And then the CD identifier.  So we assume that every person has this unique name.  Uh, but if you have people that have, um, you  know, common names, um, then you probably need to use  ID in this case.  So this is just a very illustrative kind of, um  example.  So we make very simple assumptions.  And then for each person, um, we have an occupation.  So just keep the data set in mind.  And then we have, uh, relationships between people.  OK, so so we have three CS v files.  Um, and as you can see this relationship, um, could  be, you know, uh, separated into two separate CS V  files.  One is only about follows, and the other one is  about nodes.  OK, so these are two different relationships, but we keeping  it inside one single CS v file.  Um, and this can be only I mean, this can  only be imported using a, um, using cipher.  Uh, load CS v.  You won't be able to incorporate dynamic relationships, so you  will have to keep, um, all the relationships of nodes  into one table and all the relationships into follows into  another table.  Um, and then you import or load CS V twice.  OK, imagine that you have lots of relationships, so you  could be friend with, um, family with and high school.  Um, you know, mates and different kinds of relationships.  Once you have multiple relationships, this becomes the low CS.  V becomes quite limited.  So you can't really use, um, cipher low CS V.  Instead, you will use a OK, um, so just keep  that in mind.  Um, and we'll introduce the syntax as we go along.  How do I never get it?  OK, so a quick recap, Uh, when we have, um,  uh, notes of label person and another node with label  company, uh, we would write, uh, in brackets, so in  brackets indicate this is a node.  Um, inside the bracket, we specify the label.  Uh, we specify the attribute.  Um, uh, or the property value pairs.  And then, um, the other node is specified in similar  ways with inside, um, a pair of round brackets.  Uh, so the round brackets, uh, inside that we have  label.  And we have, um, property value pairs, um, to uniquely  identify a single node.  So we have node and node, and then we have  the hyphen to indicate the start of a relationship.  And then this, um, column, um, followed by the type  of the relationship.  Um, inside a pair of square brackets, um, gives us  a pattern.  Gives us a path, uh, saying that Jennifer, um, works  for, uh, a company called Neo.  So it's almost like, you know, playing English.  And it's fairly easy to navigate.  Um, but just bear in mind of all these punctuations  and all these, um, different types of brackets.  So curly brackets is for property value.  Pairs run brackets is for nodes, and then square bracket  is for relations.  OK, so I don't know how I move to the  next slide.  Oh, here we go.  Um, and then we, uh, last week we looked at,  uh, create, uh, merge and low CS V.  Uh, so merge is very useful so that you don't  create duplicate um, nodes.  Um And so when when you create unique ones, um  or, uh, brand new ones you will use create.  But if you have, um, existing nodes already you would  use merge.  And we looked at low CS V, uh, match and  return classes and the filtering using the ware classes very  much similar to S E O.  Um.  And then we can set a variable.  Um, you know, on the fly.  So you could basically add a new property value pair  to a node using the set.  Um uh, class.  And certainly you can remove a note and then you  can detach delete, um, to remove things.  Um, And then, uh, we also briefly looked at wise.  So the wise class is very useful, which basically, um,  worked as a channel that channel through what you've already  got, uh, previously, uh, so in terms of, uh, a  variable and then passed it to the downstream.  Uh, colossus.  OK, so we'll see the use of these, um, many  times.  Um, today.  Um OK, so the several query, uh," metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="be able to incorporate dynamic relationships, so you  will have to keep, um, all the relationships of nodes  into one table and all the relationships into follows into  another table.  Um, and then you import or load CS V twice.  OK, imagine that you have lots of relationships, so you  could be friend with, um, family with and high school.  Um, you know, mates and different kinds of relationships.  Once you have multiple relationships, this becomes the low CS.  V becomes quite limited.  So you can't really use, um, cipher low CS V.  Instead, you will use a OK, um, so just keep  that in mind.  Um, and we'll introduce the syntax as we go along.  How do I never get it?  OK, so a quick recap, Uh, when we have, um,  uh, notes of label person and another node with label  company, uh, we would write, uh, in brackets, so in  brackets indicate this is a node.  Um, inside the bracket, we specify the label.  Uh, we specify the attribute.  Um, uh, or the property value pairs.  And then, um, the other node is specified in similar  ways with inside, um, a pair of round brackets.  Uh, so the round brackets, uh, inside that we have  label.  And we have, um, property value pairs, um, to uniquely  identify a single node.  So we have node and node, and then we have  the hyphen to indicate the start of a relationship.  And then this, um, column, um, followed by the type  of the relationship.  Um, inside a pair of square brackets, um, gives us  a pattern.  Gives us a path, uh, saying that Jennifer, um, works  for, uh, a company called Neo.  So it's almost like, you know, playing English.  And it's fairly easy to navigate.  Um, but just bear in mind of all these punctuations  and all these, um, different types of brackets.  So curly brackets is for property value.  Pairs run brackets is for nodes, and then square bracket  is for relations.  OK, so I don't know how I move to the  next slide.  Oh, here we go.  Um, and then we, uh, last week we looked at,  uh, create, uh, merge and low CS V.  Uh, so merge is very useful so that you don't  create duplicate um, nodes.  Um And so when when you create unique ones, um  or, uh, brand new ones you will use create.  But if you have, um, existing nodes already you would  use merge.  And we looked at low CS V, uh, match and  return classes and the filtering using the ware classes very  much similar to S E O.  Um.  And then we can set a variable.  Um, you know, on the fly.  So you could basically add a new property value pair  to a node using the set.  Um uh, class.  And certainly you can remove a note and then you  can detach delete, um, to remove things.  Um, And then, uh, we also briefly looked at wise.  So the wise class is very useful, which basically, um,  worked as a channel that channel through what you've already  got, uh, previously, uh, so in terms of, uh, a  variable and then passed it to the downstream.  Uh, colossus.  OK, so we'll see the use of these, um, many  times.  Um, today.  Um OK, so the several query, uh, here, um, as  you can Perhaps, you know, just read by looking at  this, Um uh, statement or clauses.  The match class says, um, I have a person with  a name gim.  Um, and then this g knows, Uh, some people.  OK, I want to return this Some people.  So basically, um, the people that James knows, Um, so  this is James as a note and then has an  outgoing link to a person.  OK, so this, uh, person would be, um, that, you  know, have a incoming connection.  Uh, but that incoming connection has to be g uh,  has to be Jim.  So Jim knows that person.  So it's basically, uh, the the the person, uh, Jim  knows of.  OK, um, And then what we can do is we  could chain this up.  So, um, Jim knows this person, and this person also  knows some other person.  Um, so we have, uh, created, um a, uh, relation  of a, uh knows a also knows c.  So So this is basically, um it's not necessarily transitive,  but we want to extract out, uh, people who, um  not only g knows of, um, through a third person  or through a middle person.  B uh, but also directly.  They know each other.  OK, so, um, because, um Jim know Mary Mary?  No, Bob.  Jim may not actually know, Bob.  OK, so But we are trying to extract, um, this  relation or patterns that says, you know, um, this Gene  also knows, uh, this other person's friend or other person's,  um you know, uh, what do you call it?  You know, someone.  Uh so So in the in the knowing circle, Um,  um, they know each other directly, so that's, uh, a  way of combining different match clauses.  Um, trying to return the result.  Um, so with data warehousing, what we want to do  most of the time is actually aggregation.  So how do we do aggregation.  Uh, in, uh, graph database.  So graph database, actually, um, allows you to do similar  things, Um, as relational database.  So I want you to actually actively think about, um,  the, uh the cube idea, the the dimension aggregation, the  drill down and the roll up that we introduced early  in the semester.  Um, and see how this can be implemented, Uh, in  a graph database query.  Um, so, um, that will be your your active, you  know, skill set in terms of connecting what's in the  relational data warehousing, um, and this graph database.  So we could, uh, for each person list the number  of friends they have.  And, um, for each movie, we list the, uh, the  name of all the people who watch the movie, Um,  and so forth.  So this allows us to do aggregation.  Uh, So, for example, if we want to list the  number of friends, uh, for each person, what do we  do?  Uh, so we have this database already loaded.  Um, So before you start anything, um, the one thing  to look at is once you create, um, a database  in U for J.  Um, you will need to, um, check, uh to see  whether your plugins, um, are installed or not.  So, I before I start, I click on open and  that opens this up open this little tab on the  right hand side up.  Um, so this little tab click on, uh, plugins.  And then you check to see whether a PC is  installed or not.  So if it's not installed, I click on install.  Uh, so so long as you have Internet net connection,  apo will be installed almost instantly.  Um, And then the other thing that we will talk  about this graph data signs so you could install that  as well, but not today.  We're not gonna, uh, we're gonna do that next week,  so but these are the two plugins or two libraries  that we're gonna make use of.  And as you can see from this little description, the  A.  O.  C.  Library consists of many, which is about 450 procedures and  functions, Um, for us to use.  So that's a very powerful one.  Um, and then once you've double checked that you've installed  the right plug in so you can make use of  the functions and procedures in a PC, you can start  your um, graph database.  So it takes a while.  Uh, my computer, uh, memory and processing power is quite  limited.  So while we waiting, can people just give a guess?  Um, of what will be the, um, construct or the  function to use to count the total number of friends  count?  Yes.  So it's very simple.  So instead of returning the node, um, of person two,  we can count How many?  Uh, the the, um how many, uh, person notes that  we have returned.  So it's basically inside your return clause.  OK, so now I can open the browser, and, uh  so I I will also take this opportunity to look  at, um, you know, the the different buttons that you  see, uh, in the new four g browser.  So, um, as you can see, this new four g  browser is, um, quite, you know, clean in the sense  that you can easily find things out, but a lot  of time that we don't really make use of these  buttons.  So this button here, once you load your data in,  you can see this, Um, like a a summary of  what you've got.  So in this, uh, particular database, I have 575.  Uh, sorry.  517 notes.  Um, and then I have all kinds of labels, uh,  indicating the occupation.  Um, of Yeah.  Oh.  Oh, OK.  What's going on here?  Yeah, that's the trouble of not having this for, uh,  I can minimise it.  Or I can swap this two to cut over.  No.  Better, but still, I mean, yeah.  Um So how about let's swap the two screen?  Because the demo is probably more important.  How does that look?  Is that good?  OK, yeah, It's a pity I can't figure out how  to get the screen down.  OK, so, um, with the database, um, you get a  good summary of, uh, the node labels and the total  number of nodes, and you also have a summary of  the relation types.  Um, you even have the keys for the properties.  So the, um, the attribute names, for example.  Um, So, um, and then some other information.  Um, you connect it as, uh, new for J, the  user name.  That's the default one and et cetera.  So that's not that useful.  But all up to property keys, um, and no labels.  I I've seen a lot of students using match and  return and trying to see whether the node had been  loaded in properly.  Uh, but this is already a good way.  Um, of you can even click on this, um, to  see all the actors and all the attendants and then  even, uh, the follows relationship.  OK, so that's a very useful summary of your database.  Um, and then the other, very useful one is this  little star, which keeps a collection of all the scripts  that you've written in the past.  It's not specific to this particular database.  Um, everything that if you written, uh, inside this new  four G browser, you can click on this little star  on here and then save it to the left hand  side.  Um, and one good habit is to create a folder.  Uh, because otherwise everything will be mixed up, and and  you you probably don't really know what, uh what is  what?  Um, so I've created folders, uh, that named according to,  um, you know, the database that I want account.  So, for example, I will use I'm using the person  and CD relationships.  Um, uh, or data set.  Um, I basically can just go into all these past,  uh, that I've saved, um, and rerun things, Um, as  I go along.  OK, so so that's a a good habit to" metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="use to count the total number of friends  count?  Yes.  So it's very simple.  So instead of returning the node, um, of person two,  we can count How many?  Uh, the the, um how many, uh, person notes that  we have returned.  So it's basically inside your return clause.  OK, so now I can open the browser, and, uh  so I I will also take this opportunity to look  at, um, you know, the the different buttons that you  see, uh, in the new four g browser.  So, um, as you can see, this new four g  browser is, um, quite, you know, clean in the sense  that you can easily find things out, but a lot  of time that we don't really make use of these  buttons.  So this button here, once you load your data in,  you can see this, Um, like a a summary of  what you've got.  So in this, uh, particular database, I have 575.  Uh, sorry.  517 notes.  Um, and then I have all kinds of labels, uh,  indicating the occupation.  Um, of Yeah.  Oh.  Oh, OK.  What's going on here?  Yeah, that's the trouble of not having this for, uh,  I can minimise it.  Or I can swap this two to cut over.  No.  Better, but still, I mean, yeah.  Um So how about let's swap the two screen?  Because the demo is probably more important.  How does that look?  Is that good?  OK, yeah, It's a pity I can't figure out how  to get the screen down.  OK, so, um, with the database, um, you get a  good summary of, uh, the node labels and the total  number of nodes, and you also have a summary of  the relation types.  Um, you even have the keys for the properties.  So the, um, the attribute names, for example.  Um, So, um, and then some other information.  Um, you connect it as, uh, new for J, the  user name.  That's the default one and et cetera.  So that's not that useful.  But all up to property keys, um, and no labels.  I I've seen a lot of students using match and  return and trying to see whether the node had been  loaded in properly.  Uh, but this is already a good way.  Um, of you can even click on this, um, to  see all the actors and all the attendants and then  even, uh, the follows relationship.  OK, so that's a very useful summary of your database.  Um, and then the other, very useful one is this  little star, which keeps a collection of all the scripts  that you've written in the past.  It's not specific to this particular database.  Um, everything that if you written, uh, inside this new  four G browser, you can click on this little star  on here and then save it to the left hand  side.  Um, and one good habit is to create a folder.  Uh, because otherwise everything will be mixed up, and and  you you probably don't really know what, uh what is  what?  Um, so I've created folders, uh, that named according to,  um, you know, the database that I want account.  So, for example, I will use I'm using the person  and CD relationships.  Um, uh, or data set.  Um, I basically can just go into all these past,  uh, that I've saved, um, and rerun things, Um, as  I go along.  OK, so so that's a a good habit to to,  uh, keep track of what you've done.  Uh, rather than throw things away, Um, you can even  save it.  Um, you know, once you finish and you finish the  exploration and you can save it into, um, a dot  cypher file or, um, maybe just a plain text file  so you can make use of it later on.  Um, so that's just a a bit of, uh, you  know, um, recap of what's going on here.  Um, and then we certainly can do the the counting.  Um, I will not demo this because it's fairly easy.  Um, and then with the count, um, So maybe I  I do a bit so, um, and say match.  Uh, let's pick a name, pick a simple name and  t.  Yeah.  So match.  Um, and then I can specify a variable person.  Um, so this is lower case person, and then I  can say the name is, um uh is easier.  Sorry.  Bab is a capital B.  Make sure you put the quotation marks around it because  it's a string.  And then, um, the pattern that we want to find  out.  So remember, um, patterns or relations are inside pair of  square brackets.  Uh, so instead of friend, we we have, um, follows  or nos OK, so it follows.  And then we have the second person that we're interested  in.  So p two is a person.  Obviously, you can specify other things.  So if we just want to, uh, find out all  the dancers bad follows, um, then we could replace this  with dancer.  OK, so that's, um a pattern specified.  And then we want to return this.  And then if we want the name, this person's name,  and then we can count how many?  OK, uh, so p two and I can specify, um  number of, uh, specify a better, more meaningful, uh, name,  uh, so follows number of, um, people fab for those.  OK, so you can see that it gives you a  count.  How many people that, um uh, babs Bab follows.  So only two people be follows, but I might want  to know you know who.  Um, he's following.  So if you work on the slides a bit further,  um, we can use the keyword or the clause.  The function.  Sorry.  The function collect.  Um, instead of just having, um, account, we can actually  return a list of who that actually follows.  OK, so you can see these are the two nodes  get returned.  Um, so maybe we don't need the node.  Maybe we just want to I mean, certainly you can  look at the graph.  Um, in between.  Right.  So this is, um, gas and, uh, Pristina, Uh, that  they follows.  So if I If I return the just the node,  then I'll be able to see the graph.  Right.  Um, if I just want to return the name, I  get a list.  OK, so I get I don't get a graph.  If I don't return the node, you can see that  the two followers name are collected at the least returned  back to you.  OK?  And then you have all these, um, aggregation functions.  Um, that you can make to make use of this  is very similar to, uh, CEO and very similar to,  um you know, uh, the the, uh, structure query language  that you have used before.  So what do we use that for?  One other thing that you could do um, is look  at the sample scripts.  So these sample scripts are not your scripts.  These are provided by new for J.  Um, so one thing that we could look at is  the data profiling.  Um, as you can see, we can count all notes.  So this gives you, um um a A skeleton.  Um, That you can replace this match with a particular,  uh, match class, Um, with filtering by names by other  properties.  Um, and then you can use the function count, and  then you can count all relationships.  Um, so these are basically, you know, one node, um,  connected with another.  Doesn't matter what type of relationship it is.  So we can return a count of all, um, relations.  And then you can, um, display the constraints and index.  This is less useful.  Uh, we can list all the node labels.  Um, this is very useful.  So when you use this procedure, you call DB dot  labels and will return all the labels for you.  So I have, um this many different labels, um, inside  my, uh, database.  And then, um, you can also list all the relationship  types.  Um, so that's, um uh I only have uh, follows  nos and leaves in.  So that's three different relation types.  Um, I have.  So obviously you can do it.  Um, from here.  Um, but, you know, this is a programmable way of  using cipher to look at your, um uh uh, your  your overall, uh, data, uh, that you have.  Um, so what is related and how, um is something  called, uh, schema?  OK, so remember, this is what you get.  Um, after you connect to a relational database, Um, if  you remember, uh, using the e t l tool.  Um, you you actually that the schema, uh, graph generated.  Um, sometimes it is also called as met graph.  Um, so in a it's called Met graph in, um,  cipher.  Uh, it's called schema graph.  So we can visualise the schema, uh, at a higher  level so you can see, uh, that we have in  here.  We have actors and related to engineer and lecture related  to um, yeah, so it's It's a messy graph, but  it's basically indicating people's, uh, relationship.  Um, OK, so that's a very useful one.  Um, after you finish creating your graph database, I would  strongly suggest you to do a DB dot visualisation and  then capture your screenshot and see, you know how your  actual implementation, uh, differs from your initial design.  OK, so your initial design is arrow, uh, using the  arrow app.  Um, but your actual implementation might be differing a little  bit.  That's fine.  Yeah, And then the other more, uh, useful thing is  called, uh, this data profiling, uh, what kind of nodes  And then, um, the size of keys.  Um, so how many keys?  Um, average number of keys and then so it's keys  is basically a function returning the number of properties, uh,  for each node, and then you can apply the average  and Min and Max, um, on it.  Um, so if you look at the lecture slides, uh,  we have, um so I'll go back to that.  Um, but I'm doing data profiling already.  Um, so as you can see, we have cipher, um,  clauses that does similar things.  For example, when you try to get all the labels,  you could match and return distinct labels and OK, so  it's like match and return n.  But instead of return n, you return the distinct labels  of N.  That's the same as calling DB dot labels.  And similarly, um, you can match a relation or pattern,  uh, a relationship using, um, and any relationship related to,  um A So you could even replace the n with  brackets.  Um, and then we return distinct type.  OK, so we so we we use type for relationship,  But we use labels, uh, for nodes.  So the distinct types of relationship you can use this  match class as well.  Um, an easier way is to use the DB dot  relationship types.  OK, so, um and you can find all notes that  are, uh, disjoint, uh, basically saying nots that do not  have any relationship with other nodes.  So here, instead of, um, just and related to something,  I I have a negation here, so I return all  the notes that doesn't have any relations.  Uh, with So basically they are, or they are.  They are isolated, um, notes.  And then, um, this one is returning.  Um, the nodes that have a attribute" metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="So that's three different relation types.  Um, I have.  So obviously you can do it.  Um, from here.  Um, but, you know, this is a programmable way of  using cipher to look at your, um uh uh, your  your overall, uh, data, uh, that you have.  Um, so what is related and how, um is something  called, uh, schema?  OK, so remember, this is what you get.  Um, after you connect to a relational database, Um, if  you remember, uh, using the e t l tool.  Um, you you actually that the schema, uh, graph generated.  Um, sometimes it is also called as met graph.  Um, so in a it's called Met graph in, um,  cipher.  Uh, it's called schema graph.  So we can visualise the schema, uh, at a higher  level so you can see, uh, that we have in  here.  We have actors and related to engineer and lecture related  to um, yeah, so it's It's a messy graph, but  it's basically indicating people's, uh, relationship.  Um, OK, so that's a very useful one.  Um, after you finish creating your graph database, I would  strongly suggest you to do a DB dot visualisation and  then capture your screenshot and see, you know how your  actual implementation, uh, differs from your initial design.  OK, so your initial design is arrow, uh, using the  arrow app.  Um, but your actual implementation might be differing a little  bit.  That's fine.  Yeah, And then the other more, uh, useful thing is  called, uh, this data profiling, uh, what kind of nodes  And then, um, the size of keys.  Um, so how many keys?  Um, average number of keys and then so it's keys  is basically a function returning the number of properties, uh,  for each node, and then you can apply the average  and Min and Max, um, on it.  Um, so if you look at the lecture slides, uh,  we have, um so I'll go back to that.  Um, but I'm doing data profiling already.  Um, so as you can see, we have cipher, um,  clauses that does similar things.  For example, when you try to get all the labels,  you could match and return distinct labels and OK, so  it's like match and return n.  But instead of return n, you return the distinct labels  of N.  That's the same as calling DB dot labels.  And similarly, um, you can match a relation or pattern,  uh, a relationship using, um, and any relationship related to,  um A So you could even replace the n with  brackets.  Um, and then we return distinct type.  OK, so we so we we use type for relationship,  But we use labels, uh, for nodes.  So the distinct types of relationship you can use this  match class as well.  Um, an easier way is to use the DB dot  relationship types.  OK, so, um and you can find all notes that  are, uh, disjoint, uh, basically saying nots that do not  have any relationship with other nodes.  So here, instead of, um, just and related to something,  I I have a negation here, so I return all  the notes that doesn't have any relations.  Uh, with So basically they are, or they are.  They are isolated, um, notes.  And then, um, this one is returning.  Um, the nodes that have a attribute called name.  So basically, it's not returning.  Um, the, uh, particular name.  It's basically saying, you know, um, any nos that with  the name attributes, uh, will be returned.  Ok, um and this is you know, any relationship with,  um, a type origin will be returned.  Um, and then you can do met graph or schema  graph.  Which is, uh, what I just showed you, uh, a  minute ago.  Um, so the the default code in here is, um,  some part, especially this part is obsolete.  So if you run this, if I run this here,  um, it will give you an error.  So it will say a pattern expression should only be  used in order to test the existence of a pattern.  Um, and then it keeps going on, uh, saying, you  know, uh, no other use is allowed, and you have  to use something called a pattern comprehension.  Um, so I will introduce, uh, pattern comprehension, uh, in  a minute.  But before that, um, do you guys remember what, um,  list comprehension in Python is OK, so this is the  cipher way of doing something pic, um so cipher have  this pattern comprehension and also least comprehension.  We'll introduce that in a minute, but here, in order  to fix this error, what we need to do is  we need to have this, um, pattern comprehension.  Uh, so I have a pattern where a node is  related to another node.  And then basically, I collected the relationships inside a list.  So all the relationships, um, I've collected So, um, when  the node is linked to another node, all the relationships  I've collected here, um, is treated, um, as a list.  So I construct a list as I go through every  relations, um, or every relationships in my graph and note  that I have used this pipe.  OK, so this, uh, bar this pipe notation to indicate,  um, I'm collecting every single r, um, inside, um, into  a list.  OK, so this is and this list is called all  relations.  OK, so this is a 4.3 new four j thing.  Um, so before 4.3, uh, this other syntax is allowed,  but it's now much more, um, syntactically, uh, rigid or  synthetically, uh, making more sense.  Because, really, you know, the previous previous slides here, it  doesn't really indicate that I I have collected a list  of relations.  Um, and then, uh, the function size on something that  is not the least doesn't make sense.  OK, so that's why they have improved it, uh, by  introducing this pattern comprehension.  So we have collected um, a list of relationships.  Um, and then we name it with this.  All rails, uh, variable.  So instead of using the class, I can basically we  literally replace this All rails with this pattern comprehension.  OK, with this square brackets, I get the same results.  Um, but anyone could think of you know why I'm  keeping it as a variable, so exactly, So you can  use it.  You can collect it once and use it multiple places.  Um, when you have large graph, if you do this  again and again, um, multiple times, even though you get  the same results, your computation cost is unnecessarily huge.  Ok, um, so that's why it's better to use the  Wi class.  As I said before, this class is like a funnel.  Uh, that connects, uh, what's before and after?  Uh, so it it connects the end.  It passes the variable end the value end, um, and  passes this all, uh, rails or all relationships variable to  the downstream, uh, or downstream queries.  OK, so, um, recap again.  So recall what we have learned in python.  Uh, where instead of writing this ugly follow up, we  can really use this list comprehension.  Uh, to say, You know, for this X in this  follow.  Um, So, um, this, um a, um is in X,  so this condition is met.  I will return the X.  Um, and then this, uh, multiple X values will automatically  create a list for me.  Um, without this list comprehension, we have to write a  follow up and then with, uh, within the follow up,  you write if statement, and then you create an empty  new list so that you can append the new values  in OK, so a lot of people actually find this,  uh, more intuitive.  Um, but as you become more proficient, you will find  this is just so easy to use.  OK?  And similarly, we have this list comprehension in cipher.  Um, I'm gonna use this example, uh, of, uh, a  person, um, acting multiple movies.  Um, so as you can see, uh, instead of writing  the title of the movie in, I'm actually using labels  to label this, uh, graph.  Um, that's just a, uh, alternative way of doing things.  Um, as you can see from, uh, this new four  g, uh, desktop.  Uh, so maybe I can look at a graph that  we returned So in this little graph here, um, I'm  actually using the person's name, um, as, um, a caption  or as a label that's displayed on the note.  Uh, but in certain, um, other, uh, cases, people might  want to display this as the, um the the label  or or the type.  Um, uh, the label of that node.  So, uh, instead of doing, uh, the name, I could  display the attendant.  So how do we do that?  So you can click on this, and then you can  see the the name attribute is highlighted.  Um, I can use occupation to display, um, as a  display for the note.  So it's it's a personal choice.  Um, but I'm just illustrating, you know, you can choose  other attributes, um, as the caption for your notes.  And similarly, you can choose other attributes, Um, as the  caption for your, uh, relationships.  So, um, as this little graph shows us, we have,  uh, canoe ribs, uh, acted in multiple movies.  Uh, so let's see, um, I might need to Unfortunately,  I think I need to stop this new four g  graph and then start another one.  So I've prepared, um, a different database.  So that I won't really mix everything up, so I'll  quickly illus illustrate this, and then we'll, um, have a  break.  OK, so that's the, um, create statement.  You basically, you know, create a person called, uh uh  k and then kno Reeves is the actor.  And then, um, he acted in a list of movies.  So you create the personal, you create multiple movie notes,  and then you create, um, relationships between the actor and  the movie.  So all this, um, And as I said before that,  this is, uh, uh, a lecture constructed by looking at,  um, different web-based resources.  So these are active links, so you can click on  those links, and then, um, have a look at the  original blog or the original documentation.  So with this, uh, pattern, um, at least comprehension.  So let's let's start from a fresh um so if  I look at my database, I can see this database  has already, uh, been created with eight, uh, movies and,  um, eight.  Uh, sorry.  Eight NOs, uh, which include movies and persons and then  relationships, um, as acted in.  So if if we don't have anything, I can easily,  you know, just, um do a detach all or delete  all.  So as you can see, um, that I save this  delete all as a favourite scripts.  Because sometimes I I really have to, you know, delete  everything.  Um, So So you could match and and detach delete.  And And that's in your favourite.  And you could also do a show like match and  return and with the" metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="more proficient, you will find  this is just so easy to use.  OK?  And similarly, we have this list comprehension in cipher.  Um, I'm gonna use this example, uh, of, uh, a  person, um, acting multiple movies.  Um, so as you can see, uh, instead of writing  the title of the movie in, I'm actually using labels  to label this, uh, graph.  Um, that's just a, uh, alternative way of doing things.  Um, as you can see from, uh, this new four  g, uh, desktop.  Uh, so maybe I can look at a graph that  we returned So in this little graph here, um, I'm  actually using the person's name, um, as, um, a caption  or as a label that's displayed on the note.  Uh, but in certain, um, other, uh, cases, people might  want to display this as the, um the the label  or or the type.  Um, uh, the label of that node.  So, uh, instead of doing, uh, the name, I could  display the attendant.  So how do we do that?  So you can click on this, and then you can  see the the name attribute is highlighted.  Um, I can use occupation to display, um, as a  display for the note.  So it's it's a personal choice.  Um, but I'm just illustrating, you know, you can choose  other attributes, um, as the caption for your notes.  And similarly, you can choose other attributes, Um, as the  caption for your, uh, relationships.  So, um, as this little graph shows us, we have,  uh, canoe ribs, uh, acted in multiple movies.  Uh, so let's see, um, I might need to Unfortunately,  I think I need to stop this new four g  graph and then start another one.  So I've prepared, um, a different database.  So that I won't really mix everything up, so I'll  quickly illus illustrate this, and then we'll, um, have a  break.  OK, so that's the, um, create statement.  You basically, you know, create a person called, uh uh  k and then kno Reeves is the actor.  And then, um, he acted in a list of movies.  So you create the personal, you create multiple movie notes,  and then you create, um, relationships between the actor and  the movie.  So all this, um, And as I said before that,  this is, uh, uh, a lecture constructed by looking at,  um, different web-based resources.  So these are active links, so you can click on  those links, and then, um, have a look at the  original blog or the original documentation.  So with this, uh, pattern, um, at least comprehension.  So let's let's start from a fresh um so if  I look at my database, I can see this database  has already, uh, been created with eight, uh, movies and,  um, eight.  Uh, sorry.  Eight NOs, uh, which include movies and persons and then  relationships, um, as acted in.  So if if we don't have anything, I can easily,  you know, just, um do a detach all or delete  all.  So as you can see, um, that I save this  delete all as a favourite scripts.  Because sometimes I I really have to, you know, delete  everything.  Um, So So you could match and and detach delete.  And And that's in your favourite.  And you could also do a show like match and  return and with the limits.  Um um, because if if you don't specify the limit  that you return everything, then your, uh, graph will be  super slow.  So these are my favourite things that I keep as  a general, um, general favourite scripts to run.  So I don't really need to create anymore because I've  already created this.  Um, and then we can create, uh, we can look  at the pattern, uh, comprehension.  So pattern indicates I want to specify path.  I want to find a pattern.  So I firstly, uh, specify a note that I'm interested  in I and then I give it a name, so  this could be just end, but in order to make  it meaningful, I I named it as K.  Uh, So, um, is a person with the name attribute  that is, you know, um, so I want to return  the movies.  Uh, that, uh, is connected to OK, and then, uh,  the title of the movie needs to contain the word  matrix.  And then I use the pipe so that I can  collect these notes into a list.  But instead of collecting the notes I actually created, um,  the released, uh, date, um, as a, um as a,  um pattern comprehension outcome.  OK, so the release is basically years.  So I I basically have a collection or a list  of years that these movies, um, that ku worked on,  uh, the matrix movies that kno worked on, Uh um  as, uh, yes.  OK, so it's a It's a list of years so  spanning across from 2003.  So two movies in 2003, 1 in 99 9 and  then, uh, 2021 is, uh, the latest.  So this is, um, you know, you can see that  this is using this pipe, uh, together with the squared  brackets, uh, to do a pattern, uh, comprehension.  Um, and then this, um, pattern comprehension could also allow  us store information as a variable.  OK, so here I collect the movie titles instead.  Instead, of the the release, date or release year.  So I collect all the movie titles, and, um, this  time I didn't say that it needs to be, uh  the title doesn't need to be, uh, containing the word  matrix.  OK, so any movie that he worked in, um is  collected as movies, and then I use the set class,  um, to dynamically, um, introduce a new attribute called Re  Resume.  And this new attribute resume contains all the movie titles.  So it's a list of movie titles.  Um uh, worked on.  OK, so if now, if I run this, you will  see, um, that the, uh if I just match this  to see, um Oh, sorry too quick and then return  So you can see in this note.  Now, I have a resume.  Um, attribute Dynamically created, uh, with a list of, uh,  movies that he he worked on.  Um, so once we created that list, it's actually sitting  in your database already, and then we can make use  of that to do list comprehension.  So a least comprehension, um, is a syntactical construct in  cipher for creating a list based on an existing list.  OK, so this, uh, list comprehension code, as you can  see, because I have an existing list called, uh, I  basically says, you know, for any movie, uh, in this  list, um, if x contains, um, the key word.  The Matrix, The matrix, Uh, we can now return the,  uh, matrix list.  So at least the movie, uh, that with the, uh,  matrix, uh, inside its title.  OK, so as you can see that this, uh, matrix  related, uh, movies are now returned.  Um, as a list, this is, uh, list comprehension.  So, um, it's easy to understand syntax, but you just  need to remember, uh, that, you know, this is inside  a square bracket.  Um, and, um, if you have, you know, for example,  x dot title or something, uh, to, uh, to use,  and then you need to use a pipe.  But here is the least comprehension.  So, um, it's already created, uh, from previous list.  So it's definitely, um a simple, um, type or something  called homogenous.  Um, value, uh, that you can create.  So you can't really add two different types of value  so you can't mix strings and integers together, um, and  then return it at least.  But you can if it's all integers if it's all,  uh, strings.  All right, so, uh, let's have five minutes break.  Um, and then we'll continue on with, um, a PC  I mentioned at the beginning of the lecture.  If you have multi dynamic, um, relationship you can't use  e t l tool.  Right?  I'm suspecting because I'm getting error.  This is it, Like, map the metadata to, um, from  the data warehouse to mining.  So this is the mapping, right?  I Because if I do next and in data will  get a bunch of errors.  I suspect that it's because my fact table has multiple  references that correct.  So e t l two can't deal with that.  Mm.  I was talking more on the load.  CS B oh, e l two should be able to  deal with it, right?  If I just load like back table, I might, um,  Dimension tables.  You already got these relationships based on primary key and  foreign key.  Um, so it's not a different type of relationship, so  it's only 1000 right now, So yeah, you will try  to create all the labels and then get a bunch  of errors, which doesn't make sense.  Even though Yeah, yeah, yeah, yeah, Yeah.  Like all of these are coming from the J the  J D BC driver, which, like, it's just Java occur.  And it got, like, no reference point or something.  I Yeah.  So this query is probably somewhere in the J d  BC where we're trying to use the Hm?  Yeah.  So n dot b ID is Can you look at  your, um, new for browser?  Yes.  Uh, that would be here.  Yeah.  So I currently just loaded all the nodes.  There's no relationship.  So all the notes that picked on, um, the property  keys No, relationships have been.  Yeah, because it has it failed when you try to  the relationship.  So it was able to all the node.  That's why it says successful.  So it's on.  It's on.  Um, yeah, this one.  OK, you got database?  Yeah.  All of this is every every foreign key from the  centre fact table to 1234567.  Yeah, seven dimension table All failed.  So the foreign key failed.  It was able to import.  Yeah.  Yeah.  Have you checked this?  So you skipped a few because I have two factor.  One has every dollar 111 has every dollar.  One has 1000 so I'm taking the one that only  has 1000.  So fat crime has, like, $2 million in it.  So I'm taking all the ones that be the Mm.  Well, OK, so this one is connected to the share  server right now.  Yeah.  Yeah, yeah, yeah.  So database is Project one schema.  Is this one?  Oh, you say you have multiple tables?  Multiple.  Multiple.  Wouldn't that be the one that create trouble?  So if you have, if you have two crack tables,  uh, they have different names, and then it wouldn't be  able to figure out which one to use.  Well, the thing is, I got the same arrow, and  I was trying to pull the original one, which is  huge exact same arrow.  It doesn't matter how many more.  So and now I went to the lab.  OK, just make a smaller one.  Yeah, I don't think you need to make the smaller  one.  Um, yeah.  Yeah, but you can.  You can specify how much to I in.  Um, that's using, but that's it.  No, I think Here, uh, you see that?  Now you have a So I just skip all the  one that's Yeah.  So 21.  OK, so just if you just save it and then  next here.  So I But this is" metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="of the lecture.  If you have multi dynamic, um, relationship you can't use  e t l tool.  Right?  I'm suspecting because I'm getting error.  This is it, Like, map the metadata to, um, from  the data warehouse to mining.  So this is the mapping, right?  I Because if I do next and in data will  get a bunch of errors.  I suspect that it's because my fact table has multiple  references that correct.  So e t l two can't deal with that.  Mm.  I was talking more on the load.  CS B oh, e l two should be able to  deal with it, right?  If I just load like back table, I might, um,  Dimension tables.  You already got these relationships based on primary key and  foreign key.  Um, so it's not a different type of relationship, so  it's only 1000 right now, So yeah, you will try  to create all the labels and then get a bunch  of errors, which doesn't make sense.  Even though Yeah, yeah, yeah, yeah, Yeah.  Like all of these are coming from the J the  J D BC driver, which, like, it's just Java occur.  And it got, like, no reference point or something.  I Yeah.  So this query is probably somewhere in the J d  BC where we're trying to use the Hm?  Yeah.  So n dot b ID is Can you look at  your, um, new for browser?  Yes.  Uh, that would be here.  Yeah.  So I currently just loaded all the nodes.  There's no relationship.  So all the notes that picked on, um, the property  keys No, relationships have been.  Yeah, because it has it failed when you try to  the relationship.  So it was able to all the node.  That's why it says successful.  So it's on.  It's on.  Um, yeah, this one.  OK, you got database?  Yeah.  All of this is every every foreign key from the  centre fact table to 1234567.  Yeah, seven dimension table All failed.  So the foreign key failed.  It was able to import.  Yeah.  Yeah.  Have you checked this?  So you skipped a few because I have two factor.  One has every dollar 111 has every dollar.  One has 1000 so I'm taking the one that only  has 1000.  So fat crime has, like, $2 million in it.  So I'm taking all the ones that be the Mm.  Well, OK, so this one is connected to the share  server right now.  Yeah.  Yeah, yeah, yeah.  So database is Project one schema.  Is this one?  Oh, you say you have multiple tables?  Multiple.  Multiple.  Wouldn't that be the one that create trouble?  So if you have, if you have two crack tables,  uh, they have different names, and then it wouldn't be  able to figure out which one to use.  Well, the thing is, I got the same arrow, and  I was trying to pull the original one, which is  huge exact same arrow.  It doesn't matter how many more.  So and now I went to the lab.  OK, just make a smaller one.  Yeah, I don't think you need to make the smaller  one.  Um, yeah.  Yeah, but you can.  You can specify how much to I in.  Um, that's using, but that's it.  No, I think Here, uh, you see that?  Now you have a So I just skip all the  one that's Yeah.  So 21.  OK, so just if you just save it and then  next here.  So I But this is number of per on one  number of per transaction.  Essentially, it's still gonna go through all of them.  So if I do an import data, it's gonna take  forever.  I try.  Oh, is it?  Yeah, but the arrow will still come out The exact  same arrow.  It took like, an hour and bla bla all the  errors came out just to Do you want one of  the like one of the No, I'm just training.  Yeah.  So this is Yeah, this is for Oh, OK.  Yeah.  So the same is creating, creating, creating.  But then after that, it's gonna, you know, take a  very long time before the errors come up.  Since you need to add all the all the notes  first and then it will add relationship.  So after you finish adding all the notes when you  start adding relationship, you will have those errors.  Hm.  That's weird.  Yeah.  Yeah.  Why?  I didn't have that problem.  Maybe so.  Your lab is fine, right?  So you tried it on the new Yeah.  The lab was fine.  Yeah, it's not.  It's a fact.  And dimension tables, so but this is connecting.  Not not to your, um this is connecting to your  S e o database, right?  Not the the the AM SAS not.  It's exactly so.  The lab was this one, right?  Oh, no, it was this one.  Yeah.  Yeah.  So the lab was Yeah, I follow this exactly.  And it worked.  The only thing I changed was here, Like in when  you type in your database rather than this, I just  type in Project One.  Yeah, it's It's the name of the database on my  I can see on my S MS.  Yeah.  Oh, yeah.  It was effective.  Yeah.  OK, so this worked.  I don't know why mine doesn't work.  Are you able to see this?  Uh, yes.  OK, that's interesting.  So I think it's probably not not gonna work.  You can have that.  That's what I did.  I made a new table.  Yeah.  Still going?  Because it's not This is not what it's per person.  Yeah, yeah, yeah.  You know what might be happening?  Are you taking Are you taking a stratified sample of  the exactly So what may be happening is the dimension  table will have, um, some values that the fact table  doesn't have because you took the top.  Even with two million, I still have the also like  the dimension.  Think about the three Dimension table.  It is generated every single type.  But even with $2 million not every day is happening.  Not crime doesn't happen every day, so you will have  that have no connection.  That's normal.  But for example, if your dimension table for the two  million roles has 15 different crime types, for example.  But if you're taking the top 1000 that will have  only say five crime types.  But your Dimension table has 15.  So that I I think what he says is, um  if what?  What do you mean by reducing the number of instances?  So if you only reduce the fact table, then that's  fine.  So all your dimension table remains the same.  Then you won't violate the the foreign key and primary  key key.  I didn't I didn't touch the fact I create a  new fact table with the 1st 1000 then run the  same.  That creates the need.  So if you keep all your dimension tables and then  just take the top or stratified?  Um, you know, 1000 from your fact table, things will  work, I think.  I think if we go for stratified, what are the  factors we take in?  Stratified is for every crime type you take, for example.  But then again, do you do that for every time?  Or do you do that for every day for P  U?  Or do you do that for it's a very complicated.  OK, so what's wrong with having a dimension that has  no reference to it?  It would just be a node hanging around in the  database.  It shouldn't be a problem, right?  It would just be a node of the day type,  for example that has no connection to it.  It shouldn't be a problem.  No, I I think what we worry about is that  you actually touch the dimension tables.  So some of the keys in your table can have  no reference.  Your dimension table is the same.  How about you send me the data and then I'll  have a look and then see whether I can load  it?  Um, no, I don't have access to everyone.  Um, yeah, yeah.  You or you.  You get, um, a CV I I don't know.  Yeah.  Yeah.  So we need to.  Really?  How did you create the database?  Do you have a script that create the database?  Like, Yes.  If you give me your user name and password, then  I Yeah, sure.  Yeah.  OK.  All right.  Sorry about that.  We can talk about that later.  So tell me about holidays.  Thank you.  500.  Right, You please.  And the and the OK, you can.  OK, so let's get started.  Um, OK, Before we go into a we still have,  like, two different classes that we didn't touch on.  It's gonna be very brief because we have seen that  before.  Um, the first one is wi right.  So we've used the wi, um this is the funnel.  Like I said before, um, and you can inside wi  use the ware.  Uh, not inside Wis.  But after the wi, you can use, uh, a ware  class afterwards.  So you you your filtering can happen.  Um, after the class, So anyone can guess what this  one is doing was what this statement is doing.  I assume that that means any relationship.  Mhm.  So we find a note, um, with name David or  person with name Davids and then go through any other  person and then relate to, um, any note.  OK, so it doesn't have to be, uh, a personal  note, because we didn't say anything.  And then, um, we funnel through, we put through the  other person, Um, so that later on, we can make  use of that variable, and then we count all the  returned nodes as a friend of a friend, OK?  And then when friend of friend is greater than one  we return, um, you know who the middle person is?  So that's fairly straightforward.  I think I might even have.  Do I have that?  I probably don't have.  Um, yeah, I I do have this.  So this is basically using the data set we have,  um, instead of David, I have it.  And then, um, exactly the same, uh, statements.  And now we'll be able to return all the names,  um, that are as the middle person, um, that ITER  is connected with, um, another person.  Ok, so through a person and connect it with yet  another person.  So this will be something.  Um, that's quite useful.  Um, if you want to have, you know, uh, a  longer path basically.  So we will talk about path expansion, Uh, a little  bit later.  So you can, uh, use, um, a path expansion to  replace this statement if you want to.  And another useful class is called, um, unwind.  So it's, um, basically, uh, take a list and turn  it into rows.  Um, so I have a list of values, and then,  um, I can return, uh, this as roles, so that's  very simple.  So if we do unwind, um, And by the way,  this, um, keywords in cipher, they are not case sensitive.  It's just a matter of habits and convention.  So you write them, um, as capitals, So lower case  N one is fine.  And then I can return X and then a strain  y so you can see that each element in the  list is now occupied its own single row.  And then the y column just basically filled up with  the same string.  Um, so here is, uh, slightly a little bit more  involved.  So we we have returned this, um," metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="or you.  You get, um, a CV I I don't know.  Yeah.  Yeah.  So we need to.  Really?  How did you create the database?  Do you have a script that create the database?  Like, Yes.  If you give me your user name and password, then  I Yeah, sure.  Yeah.  OK.  All right.  Sorry about that.  We can talk about that later.  So tell me about holidays.  Thank you.  500.  Right, You please.  And the and the OK, you can.  OK, so let's get started.  Um, OK, Before we go into a we still have,  like, two different classes that we didn't touch on.  It's gonna be very brief because we have seen that  before.  Um, the first one is wi right.  So we've used the wi, um this is the funnel.  Like I said before, um, and you can inside wi  use the ware.  Uh, not inside Wis.  But after the wi, you can use, uh, a ware  class afterwards.  So you you your filtering can happen.  Um, after the class, So anyone can guess what this  one is doing was what this statement is doing.  I assume that that means any relationship.  Mhm.  So we find a note, um, with name David or  person with name Davids and then go through any other  person and then relate to, um, any note.  OK, so it doesn't have to be, uh, a personal  note, because we didn't say anything.  And then, um, we funnel through, we put through the  other person, Um, so that later on, we can make  use of that variable, and then we count all the  returned nodes as a friend of a friend, OK?  And then when friend of friend is greater than one  we return, um, you know who the middle person is?  So that's fairly straightforward.  I think I might even have.  Do I have that?  I probably don't have.  Um, yeah, I I do have this.  So this is basically using the data set we have,  um, instead of David, I have it.  And then, um, exactly the same, uh, statements.  And now we'll be able to return all the names,  um, that are as the middle person, um, that ITER  is connected with, um, another person.  Ok, so through a person and connect it with yet  another person.  So this will be something.  Um, that's quite useful.  Um, if you want to have, you know, uh, a  longer path basically.  So we will talk about path expansion, Uh, a little  bit later.  So you can, uh, use, um, a path expansion to  replace this statement if you want to.  And another useful class is called, um, unwind.  So it's, um, basically, uh, take a list and turn  it into rows.  Um, so I have a list of values, and then,  um, I can return, uh, this as roles, so that's  very simple.  So if we do unwind, um, And by the way,  this, um, keywords in cipher, they are not case sensitive.  It's just a matter of habits and convention.  So you write them, um, as capitals, So lower case  N one is fine.  And then I can return X and then a strain  y so you can see that each element in the  list is now occupied its own single row.  And then the y column just basically filled up with  the same string.  Um, so here is, uh, slightly a little bit more  involved.  So we we have returned this, um, unwind this list  as rows.  Um, but then we collect the distinct one.  Um, so basically, you tend a list, uh, into a  set.  So a list allows for, uh, repetitive, uh, duplicate values.  Then a set.  You collect all the unique values, so that's just a  simple artificial use of this.  Um, OK, so let's move on.  Uh, so the next one is, uh, a, uh, as  I have alluded, Um, at the beginning of the lecture  is awesome.  Um, it's awesome procedures, uh, for C C A.  Because they're truly powerful.  Um, So the thing that we will look at today,  um, is basically including importing and exporting data.  So that's another, uh, the third way of importing exporting  data.  Um, in addition to the the simplest e t l  tool where you don't have control, but you don't need  any programming language.  Um, and then the, uh, cipher load CS v.  And now we have the importing exporting, uh, in a,  um, that you can create dynamic, um uh, relationships.  So, um, and then the next one is, uh, text  passing.  Um, And when we also look at, um, paths expansion,  um, and then find the virt graph.  So there are a few, uh, these are the sort  of the the key things that we'll be looking at,  and you need to try to keep in mind and  see how this, uh, can be applicable to your project.  So a, uh, contain, uh, both procedures and functions and  procedures.  They generally return um, a list of nodes, uh, that  are, um, unwanted.  Um, and then, um, functions, Uh, typically are simpler.  And they return a single value.  Uh, like, uh, uh, a map or least, um, strain  or number.  So procedures tend to return, uh, more complicated, uh, data  structure, Uh, so nodes, if you present it in Jason,  you can see that it's, um, quite a complicated thing  to have.  And similarly, um, edges.  So procedure returns, uh, list of nodes or, um, edges  or patterns.  Um, and then a, um basically replace the needs of  writing your own functions each.  So if you want to have customised uh uh, importing,  for example, Then you You, um you tend to write  your own functions either inside cipher or outside cipher, uh,  in your python, in your python scripts or in your  e t l scripts.  Um, but now, with a PC, a lot of things  can be done.  Uh, using this apo procedures and functions and you can  use a You remember that use the keyword call to  invoke um, uh, a procedure or function.  And then, um, when you call something, um, typically, you  will follow by a yield.  Um, clause afterwards.  Um, so we can load, um, a URL and turn  it into a json format.  Um, and you can do other you can read in  other things.  Like excel, um, and even web pages.  So a is truly quite powerful.  Um, uh, if you want to look at all the  modules, um, you call a help, uh, to display all  the modules for you.  Um, but the simplest and the most useful one is  low CS v, um, and, um, can load multiple things.  Like I said before, we will focus on low CS  V.  Um, so you could use, uh, load dot CS v  or import dot CS v This little example here.  Uh, when you do load dot CS v uh, you  give a common separate text file, uh, a CS v  file.  And then you can see you call the a p  dot load dot CS v with the file name in  there.  Um, so now you don't really need to put the  data inside your import folder anymore.  So you can be sitting anywhere in your, uh, local  hard drive.  So just refer to that location, and then, um uh,  then you can yield or, uh, generate.  Um, the line number.  Um, And then, uh, map, Uh, which is adjacent format,  Um, or a list.  So if you read it in as a list, it's  basically common separated values or as strings.  Um, and then the map is, uh, more comprehensive.  You have key value pairs.  Um, so that's the, um, uh in load CS.  V.  Um, And then this part CS v.  Um, allows you to have, um, you know, more specific  controls.  So you specify, uh, the nodes, the relationship.  And, um, you specify a set of, uh, configurations.  Um, so here, um, you could, you know, inside the  low CS v.  You have adjacent object.  Um, that stores key value pairs.  So the file name you specify the file name, and  then you specify the labels.  Um, and then you can specify all the attributes as  you like.  Uh, so here, uh, when we import the CS.  V.  Um, from the data set, um, so you can see  I'm using, um on this screen.  So I have, uh OK, so this is slightly different.  Um OK, so it just, uh this is basically just  load the CS v file.  You can do this with multiple files, uh, in one  import CS V instead of using cipher load CS V.  Um, which one, um, cipher statement, Um, at a time  for for each, uh, file.  Now we can put everything together.  Um, and you can you can see in this little  example here I have rather than comma delimited.  I have this pipe Demi delimited file.  Um, and then, um, I have, uh, this, um array  deli, which is, um, this comma.  OK, so e n and French are the, uh, language  that people speaks or the person speaks.  Um, it can be read as a least, um, And  then And you can say, you know, whether the ID  should be a strain or not to specify that as  a false So it's a lot more powerful, as you  can see from here.  Um, as compared to the, um uh the, uh, cipher,  uh, load CS v.  So, um, as I mentioned before, um, if you have  different types of relationships between two nodes or between two  entities.  Two types of entities.  Uh, for example, no friends with and enemies of and  brothers off you will have to create, uh, individual CS  v file.  Uh, so something, uh, one person knows another person, and  one person is friend with another person.  So each CS v file basically represent one type of  relationship.  Um, if we have a file that wants to represent  multiple relationships like the one that we have seen before  where we have, um, person one follows person two and  person one knows person two.  Um, So there are two different types of relationships we  won't be able to load CS v using s A  here we can.  Uh, but instead, what we can do is we can  load, um, that using a PC.  So let's see how we did it in park.  OK, so here, um, I have a statement.  I have the person, um and then the the name  is, uh, from my CS v file.  So, as you can see that this is a combination  of the load CS v uh, with a PC.  Firstly, I load the CS v, um, with headers as  as, um, as so this.  This file is loaded.  I say this relationship this CV file that you have  seen just now.  So this is loaded, um, using a load CS V.  Right.  Uh, so once we load each row in, we call  the epoch create relationship function.  OK, so the create relationships function takes in, um, a  node and then, um, takes in the relationship type.  OK, so this is a variable now, So this is  basically row dot relationship, which is the middle column from  your, uh, relationship dot CS v.  Um, so you can have as many relationship as you  like in that CS v file.  You don't have to separate that into multiple CS v  file in order to create this dynamic relationships.  Um, and this empty thing is basically the properties" metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="Um, that stores key value pairs.  So the file name you specify the file name, and  then you specify the labels.  Um, and then you can specify all the attributes as  you like.  Uh, so here, uh, when we import the CS.  V.  Um, from the data set, um, so you can see  I'm using, um on this screen.  So I have, uh OK, so this is slightly different.  Um OK, so it just, uh this is basically just  load the CS v file.  You can do this with multiple files, uh, in one  import CS V instead of using cipher load CS V.  Um, which one, um, cipher statement, Um, at a time  for for each, uh, file.  Now we can put everything together.  Um, and you can you can see in this little  example here I have rather than comma delimited.  I have this pipe Demi delimited file.  Um, and then, um, I have, uh, this, um array  deli, which is, um, this comma.  OK, so e n and French are the, uh, language  that people speaks or the person speaks.  Um, it can be read as a least, um, And  then And you can say, you know, whether the ID  should be a strain or not to specify that as  a false So it's a lot more powerful, as you  can see from here.  Um, as compared to the, um uh the, uh, cipher,  uh, load CS v.  So, um, as I mentioned before, um, if you have  different types of relationships between two nodes or between two  entities.  Two types of entities.  Uh, for example, no friends with and enemies of and  brothers off you will have to create, uh, individual CS  v file.  Uh, so something, uh, one person knows another person, and  one person is friend with another person.  So each CS v file basically represent one type of  relationship.  Um, if we have a file that wants to represent  multiple relationships like the one that we have seen before  where we have, um, person one follows person two and  person one knows person two.  Um, So there are two different types of relationships we  won't be able to load CS v using s A  here we can.  Uh, but instead, what we can do is we can  load, um, that using a PC.  So let's see how we did it in park.  OK, so here, um, I have a statement.  I have the person, um and then the the name  is, uh, from my CS v file.  So, as you can see that this is a combination  of the load CS v uh, with a PC.  Firstly, I load the CS v, um, with headers as  as, um, as so this.  This file is loaded.  I say this relationship this CV file that you have  seen just now.  So this is loaded, um, using a load CS V.  Right.  Uh, so once we load each row in, we call  the epoch create relationship function.  OK, so the create relationships function takes in, um, a  node and then, um, takes in the relationship type.  OK, so this is a variable now, So this is  basically row dot relationship, which is the middle column from  your, uh, relationship dot CS v.  Um, so you can have as many relationship as you  like in that CS v file.  You don't have to separate that into multiple CS v  file in order to create this dynamic relationships.  Um, and this empty thing is basically the properties that  you want to have, uh, for your relationship.  Uh, because we don't have any.  Um, uh, we don't have any, Um, sorry.  We don't have any properties, uh, for for the relationship  type, we leave it as.  And then this, um, is the second person.  So you basically have four arguments.  Um, the first and the last arguments are the starting  and end node.  And then the middle two, um, is the role the  relationship type and then the properties of the relationship.  So once you call that, um, you yield a relationship  and then you return the relationship.  So if I run this, I will create the relationships,  um, already, uh, in the file.  I mean, it doesn't hurt for me to run it  again.  Um, because, you know, that's just already, um, relationship created.  Mhm.  Um, so this one created all the relationships, and, um,  so that's dynamic relationships.  Um, OK, so that's that.  And then, um, the other thing that I want to  uh, specify is you know, when you or mention is  when you load people, um, it has the same problem,  right?  So in instead of, um, you know, just loading a  person, Um uh, in as a person as a single  label.  Now, with a park, you can create node with multiple  labels.  Um, so when when I have the, uh, person file.  OK, so the people file, I have the name of  the person and then the occupation.  Um, So instead of just having person as a label,  I also want the occupation as a label because then  I can philtre my data according to the, um, or  even visualise with different colours according to their occupation.  Um, so how do I do that?  A, um, allow you to do it.  Um, So, um, this little, uh, line of code here  says I can create a node with a list of  labels.  OK, so the square bracket indicating this is a list  the first one, everyone is a person, and then the  second one is dynamic from the second column of the  people dot CS V.  Ok, so now, um, I've created, um, labels.  And then I specify, uh, the role, um, as my,  uh, node, uh, input.  So a list of labels and then, uh, the node  itself.  And then I yield the node and return node.  OK, so that's dynamically, uh, creating, uh, labels using a,  um and then the next little example.  I'll I'll skip this because I need to open up  another database.  I want to stay in this database and I'll come  back to it.  Um, so the other, more powerful thing, uh, in, uh,  a PC is this past expansion?  Um, so it can be done in cipher as well,  but I'll show that this, uh, apo again is more  awesome than just cipher, um, and then the virt graph.  So sometimes you want to, um, retrieve notes that are  multi hop away.  So rather than just one hop away, we want relationship,  um, that are multi hopped away.  So in cipher, you certainly could write this.  So a, um, is one hop away from something and  this something is another.  Hop away from another thing, and then keep going, and  then until it reach a destination.  Uh, B OK, And this is providing that.  You know how many hubs that you're interested in if  you don't?  Then, um, that's troublesome.  So even if you know, you know, 10 Hubble Way  is very difficult to write.  Using this using this particular, uh, cipher, uh, syntax so  cipher, uh, provide this pass expansion syntax where you start  with a little star and then, uh, followed by a  number.  So this is exactly specifying that I want parts of  lens five.  Um, And if I put two dots before the number,  then I'm saying that I want parts of less parts  of lens less than five.  Put the dots the two dots, Um, after the number  you have basically saying part of lens five or more.  OK, so this is less than this is greater or  equal to OK, so this is, uh what?  What?  Um, the syntax is telling you.  And if you put, um, two dots in between two  digits, you basically specifying, um, I want, um a minimum  length and then, uh, maximum length.  Ok, so, um, I have a statement here, uh, where  I can demo it.  Uh, so pass expansion, Um, in here.  So I have a different name because I don't have  in my data set, I have, uh, k c uh,  in here.  So it's basically saying, um, that, um for Kelsey, Um,  I want to generate, um the the the remote friends  that are either one hop away or two hops away.  OK, so I can, uh, run this statement so you  can see that it's quite a messy graph.  Um, but this is, uh, the remote friend of, uh,  Kelsey.  Um, how do we do that in, uh, P uh,  in a so pa Apo has something called, uh, a  pass expander module.  So this path expander module allows you to do similar  things, but with a different syntax.  Um, so if we do path expansion in a park,  so you can see, um I start by matching, um,  using the same way as c a and then I  can you guys see?  Ok, um, so then I can, uh, call, uh, this  apo pass expander.  Ok, so apo dot pas dot expand.  And then I specify the node.  I specify the relationship.  Um, and then I specify, uh, condition.  OK, so this condition could be you know, the labels,  um, that you wanna, um, add in, um, or the  the, um the labels that you want to remove.  So you use plus sign to say that I want  to, um, only retrieve the engineers, uh, known by, um,  K c or I only want to return.  Uh, you know, the, uh, scientist that known by, uh  K C.  And then this has to be one or two hops  away.  Uh, so once you have that pass expander, uh, function  call, you can return the path, and then, um, you  can yield the path and then return the path, so  there's a pattern.  Don't forget that you yield the paths from your a  call first, and you return the path, you can count  the number of parts, and you can order by, Uh,  so the the number of parts is the number of  hops you can order by hops.  OK, so if I do this, Hm?  OK, so it takes a while.  This is, you know, quite messy.  Um, that's everything.  Sort of, um, using the A O.  C um, path expander.  Um, right.  And then, um, as I said before, you can limit  what you want to return.  So here I have a plus.  Mechanics.  Um, so, basically, I just wanna, uh, return, Uh, the  one, uh, that Kelsey knows.  Um, the mechanics, uh, mechanic, uh, person or the person  who are a mechanic as an occupation.  Um, that Kel C knows, Uh, that's one or two  hops away, and then I can run this, right?  Yeah.  So only two, uh, uh, mechanics that Kelsey knows.  Um OK, so that's that, um And then I can  also, uh, instead of just having one, um, relations.  So if you look at this instead of just having  one relation types, I could have, um, multiple relation types.  And this multiple relation types is, um, separated by this  bar so follows, um, it with a direction.  So this greater sign, I think, is, uh, outgoing.  And then if it's, uh, less than sign, it's the  incoming.  OK, so the outgoing link, um, that has follows type  That's one of three hubs away.  So in my, um, example, um, so I have, uh,  knows and follows outgoing and 1 to 2, uh, helps  away.  It's getting big, so it's a bit too slow now.  OK, so that's, um, that one, um, about past expansion.  Um, and then we also have" metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="in my data set, I have, uh, k c uh,  in here.  So it's basically saying, um, that, um for Kelsey, Um,  I want to generate, um the the the remote friends  that are either one hop away or two hops away.  OK, so I can, uh, run this statement so you  can see that it's quite a messy graph.  Um, but this is, uh, the remote friend of, uh,  Kelsey.  Um, how do we do that in, uh, P uh,  in a so pa Apo has something called, uh, a  pass expander module.  So this path expander module allows you to do similar  things, but with a different syntax.  Um, so if we do path expansion in a park,  so you can see, um I start by matching, um,  using the same way as c a and then I  can you guys see?  Ok, um, so then I can, uh, call, uh, this  apo pass expander.  Ok, so apo dot pas dot expand.  And then I specify the node.  I specify the relationship.  Um, and then I specify, uh, condition.  OK, so this condition could be you know, the labels,  um, that you wanna, um, add in, um, or the  the, um the labels that you want to remove.  So you use plus sign to say that I want  to, um, only retrieve the engineers, uh, known by, um,  K c or I only want to return.  Uh, you know, the, uh, scientist that known by, uh  K C.  And then this has to be one or two hops  away.  Uh, so once you have that pass expander, uh, function  call, you can return the path, and then, um, you  can yield the path and then return the path, so  there's a pattern.  Don't forget that you yield the paths from your a  call first, and you return the path, you can count  the number of parts, and you can order by, Uh,  so the the number of parts is the number of  hops you can order by hops.  OK, so if I do this, Hm?  OK, so it takes a while.  This is, you know, quite messy.  Um, that's everything.  Sort of, um, using the A O.  C um, path expander.  Um, right.  And then, um, as I said before, you can limit  what you want to return.  So here I have a plus.  Mechanics.  Um, so, basically, I just wanna, uh, return, Uh, the  one, uh, that Kelsey knows.  Um, the mechanics, uh, mechanic, uh, person or the person  who are a mechanic as an occupation.  Um, that Kel C knows, Uh, that's one or two  hops away, and then I can run this, right?  Yeah.  So only two, uh, uh, mechanics that Kelsey knows.  Um OK, so that's that, um And then I can  also, uh, instead of just having one, um, relations.  So if you look at this instead of just having  one relation types, I could have, um, multiple relation types.  And this multiple relation types is, um, separated by this  bar so follows, um, it with a direction.  So this greater sign, I think, is, uh, outgoing.  And then if it's, uh, less than sign, it's the  incoming.  OK, so the outgoing link, um, that has follows type  That's one of three hubs away.  So in my, um, example, um, so I have, uh,  knows and follows outgoing and 1 to 2, uh, helps  away.  It's getting big, so it's a bit too slow now.  OK, so that's, um, that one, um, about past expansion.  Um, and then we also have a sub graph.  Um, do I have a sub graph?  Yeah, I have a sub graph.  Sorry.  Now it's so slow now, um, so the sub graph  is basically you specify, um, you know, instead of just  pass, expand now it's pass dot sub graph, or, um,  and then you specify the node.  Um, and then you specify the relation philtre, uh, specify  the max and uh, minimum levels with the syntax is  slightly different.  But you generate the graph, um, as well.  So OK, so this is, um, a sub graph of  Kelsey, uh, knows, um, people, you know, one or two  hops away.  So it's It's similar to the pass expansion, but this  is creating a sub graph.  OK, so, um, Epoch also allows us to create virtual  nodes, um, and virtual relationships.  Uh, so, uh, this virtual nodes, they are only stored  in memory and returned back to u I.  So it's, um, uh, some kind of transitive relationship that  are not tangible.  Um, it's basically, um, a visual.  Uh, candy, uh, that allows you to see aggregated, uh,  way of, um, displaying things.  So, um, I have this, uh, virtual relation example.  OK, OK, so this is basically just creating it.  Um, it's not really doing the virtual one.  So, uh, let me.  Ok, so this is created, um, I've created I mean,  it's a bit messy because I've created, um, Alice, um,  as a person.  And then I've created, um um and it so So,  yeah, I've created not person, but accounts.  So, Alice, as a account.  And then, um uh, there's another account, Bob.  And then I created two, uh, relationships.  So one is, um, Alice sent 250 to bob.  And then Alice sent 750 to bob again.  So this is let me show you so we could  do basically, um, a virtual relationship.  So just copying what we have.  Mm.  OK, so how about I get out this database?  Because it's getting big and not responding very nicely.  Mhm.  Sorry.  I will just stop this, Um, because I need to  install the epoch library.  So while we're waiting for the database, um, to load  up, Um, as you can see that, um, we have  a pattern retrieved.  So from account, um, sent to certain amount of payment,  um, to the receiver account.  Ok, so, um, this is, uh, what we have seen  before, Uh, let me do this.  And then now we have, um, basically, uh, returned the  front and two, um, accounts.  And then you created a virtual relationship, uh, from, um  and then this relationship type is paid, and then we  can sum up the amount, um, and then as a  property for paid and then, um, created a link to  the receiver account.  Um, so this is, um, as a as a relation  that you returned.  OK, so this, um, once we open this, we'll be  able to see it.  So if I have this statement, uh, we are Huawei.  So we have virtual relation example, Um, and then I  run it.  So I created four labels and four notes, Um, and  then a set of four properties.  Um, and if you want to show, um and then  we can actually see what happens.  Sorry.  The new project is still releasing my memory.  Uh, so why you're seeing all this is because I  actually have, uh, loaded words in here, so and, um,  account.  Sorry.  It's frozen.  OK?  Oh, just bear with me.  So anything about, OK?  So as you can see, that I have, um, multiple  A and B because every time I just use create  rather than, um, merge.  So that's that's a bit of a trouble.  So I've created duplicate once.  Um, but as you can see that, um, Alice sent  $250 to Bob.  Alice sent $750 to Bob.  So that's a little bit too much to to look  at right, Because if we want to, uh, summarise that  we would do, uh, match.  Sorry.  This is just waiting for it to, uh, so you  you can try it out.  It's not hard.  Um, because I think giving the time is running out.  Um, I would just rather than demo it.  I would just, um, use this as an example.  Uh, that's definitely what you're gonna get.  Um, because here you have one and two.  Um, because we didn't really specify the name.  I can assure you, this will be Alice, and this  will be Bob.  And then the property for that, uh, paid is, um  uh, $750.  Ok, so that almost concludes what we have, um, discussed,  uh, today, um, apart from, you know, two slides worth  of, um, text, uh, EPOC text functionality.  We can do that, uh, next week because that's related  to, uh, data science.  Anyway, uh, so before we finish off, uh, just quick,  um, note on, you know, your assignment.  Um, let me see, uh, on your project or quick  device on your project, Um, on what you should think  about.  OK, so here we have, um, almost like a replica  of the of your relational star schema.  Right?  So the fact table in in, uh, the middle, and  then you have all these, uh, dimension tables, uh, you  know, beaming out of your fact table.  So this, um, could be your initial design.  Um, and you can certainly make use of the e  t l two and then see how it goes.  And a lot of people been asking me Should I  use e t l two?  Or should I use, um, a, uh or should I  use cer load CS v Um, a lot of time.  It's a combination of everything.  Uh, so you start by looking at your, uh, database,  uh, importing, um, or import it inside your graph database  by using the new four J E T l tool  as a quick start.  And then you can investigate, for example, in your, uh,  in postgraduate, um, we require the zones.  So we need to specify you know how one zone  is a to another zone.  So this is a separate CS v file that you  need to create by visually, uh, looking at whether two  zones are connected or not.  So you you need to create, um uh a CS  v file with two columns, Uh, Zone one and zone  two means zone one and zone two are, uh, connected  or adjacent.  And then zone one zone three and zone one.  Zone four.  If this zone one is connected to 234.  OK, so the every single row represent a pair of  zones that are adjacent, and then you can use either  the load CS v, um, from cipher or using a,  uh, from cipher to depend on whether you want to  store any other attributes or not, um, into this schema  ok?  Into your existing, uh, database loaded by E T.  L two.  So that's what I said that you probably need to  use a combination of this, uh, three different ways of  loading the CS.  V file.  Um, so that's one thing.  The second thing is, you know, how do we actually  count?  How do we aggregate from, uh, you know, a date,  um, to find out, given the particular date, how many  crimes we have.  OK, so you think about the Cypher query that you  actually match, uh, the exact date with the pattern of  how crime is related.  OK, so and then you count the number of crimes,  so it's a simple kind of query, but then take  it one step further.  Think about your concept hierarchy.  Think about how your date, um, concept priority could have,  you know, month, quarter and also, um, yeah, OK, so  What if I want to aggregate?  Um, an entire year of a number of crimes?  So should I use virtual node like I discussed before,  or should I make use of, um uh, uh a  designed physical node.  OK, so if it's a physical node, um, it means  that your graph schema is gonna be quite complicated." metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="what we have, um, discussed,  uh, today, um, apart from, you know, two slides worth  of, um, text, uh, EPOC text functionality.  We can do that, uh, next week because that's related  to, uh, data science.  Anyway, uh, so before we finish off, uh, just quick,  um, note on, you know, your assignment.  Um, let me see, uh, on your project or quick  device on your project, Um, on what you should think  about.  OK, so here we have, um, almost like a replica  of the of your relational star schema.  Right?  So the fact table in in, uh, the middle, and  then you have all these, uh, dimension tables, uh, you  know, beaming out of your fact table.  So this, um, could be your initial design.  Um, and you can certainly make use of the e  t l two and then see how it goes.  And a lot of people been asking me Should I  use e t l two?  Or should I use, um, a, uh or should I  use cer load CS v Um, a lot of time.  It's a combination of everything.  Uh, so you start by looking at your, uh, database,  uh, importing, um, or import it inside your graph database  by using the new four J E T l tool  as a quick start.  And then you can investigate, for example, in your, uh,  in postgraduate, um, we require the zones.  So we need to specify you know how one zone  is a to another zone.  So this is a separate CS v file that you  need to create by visually, uh, looking at whether two  zones are connected or not.  So you you need to create, um uh a CS  v file with two columns, Uh, Zone one and zone  two means zone one and zone two are, uh, connected  or adjacent.  And then zone one zone three and zone one.  Zone four.  If this zone one is connected to 234.  OK, so the every single row represent a pair of  zones that are adjacent, and then you can use either  the load CS v, um, from cipher or using a,  uh, from cipher to depend on whether you want to  store any other attributes or not, um, into this schema  ok?  Into your existing, uh, database loaded by E T.  L two.  So that's what I said that you probably need to  use a combination of this, uh, three different ways of  loading the CS.  V file.  Um, so that's one thing.  The second thing is, you know, how do we actually  count?  How do we aggregate from, uh, you know, a date,  um, to find out, given the particular date, how many  crimes we have.  OK, so you think about the Cypher query that you  actually match, uh, the exact date with the pattern of  how crime is related.  OK, so and then you count the number of crimes,  so it's a simple kind of query, but then take  it one step further.  Think about your concept hierarchy.  Think about how your date, um, concept priority could have,  you know, month, quarter and also, um, yeah, OK, so  What if I want to aggregate?  Um, an entire year of a number of crimes?  So should I use virtual node like I discussed before,  or should I make use of, um uh, uh a  designed physical node.  OK, so if it's a physical node, um, it means  that your graph schema is gonna be quite complicated.  So you're gonna have, um, a month node a year  node, a quarter node.  So, um, that of not just one, but a type  of, uh, month notes.  So every single month, um, you will represent it as  a note.  Um, so it's convenient in terms of queries.  So, from you know, January, uh, 2010, I'm linking to  the crime ID.  So I'll be able to aggregate and find out the  number of crime or the type of crime that happens.  Um, in that month.  Ok, um, so that's one physical design that you actually  introduce a new label, which is month.  You introduce another new label, which is, um, a year  and then another label, which is quarter.  So that's just along the date dimension.  You can do the same thing for location dimension, for  example, Uh, but on the other hand, you also have  the epoch virtual nodes and virtual, uh, path.  Um, so you could calculate those virtual nodes as a  display candy?  Um, not, um, as the physical implemented node.  So think about those, um that will, um, help you  structure, uh, your, um your design so that you can  answer all the queries that we have there.  Ok, All right.  So that's all from me.  Thank you so much for your attention.  And I'll see you next week.  Uh, for rough data science.  No, such a beautiful place.  I've never seen you know, something as beautiful as that  conference as well.  Had a great time so much and yeah, yeah, yeah,  yeah, yes.  Yeah.  So within the graph database, it contains a" metadata={}
 
 
