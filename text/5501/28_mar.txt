Yeah.

Thank you, Dirk.

It is after three.

So I will make a start.

Um, you may have noticed were slightly behind the topics

that are on the schedule, but that shouldn't be an

issue.

If there's anything very important that I need to cover

that I don't get covered.

Uh, by the break, I will record, uh, some extra

video lectures for that.

And if there's anything that we don't have time to

cover at all, then I will say so when we've

got test or exam or anything coming up, I'm going

to put up a little more feedback about the week

three quiz, um, from people who did very well in

it.

And based on, uh, some of the questions about it

I've had emailed to me So that will go up

on Modal next week.

We've got our mid semester ish assessment.

Part of that will be same sort of thing as

the quiz.

Uh, so Multichoice should answer Fill in the blank kind

of things.

Uh, maybe some coding questions.

Um, and the remainder will be, uh, longer written questions.

So, uh, English language, longer written answers.

And the whole thing shouldn't take longer than a few

hours to do two or three hours.

Um, hopefully, too.

So the written stuff, the idea is not it's not.

It's not an assignment, so the idea is not to

spend days or hours on it.

Uh, originally, I had this as an in class, uh,

exercise.

So a couple of years ago, pre covid.

We did the the writing stuff as an in class

exercise and then reviewed at the following week.

But we have less time because we're a bit behind

and it's on the whole much easier if people can,

uh, choose their own time to do it.

So it's a it's an online exercise.

So next week we'll do that.

Most of the written questions that we will do ask

you your opinion on something they say Here is the

situation.

What would you do?

What is the best way to handle this?

Or would you would you recommend this sort of a

test or that kind of a thing?

And your job is to give an answer and to

justify that based on whatever evidence is available from the

scenario or that we've looked at in lectures or labs

or reading material and so on.

So, um, that sort of question students have in this,

you know, historically not answered terribly well, come the exams.

So I'm aiming to give people, uh, more practise at

that.

So there will be the chance to write your own,

uh, next week and the following week, Uh, you'll be

reviewing three other people's, and they will be reviewing yours.

So you get to see a range of answers which

tends to give you, uh mm, more of an opportunity

to learn what's expected.

So if there's any queries about that, feel free to

ask me about that.

And I also will be putting up a a feedback

survey on model.

So just to get any feedback you might have on

the lectures or labs or other teaching activities, and if

anyone's having difficulties with something, then uh thinks we need

to sort of put more resources into that, then let

me know.

In general, one thing that it's kind of pointless to

say is it's going too fast or it's going to

slow because half the class will always think things are

going too fast.

Half the class will always think things are going to

slow and we'll be about five people in the middle

who think it's just fine.

So if it's too fast or too slow and probably

not going to change anything, unless that's an absolutely overwhelming

opinion.

Okay, so that's news coming up.

Any queries about that Do okay.

Oh, and I was reminded that of the textbooks that

we've got, um, if you go look at the LMS

and click through the readings uh, there's a textbook with

a mountain on the front by Brugger and due to,

uh, which is quite good, Uh, if you want any

information on preconditions or post conditions are invariants then, uh,

or failures and faults and testing.

Uh, the brother and guitar textbook is quite good.

Um, if you want information on, uh, input space partitioning

or graph based testing or sort of these four big

topics we're going to cover over the next few weeks,

uh, the only place to look for those is in

the men and offer textbook, which has a person's head

on the cover.

I think, uh, beyond the fact that it covers those

topics, it's not a particularly good textbook.

There's often mistakes and the exercises, so I don't recommend

you do those.

Some of the sections are not particularly well written, and

some of the examples are fairly poorly chosen.

So I Yeah, I recommend you.

You might want to look at it for some of

the concepts.

So when we look at input input space partitioning graph

partitioning, syntax based testing, uh, you may want to have

a bit of exquisite it for those, but in general,

uh, the other the other textbooks.

So pressman and the burger and textbook I've just mentioned.

So, uh, here we go object oriented software engineering using

UML patterns in Java That's quite reasonable for preconditions and

side effects and invariants it's all okay, So lecture stuff

we had got as far as talking about partitions and

looked at a few things that are partitions and are

not.

And we looked at Knowles, and I said that in

general, it's a presumed precondition of every method that Knowles

are not a valid thing to pass in.

In fact, if you can pass in Nichols, the Java

doc will explicitly say so.

Uh, so we don't mention them in our documentation.

It's just assumed, uh, and for any system you work

on.

If there's something that is, uh, true throughout, then, uh,

there is nothing wrong with documenting that once in one

place at saying this applies to every single method or

every single class in our system.

Um, so we don't bother testing for those, uh, anyone

who does suggest tests involving them unless there's a very

good reason will not get marks for them.

Ah, and as a as a thing to partition on

as a characteristic, no illness is only something you might

want to throw in for completeness.

Uh, in general is not terribly useful.

And we had an example of something where you can

pass Knowles in and on the whole, it was probably

a bad choice.

Okay, So characteristic is some property of an input value

or a couple of input values together that we can

use to partition the domain of that input value.

So even this is an example of a characteristic that

we could use to partition INTs.

Sidedness is a characteristic, uh, that we could use to

partition.

It's as well so we could partition them into positive

negative and zero.

Uh, dullness is another characteristic.

It only applies to reference types.

Uh, but as a in general, we're not gonna use

that, uh, all caps nous so we could say for

strings, some strings have everything in them capitalised.

Uh, and some do not.

And that's a partition.

So that counts as a characteristic.

Um, so if we have something like find element, um,

we already looked at some of these.

We said for a list some partitions that you could

pick our, uh, is the list empty?

So are the zero elements in the list, which is

not the same as null.

So if you need to review containers versus an illness,

then take a look at the Java textbooks.

Um, and that will come up in tests.

So it's worth knowing about so we could have an

empty list.

So is it empty or not?

Uh, that's one partition.

Uh, you might want to pick a few values, you

might say.

So there's no particularly good name we can give to

it.

But we could say I'm gonna partition lists into things

that have no values, things that have one value, things

that have two or more values and everything else about

two values.

Things with three or more values.

Um, so you might choose something that you can't find

a particularly good name for, But if you want to

use that as a partition, that's fine.

Just call it a petition P or Property P or

something and define it.

Um, some properties are things that, uh, only makes sense

when we look at both parameters together.

So we could say, uh, one property of a list

is the interferon.

It is l m in the list.

That's partition divides things into, uh, it's there or it's

not there.

Another property we could look at is Is it in

the list?

More than once?

Uh, we could say, Is it in the list?

And when we do have a partition, we can look

at, uh, sub partitions of that.

So out of all the cases where what we're looking

for is in the list, we could say partitioning of

that is the thing we're looking for is in the

first spot in the list.

Uh, so that's partition divides things into another possible partition

is the thing we're looking for is in the last

place of the list or not.

So that's another partition divides things into two.

Um, why would we pick those?

Well, we know people tend to make mistakes around boundaries

of things.

So the beginning of the list and the end of

the list, uh, can be particularly important things to check

if people have made some kind of an off by

one error.

So they've written their loop incorrectly, Uh, then they might

do something wrong.

Uh, when it comes to the first element of the

last element of a list or some other container so

we could draw our characteristics something like this.

So we've said looking at the list, we could say,

Is it no or not?

And we might put that in for completeness but not

write any tests based on it.

Uh, if it's not null, we could say, Is it

empty or not?

Uh, so either it's empty or it's not empty.

If it if it's not empty, does it contain the

element or not?

Or not?

Uh, so either it does or it doesn't.

That's a partition.

Uh, if it does contain the element, then there's a

bunch of other sub partitions of that we might consider.

So is it in the first spot?

Is it in the last uh and so on.

Uh, in general, we usually try and go for a

fairly for characteristics that divide things up into a fairly

small number of partitions.

So two or three, maybe four, usually not more than

that, uh, is better to come up with more characteristics.

So to think of a a bunch of these blue,

actually a bunch of these orange boxes.

So various properties, uh, than to try and come up

with one partitioning that is full of lots of partitions

because we're, uh, in the next stage, we're gonna try

and look at combinations of things How those combine.

So here's a continuation of that last diagram.

If something contains the element we can have is there

is the element in the first position.

Is it in the last?

And we've said that there are things that aren't partitions,

and it would be bad to choose those.

A common mistake that people make is to pick some

property and not think terribly carefully about whether it induces

our partitioning.

So whether it produces partitions.

So the ordering of a file, someone might sort of

casually think I'm going to use, uh, this characteristic lines

in a file, Um, they might be in ascending order

or descending order or not ordered at all.

And those are my partitions.

But that isn't actually a partitioning.

So if I have a file with one line on

it, is it in ascending order?

Who says Yes, Well, if you if you run the

sort on it who says it's in descending order or

who says it's in no order, it's in no order.

Well, it's ascending and it's descending.

It's You can't point to anything in that file where

the lines are out of order.

So it's true that every line in the file is

in order.

So if you have a file of one line, uh,

it's sorted in ascending order, it's sorted in descending order.

Arbitrary order is not something you've defined particularly well here,

except maybe as things that don't fall into the first

two.

Uh, so it wouldn't be an arbitrary order, or you

might.

You might say that it is.

But whatever you decide, it's certainly the case that what

you've come up with there is not a partitioning, so

it's better to have multiple characteristics and say one characteristic

is the file other lines in ascending order that's either

true or false.

So that's definitely a partitioning.

Is the file in descending order?

That's another partition that's also true or false.

It's definitely a partition, um, so split things up into

into multiple characteristics.

If you need to.

Don't try and combine them into a single, potentially bad

one.

So complex characteristics tend to lead to mistakes in our

test planning.

Okay, so I'm just going to give a brief review

of what the steps are and how we apply them.

So we saw that our steps are in SP.

Identify are testable functions for each function, find the parameters

for each parameter come up with characteristics.

Sometimes those will be characteristics based on more than one

parameter from the partitions we've come up with.

Uh, we need some way of picking values from within

those partitions and, uh, ideally, also deciding roughly when we

have enough and finally turning these into test values.

So testable functions I I won't say much more about

except that when we've got a method to test, that's

usually pretty easy.

We just say, Well, that's got one testable function.

Uh, if we've got classes there might be multiple.

If we've got a bundle of classes, we might want

to treat them as something that can be, uh, model

as a function, uh, for whole programmes and larger stems.

Uh, there might be many functions.

Uh, so one thing that we can use is whatever

our design documents are, or any use cases or user

stories that we've got, those can be a good way

of identifying functions of a whole system.

Alright, Sorry.

Finding the parameters.

Sometimes that is easy.

Sometimes you've got something like a static method that just

takes in a bunch of parameters and does something to

those parameters and attend something.

But sometimes we've got methods that make use of state,

so that might be state of an object.

So if we've got a list object, then things like

calling the size method what result you get depends on

what the state of the list is that you call

it on.

Uh, it is possible for a method to read global

variables, so there might be variables in other classes or

static variables attached to other classes that it can read.

So one example is so in Java, the system class

holds a bunch of sort of generally useful properties about

the system that we're running on as a whole.

And it's got a couple of, uh, static, publicly accessible

variables attached to it.

Uh, two of those are system out and, uh, system

in.

So we come across those when we when we call

the print land method to print something to the console

and any any method can potentially read to or right

from those.

So a method that does those that does that those

would form part of the state.

So if some method print stuff to the screen, um,

it's making use of, uh, making use of state if

it read something from the terminal.

It's also making use of state.

Uh, so potentially the result you get from it could

be different every time.

Uh, we need to include those when we model our

parameters.

So we saw last lecture that all of those things

that we rely on, we add in as extra extra

parameters to our method.

Okay, So coming up with partitions, um, is going to

depend on the method that we're looking at.

Okay.

Usually we get clues based on Well, what the What?

The specification for the method says it is possible to

come up with some.

It is possible to look at methods in a kind

of an automated way and generate some partitions.

Uh, just based on the type of the parameters.

So given uh huh, Uh huh.

If we've got something like contains element, uh, method, you

can produce a programme that will apply some simple rules

and get you some partitions.

Uh, based on the type of these, uh, parameters for

introduce.

It might know.

Yeah.

Positive.

Negative.

And zero.

That's a reasonable partition.

Uh, but in general, it won't give you particularly sensible

or good tests.

Uh, to do that, you need a bit of human

creativity, All right.

And we'll look at these two ways that we can

do it in a little more detail later.

So the mechanical approach and why the mechanical approach is

not a particularly good one.

Once we've got our partitions, uh, we might have tonnes

of them, so we might have dozens and dozens.

Uh, can we just say let's take all combinations that

work and write tests for them?

Um, often, there will still be too many, uh, to

try all of those.

Remember that in general, we we test to try and

lower the risk that something will go wrong in our

method.

If some bit of our system is particularly vital, then

maybe we want to look at it with increased scrutiny.

Maybe we do decide to try every combination of partitions,

but usually we'll apply some rule for coming up with

a reasonable number of combinations of our partitions.

And lastly, uh, given all the previous steps, we select

those values.

So we decide what combinations of things we're going to

look at and we find test inputs for those and

turn those into actual tests.

Okay, so, um, I said, there's two approach.

There's a sort of a mechanical approach and, uh, not

mechanical approach.

So the mechanical approach is called interface based, uh, and

it can be partly automated.

Uh, but it tends not to give you terribly meaningful

tests.

And the functionality based approach means you look at what

the method is your class or whatever it is is

intended to do and try and develop characteristics based on

that.

So for our find element thing, uh, an automated approach

might say, Oh, here we have an integer I know

how to handle introduces.

Let's spin it into a positive negative and zero and

it might say for lists.

Oh, yeah, I know some things about lists.

Let's split that into, uh, empty and not empty.

Uh, but a mechanised approach is unlikely to recognise that

an important thing about the find element method is is

looking for that element in that list and so is

unlikely to come up with that as a test chat.

GPT might.

On the other hand, I don't know.

Someone might like to try that, uh, plug in a,

uh, signature and interface for a method.

Ask what tests that would recommend, And, uh, you might

get something interesting, but a simple mechanised approach will often

miss, uh, things based on combinations of these.

So So the other approach is where you actually just

look at the specifications for a method.

Think about it.

Uh, and use that to decide what you're, uh what?

Your partitions.

What?

Your characteristics are going to be so good.

Places to look are in the pre conditions and post

conditions for a method or function.

Uh, whether there's any relationships between variables, Uh, whether there's

special values, so zero or null or blank or something

like that or empty.

So I won't look at these slides in detail.

This is just saying if we apply a mechanised approach,

we might divide this up into a few partitions.

But a human based approach, we're likely to get more

interesting characteristics.

All right, so once we've got some partitions, uh, we

are going to want to think about selecting particular values

from within those partitions.

Um, in theory, uh, the idea behind partitioning is you've

divided something up into what are called equivalence classes, where

any one member of a partition should be as good

as any other in practise, there is often special values

from partitions.

So there might be, um, values sort of around the

borders of that partition.

Um, and those are worth focusing on.

Often.

There's some values that represent sort of typical use and

some that represent unusual use or exceptional use.

So those are all ideas we might want to draw

on for coming up with values.

Uh, so we've got an example here that I we'll

talk about briefly, but here is a better one.

Somewhere in the Java library, there is something called file

or files.

I forget the exact name, Uh, and an open method

or read lines method, something that takes a path.

If we were adopting, I mechanised approach to that.

Uh, so I, uh, programme was coming up with tests

for us, it might say, Oh, I might pick an

empty string.

Ah, and I might pick a string with one letter

in it and, uh, some strings with saying non non

Western character sets in them.

But all of that is fairly unimportant because the properties

that actually matter will be does the file exist?

And do we have permissions and recall also that when

we are coming up with parameters for this, we'll need

to think about, uh, any state that this method relies

on and one bit of state that it does rely

on.

So we could sort of model that as an extra

parameter say, uh, for testing purposes, we might say, uh,

implicitly.

This has another parameter the state of the file system.

Uh, so a mechanised approach will not give us any

terribly useful tests, uh, human based approach.

So functionality based approach, uh, will lead us to the

idea that we'd like, uh, cases where the fall that

we've named does exist cases where it doesn't exist.

Cases where we do have permissions cases where we don't

have permissions.

Another example of where you get quite different results from

a mechanised approach versus a human approach.

Something like, uh, let's suppose that we have a method

try type, uh, that takes in three introduced, which are

lengths of sides of a triangle.

And it tells us what type of triangle we've got.

So it might be invalid.

It might not be a triangle at all.

So sides of length 11 in five don't form a

triangle.

It might be equilateral it might be.

I saw Seles.

It might be scaling.

A mechanised approach will just give us a bunch of

partitions.

Uh, probably based on dividing each of those ends up

into, uh, positive, negative and zero.

Uh, but a human based approach will notice that first

of all, those aren't particularly sensible ways of dividing up

those parameters, but also that some of them are going

to be equivalent.

So if we've got a triangle with sides of length,

let's say 33 and four.

There's probably not too much point, uh, writing tests, Uh,

where we have 34, and three or 43 and three.

Uh, the result should be the same regardless of what

order those are in.

Uh, so we probably want to consider all of these

parameters together as a bunch rather than look at them

individually anyway, So mechanised approach will give us a whole

bunch of fairly pointless tests, a functionality based approach where

human looks at this will say.

Well, uh, what are some ways of characterising the input?

Um, well, I probably want to use as, uh, my

partitions something like, uh, do the three parameters together represent,

uh, an equilateral triangle, or do they not?

That's partitioning.

Uh, do they represent a scaling triangle or do they

not?

So we might come up with a partition like that.

The partition here says, has divided divided the input space

up into four.

Like I said, it's usually better to choose more characteristics

than so here.

We've just got one characteristic, and we've called it sort

of geometric classification.

What sort of triangle is it?

But probably better would be to have a bunch of

characteristics, so make them binary.

And then if some combinations of things don't work, that's

fine.

We can ignore them.

All right, So I've said already if we've got particular

parts of the system that we want to focus on

in, uh, more detail, uh, we can do that.

So we can we can say this is particularly risky.

Bit of the system were uncertain about it.

Uh, we might focus on it and choose more test

values or spend more effort modelling it and, uh, reviewing

our model of it.

Other bets we might be less concerned about and we

might use a simpler model.

All right, so, uh, and we will look at this

in more detail.

So in last week's lab, we had an exercise where

we sort of had an initial go at, uh, some

I s P based activities coming up with partitions, uh,

and in this week's lab will do that in more

detail.

So let's assume that we have a bunch of partitions,

uh, possibly dozens of them for, uh, one method, Um,

how are we going to choose our test values?

So one way is to say, let's say I've come

up with, I don't know, maybe a dozen characteristics.

One thing we could do is we could say, Well,

try every combination of those characteristics.

Unfortunately, that approach usually leads to many more tests than

it is feasible.

So we, uh, we have a number of other a

number of other criteria for what's called test coverage that

we use to pick combinations.

So I'll look at that.

Next, uh, we will skip over this material on test

coverage.

For the moment.

I will come back to it later.

All right.

Uh, so one of the slides here is just looking

at that triangle classification method and saying, uh, a better

modelling approach would be to use a bunch of characteristics,

uh, each with a small number of partitions.

So when we come to choosing test values, uh, approach

we've got is we've got 12344 characteristics.

Uh, we can look at every way that these can

be applied.

Some of them won't make any sense.

So we can say, uh, let's suppose is scaling is,

uh Well, let's start off by saying, Can we have

a situation where all of them are false?

So it's not scaling.

It's not a socialist, it's not a collateral.

It's not invalid.

No, we can't.

So that's one combination.

But it's not valid.

Uh, let's change.

Is scaling true?

Can we find a set of values?

Where is Scallion is true?

Uh, and all of the others are false.

Yes, we can.

That's a valid combination of partitions, that we might pull

something out of that.

Let's look at the next one on the list.

We might vary that and say, Look at the situation

where it's false.

Look at the situation where it's true.

How does that combined with the others?

Can we find a set of values in there so

we could work our way through and try and find

all all possible combinations of those that work?

So that's called taking the all combinations approach or gives

you, uh, what's called the the all combinations coverage criterion?

Um, and it usually gives you more tests than you

want.

So for most of the testing approaches, we see, uh,

we'll see a few different coverage criteria.

They will usually be one that gives us far too

many tests.

Uh, and we would only adopt that approach if we

want to sort of give some particular component of our

system particular scrutiny.

Uh, so another example of something where we might try

and choose all combinations is Let's suppose we've got a

method that has a bullion and hint and another intent

as parameters.

Um, and I suppose that it's sensible in this in

this situation to divide those up into true and false

synod nous and even and odd.

So I've got two petitions there, three there and to

their, uh, if we wanted to find all combinations of

partitions, uh, then we know we've got two partitions three

and to, uh so that gives us two times three

times two is 12 tests.

So for something small, uh, that's possible.

So 12 is not too bad.

We can we can probably write 12 tests.

Uh, but as we get more parameters and our methods

get more complex, uh, and we have more characteristics.

Uh, this number will start to get quite big as

we look at all combinations of, uh, partitions.

So another approach that is often handy to adopt is

called base choice criteria.

So the intuition here is Well, let's look at these

again.

The intuition here is trying very one thing at a

time.

Let's say that we're focusing on the bullying.

We might try and find sort of sensible default values

for A, B and C uh, and, uh, focus on

our bullion and just very, very the bullying.

So based choice criteria.

We look at each of our characteristics.

Here are characteristics.

We just had one for each parameter.

So we might have We might have more.

For each characteristic, we choose what's called what we call

a base choice.

So we select a partition.

It's often going to be what whatever we think of

as maybe a typical a typical use case or a

default or a simple, uh, simplest option, something like that.

But somehow we decide on a base choice for each

partition.

Uh, and we come up with one base test where,

uh, all of the partitions are using the base choice.

So it's a fairly, uh, a typical sort of a

use case.

Uh, then we go through our partitions one by one,

and we start trying to vary them.

So keeping everything else the same.

Uh, we vary, uh, for one characteristic, which partition we

choose.

The number that we end up with is going to

be.

Sometimes there'll be invalid combinations of things.

But in principle, we've got one base test, and then

for each of our characteristics, uh, we've already we've already

sort of done the base test.

So there's going to be, uh, the number of partitions

minus one.

So for each partition, we have those together and in

principle, that's the maximum number of tests.

Uh, that's the number of tests that we're going to

end up with.

All right, So an example of that, uh, we've got

our method, my method where the bullion and two events.

And we said, uh, we partition.

That is true or false that as, uh, sightedness and

that as, uh, evenness we come up.

So, based on a description of what the method does,

uh, we may be decided that true, greater than zero

and even, uh, sensible sort of base choices here.

So some kind of a default use case.

So another example is for opening a file.

What would our So we've got a parameter path.

We've got a state of the file system.

Uh, what might be a base choice that we would

choose that.

Sorry for characteristics we might have.

The file is in the file system or the file

is not in the file system.

Which one would you choose as a base, Do you

think?

Sorry.

It is in the system?

Yep.

I would probably go for that.

You might say, uh, you know, base choice is going

to be what we think of as, uh, typical use

case or the happy path through the function.

The file is in the system, Uh, and, uh, we

can vary that characteristic.

So the other possibility, of course, is the file is

not in the system.

Uh, we might have some partitions of that.

So if the file is in the file system, we

could have a sub characteristic.

Uh, we have permission to read it, or we don't

have permission to read it again.

We decide.

Whatever we think is a good base choice there.

So I would probably go for we do have permission

to read it.

Um, so for any for any characteristic that we've got,

um, if we're designing tests, we decide.

Um, what are based choice is going to be, and

ideally document why we, uh, why we chose that?

So it's the typical use cases, Um, or I think

this is going to be most common is a perfectly

valid way of deciding that so base choice has got

to be feasible.

Combination of things.

It could be most likely simplest, smallest.

First, any of those is fine, but we should document

why we chose it.

Uh, sometimes we'll decide for whatever reason.

Look, we we really can't pick just one base choice.

There's a couple that are equally sensible.

Uh, that's fine.

We can vary our approach a bit and come up

with something called the multiple based choice Criterion.

Um, we do things similarly, uh, will have more based

based tests.

So let's say for one of our characteristics, there's to

base choices that we've got.

Um, So instead of just one base test, we now

have to.

But then we Then we approach things the same way

as before we work our way through the characteristics and

try varying them one at a time.

So for our method that categorises triangles, maybe we decide

that, uh, equal lateral nous, uh, looking at equilateral nous

uh, both 2 to 2 and 111 are sort of

good based choices of values.

All right, when we have combinations of characteristics that are

not going to work together, that's fine.

We just drop those, we ignore them.

Um, if we're using this base choice criteria and then

one thing we might do is say, what if we

alter the base choice a little, Uh, can we find

a feasible combination if we do that?

So that's another thing that we might consider.

Okay, Is almost four.

So we will take a short break of seven minutes

and then come back at four.

And I will make a start on, uh, logic based

Sorry, graph based testing.

So if you need to grab a drink or anything,

feel free.

Yeah.

Yeah, but more.

How did you but these your question?

Yeah, Yes.

Continue nothing.

Hello.

Very inspiring.

Don't know, Will.

Mhm.

Yeah.

Okay, so in the in the stuff marked as weak

five material, there is a lecture.

Five a, uh, with material called models and approaches.

That just really is a bit of an introduction to

things uh, that we're going to see over the next

few weeks.

So I'm going to let people read through that in

their own time.

It gives an outline of sort of gives a bit

of a preview of, uh, things that were going to

call graph based testing.

So modelling programmes as some kind of a connected set

of, uh, blobs and errors.

It talks a little about how that relates to traditional

testing.

Uhh.

Yeah, and it gives you a preview of what will

call logic based testing and syntax based testing.

But as I say, I'm gonna let people read through

that in their own time.

I'm going to start with the material that's labelled graph

based testing.

So that's the next major topic.

All right, so the idea behind graph based testing is

we identify paths through something.

Uh, we've got a structure we call a graph, Uh,

and it represents paths through whatever.

We're trying to test the system, uh, or a method?

Uh, there's a different.

There's different sorts of ways of representing a system as

a graph.

So if we have got a method, then, um, in

all languages, more or less, we have, uh, well in

altering complete languages, we've got something equivalent to if then

statements So we've got some way of choosing between options,

and we've got some way of repeating things.

So we've got loops.

Uh, so within a method, if we wanted to draw

how how the flow of control passes through the the

code, then we might come up with something like this.

So we might for ram.

If then else statements will have some kind of branching

happening for loops will have, uh, loops in our graph.

Uh, but they'll represent paths through the flow of control

for a method.

We can also have a flu of data between variables.

So whenever I assign a value from one variable to

another or when I assign, uh, data from one variable

and inserted into a list, um, I've got a flow

of data happening.

Why might we want to do that?

So one reason is, uh, in some cases, you want

to, uh, mark particular variables as, say, coming from untrusted

sources.

So if you're writing something like a bulletin board system,

um, one serious security problem that you can cause is

when you have input coming from people who want to

make posts to the forum.

Uh, and you just kind of implicitly trust that whatever

they wrote is kind of safe to throw up on

the Web, and you don't check it in any way.

So whenever stuff goes on the Web, uh, there's the

potential for people to include, um, malicious bits of script,

malicious bits of code in that material.

And if you treat everything that users give you as

trustworthy and put it up on the Web, then, uh,

that can lead to compromises of either your system or

other users.

So that would be bad.

So sometimes you want to say, uh, data that has

made it made it into these particular variables or that

comes from these sources is untrustworthy.

Uh, until it's gone through some kind of a sanitising

process.

Um, we want to track where that data goes.

So that's one reason you might want to look at

data flow between variables.

Another is, in some cases, you've got, uh, systems that

contain, say, confidential information or information at different levels of

security, say, for defence, uh, software systems, uh, you might

want to ensure that information that is confidential, uh, so

stuff in particular, uh, components of the system or, uh,

that ends up in particular variables that that comes in

via particular methods.

You want to track where that goes and make sure

that it never gets uh, leaked to people who aren't

authorised to see it.

So that's another reason why you might want to look

at data flow.

It says here, Data flow between variables, but it could

be It doesn't have to be variables.

It could be between classes or components or methods or

parts of the system or nodes.

Uh, so whole computers in your system.

Uh, there's lots of cases where you might want to

be, uh, concerned about how data flows through a system.

You might have what's called an activity diagram.

So that's a sort of a flow chart that represents

a single users interaction with the system.

So a scenario where the user is interacting with, say,

an ATM or something like that, or your Internet enabled

toaster.

Uh, an activity diagram shows what actions the user takes.

How the system responds, uh, can potentially show decision Bunches

and looping within that another sort of graph that you

might have is it's from the in for here.

So here's an example of what's called an activity diagram,

so it's basically a flow chart.

So here we have the start of some.

Some scenario, we say system displays.

A prompt user enters a user ID and password.

If they're correct, the system does.

One thing, if they're incorrect, system does another.

So that counts as a sort of a graph a

path through the system.

Another sort of graph of a system that we can

have is what's called a state chart or state diagram.

So if we had, say, an automatic door, uh, we

might model that as, uh, say, being in two possible

states either opened or closed, and it can transition between

the two, uh, for more complicated systems, like, say, for

a set of traffic lights.

There might be particular paths that system can go through

in particular ones that can't So, for instance, for traffic

lights, uh, in Australia at least, uh, you're never supposed

to go directly from green to red.

You should always go green, then amber and then read,

uh, read can then go to, uh, to green.

So that sort of thing, you could model with a

state diagram, uh, so potentially there's there's lots of sorts

of things that a graph could represent.

So the essence of a graph is, uh, it's any

way of representing a method or a system where you've

got blobs and areas joining those blobs.

So mathematically, we say that a graph consists of two

things.

We've got a set of nodes.

So are blobs.

So those might represent lines of code.

Uh, they might represent variables, computers.

It all depends on how we've decided to model things.

Uh, and we've got edges between them.

Usually those edges will have some kind of direction to

them.

So for our first example, will consider flow of control

through code.

So that's the case where we've got source code or

pseudo code for a A method, and we come up

with a graph representing the flow of control.

Through that, we use the graph to either, uh, come

up with tests or help us identify bits of that

code that so we may already have some tests.

We may use the graph to help identify things that

currently aren't well tested.

So in a control flow graph, nodes represent lines of

code, sometimes just one line, sometimes multiple lines.

They're basically spots where spots in the programme where the

flow of control can go from or to, and we

have loops, exceptions, and in some languages we have go

shoes.

Uh, and those will get represented as arrows between our

nodes.

So if we have two statements one after the other,

um, we could represent this gets executed and then this

as just a graph.

Where s one statement?

One, uh, always goes to statement.

True.

If that really is the case, if they always are

executed together, we might actually decide to simplify that.

So if it can never be the case, that s

one is executed and not s two, we might decide

to lump them together in one node if we've got

an if, then statement.

So if condition then execute as one after the if

we've got statement as to that would get modelled this

away.

So we've got a division.

We've got our path bifurcate its We can take either

of these choices in our graph, So sometimes when the

condition is true, we'll execute statement as one, uh, but

other times we'll just go straight through the statement as

to if we've got a slightly more complicated.

If then else we'll have a graph that looks like

this.

And when we've got loops, we'll have edges that go

backwards.

Uh, so if we've tried to write our if we've

tried to dry a graph roughly from, uh, top to

bottom, then when?

Whenever we have loops, uh, we'll have bits of the

graph that kind of jumped back upwards in our diagram.

So if we've got a bit of code that says

while C is true execute s one afterwards execute s

two, then we'll have our loop here.

So while condition is true, keep executing s one.

But when it's false, execute, It's true, Uh, and pretty

much any other control structure that we that our language

has, uh, can be, uh, written out so it can

be expanded into one of those forms.

Uh, so the basics of all programming languages are they've

got some way of making decisions and they've got some

way of repeating things.

So pretty much anything that we want to anything that

we come across in our code, we can model in

one of those ways.

Uh, so some of the slightly more complicated ones will

be things like, um, loops that contain break statements or,

uh, next statements so we might have loops that break

out of the loop completely, or loops that skip to

the next round of the loop in some cases, and

sometimes we'll have exceptions.

So for this unit, if you're asked to model something,

Well, if you're asked to give a control flow graph

for a bit of code in this unit, largely we're

gonna ignore exceptions.

Uh, mostly because it just makes things too complicated.

Um, the way that these sorts of breaths get produced

in practises, we typically automate the production of it.

It would be very tongue consuming and kind of pointless

for a human to look a bit of code, uh,

model a complicated bit of code as a graph.

Uh, computers can do the job job just as well.

So often.

What we'll do is we'll have a computer analysed code,

will have it produced some kind of a control flow

graph from that, uh, and in our test framework, we'll

have some way of working out when we execute all

our tests.

Uh, which bits of the graph get covered.

So which passed through the graph get executed and which

don't.

So a lot of this will be automated for us.

So in general, when we've got a graph of something

like control flow through a method, um, often, what we're

trying to do is we're trying to find bits of

it that haven't been exercised yet.

So bits of that graph that none of our tests

go through particular bits of the graph.

We're trying to come up with a test that will

exercise that bit of the graph.

Often, we would like our tests to be fairly small

in the sense that, uh, we'd often like to try

and cover a few bits of that graph and, uh

as little else as we can.

So in practise, we can't do that perfectly.

So let's have a look.

Let's have a look at something like this in practise.

Well, suppose for whatever reason, we discover that our tests

never go through this edge of the graph.

So we we run all our tests, we've had our

code analysed.

It says your tests have very good coverage of this

bit of the graph and this bit and this bit

those all get exercised thoroughly.

Uh, but you haven't done this yet.

You haven't written any test case that goes through, uh,

that bit of the graph, obviously, to come up with

a test case, we can only get there through here.

So by starting at the beginning and getting to the

bit, we need to.

But still, we try and aim for, uh, executing as

little as possible.

Besides what we need to.

So one of the reasons that we do that is

one thing that you want out of your tests, ideally,

is that there give you good localisation when the test

fails.

Um, it gives you a good ability to hone in

on some small bit of your code.

Uh, say that's probably where the issue is, whereas a

test that something like when something like an end to

end test fails.

So you've got something that you set up a system.

Uh, you put in place all the things you need

for a databases files, and you run your whole system

through a particular sort of a scenario when it fails.

Um, that is giving you useful information.

So, you know, the test broke down somewhere through that

process.

It doesn't always give you terribly good.

Um, localisation, though you don't always know exactly what class

or what method the bug was in.

So here, when we're writing smaller tests, uh, what we'd

like is tests that try and execute particular bits of

the graph.

And when they fail, we know there's a bunch of

methods has gone wrong.

So we've got an example here of a binary search,

but I'm gonna rather than work through that in detail,

I'm gonna leave that for the labs instead, we'll look

at, uh, testing criteria for graphs.

Uh, um, criteria you might have for deciding.

Do we have a pretty good coverage of this graph

or not?

Okay, So, uh, here's here's a few criteria that you

might come up with when you're trying to think of

measures of whether something is thoroughly covered.

One is what's called mood coverage.

Have you have you visited every node in the graph?

So here, if your tests visit every possible every line

of code in this, uh, in this graph, every node

in the graph, then you've got what's called mood coverage.

However, um, we've seen that you could have you could

have coverage of every node here, Uh, and not have

gone through a particular edges.

So there might be particular arrows in the graph, which

you have missed.

So no coverage is not quite the same as edge

coverage.

Edge coverage asks, uh, have we have we traversed every,

uh, every one of these edges every one of these

arrows.

So if our tests have gone through all of the

owes, then we've got edge coverage edge pair coverage looks

at adjacent pairs of arrows, adjacent pairs of edges and

says, uh, for all the adjacent for all of those

pairs, have those all been traversed.

Uh, and it is, uh, you can have something that

does have edge coverage but doesn't have edge pair coverage.

So, for example, you might have Can we get an

example from this code?

Actually, I don't think we can, but we'll see examples

of that in the labs so we we can have

edge coverage, but not every pair coverage.

Another criterion is so one sort of rule of thumb,

uh, that you occasionally used to see in testing with

the idea that if you've got a loop, uh, you

should try and write tests that, uh, execute at zero

times.

So they go, uh, potentially skipping the body of the

loop entirely, if that's possible.

Uh, once, uh, and more than once.

And if you've got if you've got all of those,

uh, you've got reasonable coverage, so sometimes that's called, uh,

loop coverage.

So those are a bunch of possible criteria, but we're

going to look at something slightly different We're gonna look

at Well, we will use.

We will end up looking briefly at all of those,

Uh, but the main sort of coverage criteria and we're

going to look at is called prime path coverage.

So it needs a little bit of, uh, sort of

mathematical preliminary.

So some definitions, we're gonna say a simple path, uh,

is a path from one node to another node.

So going through, uh, multiple multiple nodes down some connected

set of edges, uh, where no note appears more than

once, except that the first and the last node can

be the same.

So there's no internal loops, so that's called a simple

path.

So some examples of a simple path If I've got

this graph, then if I pick the note g g

on its own, that counts as a simple path.

Likewise, B, c and D Those are all connected that

counts as a simple path.

So does B C D F B.

So B C D E f b counts as a

simple path.

Uh, so the path is allowed to meet itself, but

only, uh, only at the start and end.

So the start and the end can meet, uh, so

B C D E F B Council simple path.

Uh, but B C D E F B C is

not a simple path, so the loop meets itself internally,

it sort of got internal loops that doesn't count as

simple, so I can't have any internal loops.

So a prime pass we're going to define.

So the mathematical definition is a prime path is a

simple path that does not appear as a proper sub

path of any other simple path.

But the intuition here is it's kind of a longest

possible simple path, so it's making a simple path as

long as it can be, until any further extension of

it would make it non simple.

So here's an example.

I a B c d e f.

So a B C D e f Uh, that's definitely

a simple path.

There's no loops there.

There's no internal loops.

Um, could it be longer?

Could I extend it in any way and still have

it simple?

What do?

So the answer here is No.

I can't add anything to that simple path without it

ceasing to be simple.

So I could add in, Let's say, a B C

D E f.

Yeah, I could add in a loop from F to

B, but at that point it would no longer be

simple.

So a B C D E f is not only

a simple path, but it's a prime path.

It's as long as it can be, uh, without becoming

uncynical.

Let's see another example, so B c D E f

Well, yeah, B C D E f.

That's a simple path because it doesn't intersect itself.

Is it a prime path?

What do people say?

Is that a prime path?

B C D E.

F.

Who says yes?

Who says no?

Okay, the other is is not prime because it can

be made longer.

B C D E f can be extended into a

B C D e f B.

So a simple path is allowed to meet itself at

the start and end.

So a B C D E F B is a

prime path, but B C D E f is not

It could be made longer.

Uh, whenever we have a look like that Well, actually

end.

Yeah, um, feel free to ignore it.

If you want to look at the definition, the definition

says a simple path cannot intersect.

Except that may be the first note, and the last

node can be the same.

So internal loop just means there's some intersection beyond that.

Okay, So whenever we've got a loop like B C

d E F B, um, there'll be a whole bunch

of other simple paths that we get by kind of

rotating at round one.

So B C D E F B is a simple

path.

So is C d E f B C.

So is D E F B C D B C

D, etcetera, etcetera.

So there will be a whole bunch of those.

So uhh, potentially, this gives you combinations of of nodes.

Uh, that the other sorts of coverage we've seen won't

necessarily give you so I said, uh, sort of an

old rule of thumb was, um whenever you've got a

loop, try and write code that executes it, uh, zero

times one time and more than one time, uh, the

prime path criteria and says, uh, try and write tests

that cover all of the prime path so potentially, uh,

if the behaviour of the code is different, so B

C D E F B is one prime path C

D f B C is another.

Um, you can end up with different tests and different

behaviour, uh, for different ways that that that prime path

can exist.

It's, um it's a fairly, uh, fine grained, uh, criterion.

So compared with, uh, node coverage and edge coverage, those

are fairly coarse grained criteria.

Criterion criteria.

Rather, uh, there's, uh, lots of ways you can sort

of miss particular cases, but, uh, prime.

The prime path criterion is pretty fine grand.

So we have prime path coverage of every prime path

in the graph is visited.

Um, sometimes you'll have tests which cover a whole bunch

of prime paths.

That's fine, but yeah, actually means the care of each

award.

Each parent.

So let's say here, um so an edge is the

arrow from a to B.

An edge pair is two edges, so a B B

C.

So a BBC or ABC that's a pair of edges.

Uh, B C.

D is a pair of edges.

CDF is a pair of edges.

DF is a pair of edges, so it's just no,

no payments to.

That's what Pierre means.

All right, So, um, if we have prime path coverage

necessarily, so it subsumes node and edge coverage.

So if we visited all of the prime paths necessarily

will have visited all of the nodes and we'll have

visited all of the edges, so it is possible to

have So we said edge pair coverage.

It is possible to have, uh, pairs of edges that

we might We might have prime path coverage and still

not have visited every pair of edges.

Um, so it's possible, um, we may have examples in

some of the assignments where that is the case.

But the most common thing that we're going to worry

about is just Do we have prime path coverage?

So we'll have, uh, some, uh, set of tests.

And we might ask you, does this set of tests

give you prime path coverage of some particular graph we

show you, uh and you should be able to say

either Yes, it does, or no, it doesn't.

Okay, so one thing to note about, uh, this sort

of graft based modelling is when we've got an if

statement So here, when we've got a brunch in our

graph that corresponds to some kind of decision points at

some kind of if statement or case statement or something

like that in our code, um, sometimes you can have

extremely complicated if statements that are have a whole heap

of sub clauses them.

So you might have if this variable is less than

12 and this other variable is greater than something or

something else.

So you could have a very complicated, uh, condition in

a loop or in an if statement, a graph based

testing just treats those as well.

It treats them as a known as a kind of

a black box.

So either the whole condition evaluates to true or it

evaluates to false.

So graph based testing doesn't sort of prove into detail

that the innards of those logical conditions, uh, just asks,

uh, what path did you take through the graph.

Uh, you know, for an if statement, did it come

out as true, or did it come out as false?

So complex bullying conditions, uh, you can sort of think

of as being a black box.

So graph based testing doesn't doesn't probe into the details

of them.

Um, for some sorts of systems, you do want to

look pretty carefully at that.

So in avionics, one of the there's a whole bunch

of criteria that software and for planes is supposed to,

uh, past.

You're supposed to have very good coverage of the code.

You're supposed to ensure that you've exercised all the possible

entry points, all the possible exit points.

Um, I think I forget it's got some some sort

of edge coverage.

I forget the exact details, but it's also got a

requirement, Uh, that any logic, uh, any conditions in your

programme.

So any, uh if statements or conditions in loops, it's

got a requirement that you write tests that exercise the

individual little bits of those, um, condition als in detail.

And when we do that, we end up with what

we call logic coverage.

Okay, sir, I have actually got ahead of where I

expected.

So we will finish a little bit early unless people

have got particular questions or want me to look at

something in more detail.

Uhh.

So, um yeah, I'll be around for questions.

Yes.

Yeah, yeah.

So it's adjacent pairs of edges.

Um, I think that forms one of those, uh, avionics

criterion is you're supposed to have, uh, edge pair coverage

for your tests.

Um, I can find out for you.

All right.

So, uh oh, no, it doesn't have an age criterion.

So m c D.

C is the, uh is a particular standard.

Uh, so it requires every entry and exit point is

invoked.

So if you've got one of those graphs and there's

multiple ways of coming into it or multiple ways of

coming out of it, you've got to cover all of

those.

Uh, every decision takes every possible outcome.

So whenever you've got a branch, you've tried them, tried

them all.

Uh, and the logic bit of it is this fourth

part, it says, uh, so each condition in the decision

is shown to independently affect the outcome of the decision.

Um, well, look at that in more detail.

in the next couple of lectures.

But, uh, instead of saying, take your big complicated, um,

conditional.

That's part of an if statement, uh, break it down

into smaller bits that are either true or false.

So they'll be joined with ends or oars or knots

or something like that, and try and modify each one

of them in turn.

Uh, such with everything else taking on values, uh, such

that you can sort of, uh, flip the condition as

a whole.

Um, so Yeah, well, look at that.

Under logic coverage.

Mhm.

Is there anything else?

You don't think there's anything else I vitally need to

look at from that five a bit.

So yeah, I will.

I will finish it there.

Okay.

Thanks very much.

And see you in the labs or next week.

Yeah, Very tasty.

Really?

Okay.

Mhm America output.

You can't hide, I think a number you're looking for.

Well, you know when you're covering your big upset, your

Yeah, I know my college loud.

The union to run drugs.

Hi.

Okay, I don't think.

Okay, so now you think how you can kill?

Absolutely.

For what you're watching.

Bob Chapman singing the Rock, The input domain, right?

You know?

Yeah.

Recent For without a deal.

Real power, gentlemen.

Quiet.

Well, I'm very confident.

Oh, it must be this tall.

