这是个课堂录音，你来说说老师说了什么
page_content="okey doke.  So, um, stuff for today The, uh, project came out  last week, and the, uh there's a sandbox open in  mood so that you can, uh, try out, uh, uh,  answers to questions for that.  Um, I've been clarifying a few bits and pieces on  the forum.  Uh, but, uh, probably after today I'll release.  I'll assume that if there were things that people needed  clarified, then they've already done so And I'll, um, release  a new version of the spec.  Uh, and that will be the one that we work  with.  That's just spare that up.  So, aside from questions that people have asked, I've been  thinking I might remove question nine because I think there's  probably already enough coding to do in the time available.  Um, if someone's already answered it or desperately thinks that  they want it in and it will improve their mark,  then let me know.  But otherwise I think I'll, um, I'll remove question nine  because I don't think there's I think all the, uh,  all the information that it gives me about you know  what you understand about, um uh, syntax testing is probably  available from the other questions.  So, uh, I will take that one out.  Uh, I've uploaded to the website.  A zip file, Uh, with some, uh, I a t  a codes for airports and airlines in there's a lot  of them.  So, um, you might want to be, um, cautious about  how you use them.  Uh, if you try.  And, uh, I mean, you should only need them for  fairly specific purposes.  So think about, um, what your tests need to do  and why you might need access to a real I  A t A code.  Most a lot of the questions are questions one and  two.  And for that matter, three and four.  Uh, will, um, you can assume that, uh, I a  t a codes, and you just need to check their,  uh, syntactical validity.  And there's a few assumptions you can make about how  to do that.  So you can assume that, um, an airport code is  just, uh, three capital letters.  And I'll add some assumptions about, um, uh, airline codes.  So for the for the syntax purposes, uh, in reality,  if you wanted to say something is a a valid  I a t a airport code, you'd sort of have  to go to the the final list and say this  is the list of what they are.  But for the syntax checking.  Uh, yeah.  You've got some some simplified assumptions you can make.  Uh, they're gonna differ slightly between the questions on syntax,  checking and other questions like, um, applying ISP.  So I'll I'll be adding some clarifications to question six  about, um, What you can assume about, um syntactically What  are syntactically versus?  Semantically valid?  Uh, I a t a codes of various sorts.  Um, the how are people funding the project so far?  Any comments on things that are difficult or or easy?  No.  Oh, yeah.  Yeah.  Well, um, I thought I could do a lot for  a question worth four months.  Yeah.  So I was kind of I I thought I was  doing something wrong, but I think I Oh, OK, I  I will give, um So all of the questions there,  um, for the ones that require code, there's some, uh,  visible tests in mood.  And there's some hidden tests.  Uh, the the project specification.  Once I finished amending, it should be exactly enough information  to complete the project.  Uh, so you shouldn't need anything more.  Uh, but I may add a few clues about the,  um, some of the hidden tests I can see from  the mood attempts that some people are finding, uh, the  B N f, uh, question tricky.  I do recommend people use the, uh, the B n  F playground.  Uh, because it is, uh and I said so in  the forum.  Uh, because it's quicker to respond than noodle, and it's  easier to read.  It's prettier, Uh, and it also gives you full online  help explaining exactly what syntax it's using for, uh uh,  e b n f.  So it would definitely be, uh, a good idea to  check your grammar in the B N F playground before  checking out with mood.  Uh, what else are there?  No, that's all Fine.  So, yeah.  Uh, uh, Yeah.  Yep.  Uh, where are we?  Sorry.  Um what section?  4.1?  Uh, yes, sir.  OK, uh, currency code three.  Letter code.  And what was the query?  Oh, right.  OK, that is definitely a mistake.  Uh, so no.  No.  So I'll fix that up.  Uh, and yeah, if people want a list of three  letter currency codes, then I'll uh uh, I'll add those  as well.  Uh, Yeah.  I mean, I don't think there's actually too many of  them.  There's only a few 100 countries in the world after  all.  So we can't have that many currencies.  Um, OK, can you email me and remind me of  that?  And I'll correct that, Uh, so, yeah, I might add  a hint about or some test strings for what those  two commands should look like, so that you, um, have  a little more to go on.  But otherwise it should be so question one should be.  If you've kept up to date with the material on  grammars, it shouldn't be too hard, uh, questions for So  there's a couple of questions on coding.  Uh, I'll add the rubric, but, um, there will be,  uh, two marks for code and two marks for style  and clarity.  So you should be following good coding practises.  They're listed on the website.  Um, there'll be two marks for neat, well presented, easy  to read code that follows all good practises, one mark  for code that has one or more sort of medium  or a bunch of minor errors with it, and zero  marks for code, which has got multiple major problems with  it.  So for the questions which take English answers, those will  have the the usual breakdown of, um, half marks for  relevance, half marks for justification.  And we've already seen how the rubric for those works,  uh, question seven, uh, 12 marks.  So, for this question, um, we're supposed to implement three  test cases, and they're supposed to be test cases that  you specified in question six.  So if you to get marks for that, they have  to be real test cases, so they have to actually  assert something.  And it has to be whatever it was that you  specified in the in the, um uh, in question six,  uh, so answers that don't actually contain any real tests.  We'll get zero for that.  Um, it has happened occasionally that people have submitted very  peculiar things that don't actually contain any assertions.  So, yeah, those don't qualify as tests.  Um, for question seven.  And I'll clarify this.  You can import anything you like.  Uh, so you're writing a whole class.  You can, uh, add whatever imports you like for the  other coding questions where you're only writing a method.  Uh, you're limited in to, uh, what's already been imported.  Uh, I'll add You're told you can use anything in  java dot il dot star Um, I'll probably add, uh  java dot il dot Rx as well.  So you can use uh, r X methods if you're  familiar with how to use them in Java.  So I say so.  If I take out question nine, there will be nine  questions to do, and they're still wearing 10.  So, yeah, there's still two weeks to do it in,  So should be, I think, plenty of time.  It should only require, uh, I don't know, an afternoon  or so per week for each of the two weeks.  And, uh, and it should be done.  Any other queries about the project?  It's everyone.  All right.  So I was also going to very briefly look at,  um, one of the labs on logic based testing.  So let's have a look at that.  Six.  So that's workshop five.  OK, uh, so one of the one of the solutions  to workshop five talks about how worthwhile it would be  to use different sorts of testing.  So let's look at the sample method that we've got  there.  So this is looking at a, um, a website login  method and from the workshop on, uh, from the lab  on, uh, system testing.  Uh, you should have a rough idea of what website  handler methods look like.  They tend to look something like this.  Uh, they handle some particular sort of path or portion  of, uh, website functionality.  And a lot of them take in as a parameter.  Whatever request it is that the user has just made.  So the user says, I wanna see this web page.  Uh, that request goes from the browser to the server  and in your code, you get to see it as,  uh, some sort of h c t p request object.  So there are a whole bunch of tests we might  wanna write for this, uh, handle login thing.  Uh, it doesn't have any comments, so that's bad.  But, um, let's assume that it does have, uh, actual  Java doc comments.  Uh, and it says something along the lines of, uh  this method looks in the in the request for, uh,  a user ID parameter and a password parameter, and it  checks them against our user database.  And, uh, if the user ID is a valid user,  ID and the password is a valid password, and the  user's account has not been disabled.  Then, uh, we show them the welcome page.  Uh, and if any of those things are false, uh,  we show some kind of an error so often, uh,  it depends on the framework.  Uh, but, uh, often you can indicate, uh, errors just  by throwing particular sorts of exception.  Uh, and those will come up in the browser as  saying something like, um uh, if it's one, if it's  one of the sort of exceptions you're expecting, like you're  not allowed to see this page, uh, then some sort  of error will come up in the browser saying that's  forbidden.  Uh, if you've made a mistake in your code and  some sort of other exception turns up, then that usually  shows up in the browser as being a, uh, a  status 500 error server fault.  So something's actually gone wrong with the, uh, the server,  which is bad.  Um, so if we were gonna test this so it  says, um, user name must be right.  Password must be right.  Uh, account.  Can't be disabled.  If we wanted to use, say, ISP, what would some  of our characteristics be that would we we would use  to to test that.  That What's that?  So a characteristic is always a property.  So, uh, one thing we could say is validity of  the user.  ID.  That's a That's a possible property.  Um, and another one is validity of the password.  Uh, and the last one is, uh, status of the  password.  So whether it's been disabled, So there's an explicit parameter  here, uh, the request.  And there's two things" metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="done.  Any other queries about the project?  It's everyone.  All right.  So I was also going to very briefly look at,  um, one of the labs on logic based testing.  So let's have a look at that.  Six.  So that's workshop five.  OK, uh, so one of the one of the solutions  to workshop five talks about how worthwhile it would be  to use different sorts of testing.  So let's look at the sample method that we've got  there.  So this is looking at a, um, a website login  method and from the workshop on, uh, from the lab  on, uh, system testing.  Uh, you should have a rough idea of what website  handler methods look like.  They tend to look something like this.  Uh, they handle some particular sort of path or portion  of, uh, website functionality.  And a lot of them take in as a parameter.  Whatever request it is that the user has just made.  So the user says, I wanna see this web page.  Uh, that request goes from the browser to the server  and in your code, you get to see it as,  uh, some sort of h c t p request object.  So there are a whole bunch of tests we might  wanna write for this, uh, handle login thing.  Uh, it doesn't have any comments, so that's bad.  But, um, let's assume that it does have, uh, actual  Java doc comments.  Uh, and it says something along the lines of, uh  this method looks in the in the request for, uh,  a user ID parameter and a password parameter, and it  checks them against our user database.  And, uh, if the user ID is a valid user,  ID and the password is a valid password, and the  user's account has not been disabled.  Then, uh, we show them the welcome page.  Uh, and if any of those things are false, uh,  we show some kind of an error so often, uh,  it depends on the framework.  Uh, but, uh, often you can indicate, uh, errors just  by throwing particular sorts of exception.  Uh, and those will come up in the browser as  saying something like, um uh, if it's one, if it's  one of the sort of exceptions you're expecting, like you're  not allowed to see this page, uh, then some sort  of error will come up in the browser saying that's  forbidden.  Uh, if you've made a mistake in your code and  some sort of other exception turns up, then that usually  shows up in the browser as being a, uh, a  status 500 error server fault.  So something's actually gone wrong with the, uh, the server,  which is bad.  Um, so if we were gonna test this so it  says, um, user name must be right.  Password must be right.  Uh, account.  Can't be disabled.  If we wanted to use, say, ISP, what would some  of our characteristics be that would we we would use  to to test that.  That What's that?  So a characteristic is always a property.  So, uh, one thing we could say is validity of  the user.  ID.  That's a That's a possible property.  Um, and another one is validity of the password.  Uh, and the last one is, uh, status of the  password.  So whether it's been disabled, So there's an explicit parameter  here, uh, the request.  And there's two things about that that we can say  the request might contain.  Uh, a a valid user name.  It might contain a valid password.  So we pull those out of the request here.  Uh, so those are some, uh, some characteristics that we  can use to partition up requests.  Uh, and, uh, there's an implicit parameter there because we're  making use of state.  Uh, here we've used a a user DB object, and  we're not told exactly what that is.  But it must be, uh, some sort of, uh, instance  variable or static variable or something.  Uh, that's defined outside this method.  So it's in a class.  Uh, it's in the the class as a whole.  Uh, so that state also forms part of the parameters  when we apply ISP, uh, and so we can make  a few characteristics about that.  Um, and we've seen you can have combined characteristics so  you can have characteristics that relate to parameters.  Uh, so you might say one characteristic is, uh uh,  does the user ID and the request match your user  ID in the database so we'd have, you know, three  or four or so ISP characteristics.  Uh, and we'd write tests for all of those, and  hopefully they would pass if we wanted to check our  coverage.  Then there's a few ways we can do that.  So ISP itself defines a sort of coverage.  So we can say, Do I have base choice coverage?  And we'd, uh, work through, uh, and see whether that's  the case.  Uh, if we wanted to ask whether we had, uh,  let's say brunch coverage based on, uh, based on, uh,  looking at the the control flow graph here, uh, let's  assume we write our So we've got about four characteristics.  Uh, there's probably about two or so partitions for each  of them, so I end up with about eight tests.  Um, do you think we would have branch coverage if  we measured branch coverage here.  Who thinks we would and who thinks we would not?  All right, why would we have brunch coverage?  Right.  Exactly.  You've got, like, three if statements in there.  So, uh, each of them is yes or no.  Your partitions probably contain exactly the same things.  So one of your characteristics will be, uh, you know,  does the user in the request match a user in  the database?  Yes or no?  So you'll have checked, uh, the yes path.  Uh, does the user record exist and you'll have checked  the no path.  So there is no such user.  Uh, and you'll have checked is their password, Right?  And you'll have checked Is their password wrong?  And, uh, presumably, you know, this would be in the  documentation you'd check, uh, the partition where their account is  disabled and a partition where their account is not.  So there's only three if statements in there and your  ISP testing should really cover them all.  So, yes, you'd have branch coverage.  Um, would you have prime path coverage?  OK, I'll tell you, the answer is yes.  So, prime birth coverage, uh, if there's no loops, is  not really gonna differ from Branch coverage from edge coverage  or branch coverage or any of those sorts of things.  Uh, so prime paths, uh, there's about.  Well, there's six of them.  We've got, uh, uh, go here and fail this.  So throw this no user exception.  Uh, go here and fail this So the password doesn't  match.  Go here and fail this, uh, the disabled status or  carry straight through.  So 1234.  So there's only four prime paths in there.  Uh, the only time prime path.  So prime path coverage.  Isn't that actually gonna add any?  You know, if you've done branch coverage, you've already got  prime path coverage for this.  It only differs when we've got loops of some sort.  Um, what about logic coverage?  Would we have closed coverage?  Who says Yes.  Yes, she says no.  Uh, so we say that the clauses are the little  bits inside a predicate.  Well, each of these only has one clause.  So clause coverage is gonna be exactly the same as  branch coverage.  Uh, there's no structure within these these bullying they They  only have one thing in them.  There's one comparison.  So, uh, doing logic based testing, uh, he's only going  to add something to any of the other sorts of  testing, like, you know, branch or edge testing.  Uh, when you actually have, uh, if statements that have  more than one clause in them If they only have  one clause, then, uh, all of the logic testing that  we saw all the, uh, all the possible levels of  coverage are already gonna be satisfied because they'll just be  the same as branch branch testing.  So we could do predicate predicate coverage and closed coverage  and active closed coverage.  Uh, and they would all come out to exactly the  same thing.  We just end up with four tests and they'd be  the same four tests that we get from graph coverage  and from IP.  Well, there might be a few more for ISP, but,  um uh, So what's that?  We've got, um, ISP graph syntax.  OK, we could also look at the syntax of an  H T.  P request.  That's possible.  An H T.  P request.  In addition to being a sort of class in Java,  it's actually a a text document that gets sent from  your from your browser to the, uh to the Web  server.  Uh, if we did syntax based testing do what would,  what kind of coverage might we have?  Would it add anything to to the testing here?  Who thinks it would?  Would it be useful who thinks it would be useful  and who thinks not OK, people who say not why  not?  Oh, John, that would be really wrong.  I think if if you it's not really gonna be  the same No, it's not.  Uh, one reason is because if the if the request  was invalid, we'd never be here in the first place  Like we couldn't have one of the one of the  invariants of, uh, any sort of an H T P  request is that the the the the object can only  be constructed when the server actually got a valid HTTP  request.  So if we're here, this must be valid.  So this is one of the reasons why, uh, class  in variants and preconditions are important because they let you  know what sort of areas you can usefully think about  at any point in the programme.  So at this point in the programme, there's there's no  point worrying about whether that request was invalid in some  way because it can't be assuming assuming HTTP request has  been thoroughly tested.  And, you know, it's part of the Java, Uh uh,  the Java library.  So we'll assume it has.  So it's impossible for that request to be invalid or  something has gone very, very wrong with, um, the Java,  the Java libraries.  Um, so syntax testing actually really wouldn't help us much  here, but, um, if we did do it, uh, we'd  wind up with, um so if we limited so syntax  testing, uh, if we checked for things that happen when  the syntax is not complied with at all, uh, we  wouldn't be here, so that doesn't add anything.  Uh, if we divide the request up into requests that  are valid and, you know, exercise different bits of the  the clauses or whatever, Uh, none of those are going  to make any difference, except for the tiny, tiny bits  of the request that correspond to the user ID and  the password.  Uh, so it won't cover this this disabled case.  Uh," metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="something to any of the other sorts of  testing, like, you know, branch or edge testing.  Uh, when you actually have, uh, if statements that have  more than one clause in them If they only have  one clause, then, uh, all of the logic testing that  we saw all the, uh, all the possible levels of  coverage are already gonna be satisfied because they'll just be  the same as branch branch testing.  So we could do predicate predicate coverage and closed coverage  and active closed coverage.  Uh, and they would all come out to exactly the  same thing.  We just end up with four tests and they'd be  the same four tests that we get from graph coverage  and from IP.  Well, there might be a few more for ISP, but,  um uh, So what's that?  We've got, um, ISP graph syntax.  OK, we could also look at the syntax of an  H T.  P request.  That's possible.  An H T.  P request.  In addition to being a sort of class in Java,  it's actually a a text document that gets sent from  your from your browser to the, uh to the Web  server.  Uh, if we did syntax based testing do what would,  what kind of coverage might we have?  Would it add anything to to the testing here?  Who thinks it would?  Would it be useful who thinks it would be useful  and who thinks not OK, people who say not why  not?  Oh, John, that would be really wrong.  I think if if you it's not really gonna be  the same No, it's not.  Uh, one reason is because if the if the request  was invalid, we'd never be here in the first place  Like we couldn't have one of the one of the  invariants of, uh, any sort of an H T P  request is that the the the the object can only  be constructed when the server actually got a valid HTTP  request.  So if we're here, this must be valid.  So this is one of the reasons why, uh, class  in variants and preconditions are important because they let you  know what sort of areas you can usefully think about  at any point in the programme.  So at this point in the programme, there's there's no  point worrying about whether that request was invalid in some  way because it can't be assuming assuming HTTP request has  been thoroughly tested.  And, you know, it's part of the Java, Uh uh,  the Java library.  So we'll assume it has.  So it's impossible for that request to be invalid or  something has gone very, very wrong with, um, the Java,  the Java libraries.  Um, so syntax testing actually really wouldn't help us much  here, but, um, if we did do it, uh, we'd  wind up with, um so if we limited so syntax  testing, uh, if we checked for things that happen when  the syntax is not complied with at all, uh, we  wouldn't be here, so that doesn't add anything.  Uh, if we divide the request up into requests that  are valid and, you know, exercise different bits of the  the clauses or whatever, Uh, none of those are going  to make any difference, except for the tiny, tiny bits  of the request that correspond to the user ID and  the password.  Uh, so it won't cover this this disabled case.  Uh, because you can't You can't tell from looking at  the, uh, looking at the request, whether, um, uh, the  account is disabled, but, yeah, syntax testing isn't really gonna  add anything of use here, so there's not really any  point doing it.  So, for for any of these sorts of coverage it's  worth thinking about, Yeah.  How how difficult would it be to assess this level  of coverage?  Would it add anything to what?  What we already know.  Um, if I know that there's no loops in my  programme, then you can say, Yeah, we could test for  prime path coverage, but we we know that we've already  got it.  If we've already done, uh, branch coverage.  So, uh, there's a little on different sorts of coverage  we could have and whether it's worth doing them.  All right.  So onto the lecture, there are, uh there are a  couple of things I'm gonna record.  So I need to record the stuff on quality assurance.  I'm gonna record the material on risk.  Uh, this is so we can get through the material  on formal methods.  Uh, we've got a case study, which is quite short  about, um, a situation where, uh, risk went very wrong,  Uh, for one company.  So this is the knight capital trading loss case.  Uh, but today, I'm gonna talk about, uh, four more  methods, and we're gonna look at the Daphne language.  Alright, so we're gonna look at what formal methods are  Why we might want to use them.  Um, And once we get on to Daphne, we'll look  at formal verification.  And, uh, there's a few, uh, useful sources here.  Pressman actually no longer has the reading that we used  to use on, Um uh, formal methods.  So there's a couple of books here that are potentially  useful, but I'll see if I can find any shorter,  like, just a chapter or so that, um uh, might  be useful background reading if you want to go beyond  the slides.  OK, So what are formal methods?  Uh, is not a terribly clearly defined term.  Uh, at any one point in time, uh, people are  probably gonna have slightly different opinions on whether something is  a formal method or not.  That is a full screen.  Uh, but roughly they're all maths based techniques for describing  system properties of some sort.  Uh, so whenever we're doing any sort of software engineering,  so we're specifying and developing software systems, we can do  them with different levels of mathematical rigour.  We can have none at all, or very little, uh,  or we can have some or a lot, uh, stuff  that's towards the more messy and more formal side, uh,  tends to get depending on how hard they are to  do.  Really?  Uh, and how much maths is involved, they'll get called  either lightweight formal methods or formal methods.  Uh, so really, it's just really It just means at  any point in time stuff that most programmers consider Mathy.  Uh, because once a technique gets very widely accepted, uh,  it doesn't really get called a formal method anymore.  People just start to consider it a normal part of  programming or specification.  Uh, we use them because building reliable software is very  hard.  A software system can be extremely complex.  Uh, so when we talked about exhaustive testing, we know  that for each variable in a programme, if you've got  just an an one in in your programme, there's already  two to the 32 values it could take on.  Once you've got a few of those, uh, the state  of your programme your system at any one point in  time.  Uh, it could be one out of an absolutely astronomic  number of states, so it's, uh, it can be quite  hard to pinpoint uh, exactly what the behaviour of a  system is.  So people have come up with all sorts of techniques  for improving reliability.  Some of them we've seen.  So some of them are dynamic techniques.  So testing is a dynamic technique.  You run the system, uh, you see what its behaviour  is, and and you've written tests that look for specific  examples of good or bad behaviour, and you try and  find them.  Uh, we've seen some static techniques.  So static analysis and reviews, uh, both static techniques.  You get people or programmes to look at your code  or your designs or your specs and try and come  up with problems.  Uh, in the recorded lecture, we'll look at risk management  and quality controls.  Uh, but, um uh, in addition to those, uh, we've  got, uh, a number of mathematics based techniques.  So most of the techniques we've seen so far are  empirical.  Uh, they're sort of like, uh, science.  You go out and look at things.  Uh, if you're a biologist and you want to know  something about it particular species of animal or plant or  something, then you go out in the world and you  you find them and you observe things about them, so  testing is empirical.  Um, if you don't find a bug using testing, it  doesn't mean there are no bugs.  It might just mean you didn't look hard enough.  So formal methods, on the other hand, are are based  on the idea generally of mathematical deduction.  So there are things that absolutely must be true.  And the idea is that by by reasoning about properties  of our system, uh, we can get certainty that our  programmes are reliable and error free.  I should qualify that a bit, though, because are often  doing this for a whole system can be expensive.  Sometimes it might be, uh, that you just apply formal  methods to a part of your system.  So, as an example, let's consider requirements.  So, uh, requirements can be specified, uh, informally.  So we could do them in natural language.  We might have a A requirements document.  We might have user stories.  Uh, it might include tables and diagrams, and that's one  of the most common ways of giving requirements.  Uh, and for people who speak the language natively, it's  fairly easy.  But issues with it are are that it can be  imprecise and ambiguous and it can be hard to spot,  uh, where imprecision and ambiguity have crept in.  Uh, it can also actually be very, uh, very vise.  Uh, so we could specify our requirements.  Informally, we could, uh, maybe add in occasional math formulas  or bits of code by requirements.  I'm actually covering requirements and specifications here.  So any sort of constraint on the system, uh, or  we could lean towards the more formal level we could  use mostly some sort of mathematical notation, uh, with bits  of English to clarify what it represents.  Uh, this tends to be more effort.  So you need someone who knows the notation and understands  it.  Uh, and you can have the issue that, um, what  you've written in your notation, Um might not match up  with what you thought you were saying, but it has  the advantage that there is little or no vagueness or  ambiguity, and I'll talk a bit more about vagueness and  ambiguity later.  So if we wanted to specify exact parameters and commands  accepted by a programme or the format of an H  t HTTP request, uh, we could do that in natural  language.  Um, but that's actually extremely verbose.  Uh, specifying things like formats in particular, uh, writing again  and again and again" metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="static techniques.  You get people or programmes to look at your code  or your designs or your specs and try and come  up with problems.  Uh, in the recorded lecture, we'll look at risk management  and quality controls.  Uh, but, um uh, in addition to those, uh, we've  got, uh, a number of mathematics based techniques.  So most of the techniques we've seen so far are  empirical.  Uh, they're sort of like, uh, science.  You go out and look at things.  Uh, if you're a biologist and you want to know  something about it particular species of animal or plant or  something, then you go out in the world and you  you find them and you observe things about them, so  testing is empirical.  Um, if you don't find a bug using testing, it  doesn't mean there are no bugs.  It might just mean you didn't look hard enough.  So formal methods, on the other hand, are are based  on the idea generally of mathematical deduction.  So there are things that absolutely must be true.  And the idea is that by by reasoning about properties  of our system, uh, we can get certainty that our  programmes are reliable and error free.  I should qualify that a bit, though, because are often  doing this for a whole system can be expensive.  Sometimes it might be, uh, that you just apply formal  methods to a part of your system.  So, as an example, let's consider requirements.  So, uh, requirements can be specified, uh, informally.  So we could do them in natural language.  We might have a A requirements document.  We might have user stories.  Uh, it might include tables and diagrams, and that's one  of the most common ways of giving requirements.  Uh, and for people who speak the language natively, it's  fairly easy.  But issues with it are are that it can be  imprecise and ambiguous and it can be hard to spot,  uh, where imprecision and ambiguity have crept in.  Uh, it can also actually be very, uh, very vise.  Uh, so we could specify our requirements.  Informally, we could, uh, maybe add in occasional math formulas  or bits of code by requirements.  I'm actually covering requirements and specifications here.  So any sort of constraint on the system, uh, or  we could lean towards the more formal level we could  use mostly some sort of mathematical notation, uh, with bits  of English to clarify what it represents.  Uh, this tends to be more effort.  So you need someone who knows the notation and understands  it.  Uh, and you can have the issue that, um, what  you've written in your notation, Um might not match up  with what you thought you were saying, but it has  the advantage that there is little or no vagueness or  ambiguity, and I'll talk a bit more about vagueness and  ambiguity later.  So if we wanted to specify exact parameters and commands  accepted by a programme or the format of an H  t HTTP request, uh, we could do that in natural  language.  Um, but that's actually extremely verbose.  Uh, specifying things like formats in particular, uh, writing again  and again and again you know, the n word or  the nth bite of this can be blah, blah, blah,  blah, blah would be very verbose, and it's not precise  or we could use a specification language.  So we've actually already seen one, uh, b N F  and, uh, extended B N f are are specification languages,  so that's math.  Uh, and if you look at a lot of, uh,  formal standards for various bits and pieces of, uh, languages  and technologies, we use, uh, plenty of them.  Use B N f so RFC 2616, which specifies what  an H T.  P request looks like.  Or at least it's one version of the standard.  There's probably new ones now, uh, uses exactly the notation  we've seen.  Well, it's a bit different.  So, um, it doesn't use the angle brackets, but it  uses a form of B N F to specify uh,  what a whole ATT P request looks like.  Uh, and something like this.  So it says, here's what a hex digit is.  Um, it's unambiguous.  So, assuming you know how to read E b N  f, there's no ambiguity about what makes up a hex  digit.  So do you want to know?  Can it be upper case?  Can it be lower case?  The answer is both of those are covered.  Uh, does it include digits?  Yes, it does.  What are the digits here?  They are, So there's no ambiguity here.  Uh, and it's a lot shorter to write it this  way, uh, than it would be to, um, spell out,  uh so it takes, you know, three lines in the  length that would take you to say, uh, it can  be a digit from 0 to 9 or an upper  case letter from A to F or a lower case  letter from A to F, uh, followed by, uh, a  digit.  Uh, then, uh, you'd have spent, uh, just as long  as you would have writing it.  Uh, precisely in B N f.  So B and F is, uh, is very concise.  It's usually shorter than any kind of, um uh, sufficiently  precise natural language description would be, uh it's precise, and  it's unambiguous.  Uh, and it also has the advantage that we can  actually process and use it, uh, programmatically so we can  get, um programmes to look at a B N F  grammar and tell us things about it.  They can tell us.  Is it Is it finite?  Is it infinite?  Have we got various sorts of coverage in our tests?  Uh, we can tell them to create a parser or  a generator.  So the mood, um, or you've seen the the B  N F playground.  And, uh, the mood tester is using exactly the same  node J s code that the, uh the B N  f playground uses to to read your grammar, convert it  into a pizza and then apply the parser to a  bunch of test strings and see if it works.  So there's a lot of power there.  Uh, what are the things that we can avoid by  using them?  Uh, depending on what sort of formal method we're using,  Uh, we may be able to avoid or check for  contradictions.  So, in a large natural language set of requirements or  specifications, uh, it can be tricky to check to see  whether there's any requirements that contradict each other.  So you can have that where you've obtained specifications from,  uh, a lot of different users and stakeholders, and no  one's noticed that, uh uh, something there, uh, contradicts itself.  So one requirement says all temperatures in a chemical reactor  must be monitored.  Another says only temperatures in a specific range.  Uh, we can have ambiguities.  So ambiguity is where you've got, uh, a statement that  can be interpreted in multiple, different ways.  Technically, an ambiguity is two ways, and if it's more  than two ways, it's called policy need.  But usually we just, um, call them ambiguities.  So here we have, uh, the operator identity consists of  the operator name and password.  The password consists of six digits.  It should be displayed on the security screen and deposited  in the login file.  When an operator logs into the system, Is there any  ambiguity there?  One is the word.  It is not at all clear what it means that  it mean the password, which was the most recent thing  we mentioned or the identity.  Uh, now I assume if someone trying to work this  out might say, Well, it has to be the password,  because why would we display?  Sorry, it has to be the, uh, the identity, because  why would we be displaying the password on the screen?  But, um uh, As it stands, it's stands.  It's ambiguous.  Uh, should is also ambiguous.  Um is not necessarily clear whether that means the system  must do X or that this is AAA good to  have requirement.  That would be good if the system does X, but  it's acceptable if it doesn't.  And there's a whole bunch of other terms that, um  are ambiguous because they have more than one meaning.  Sometimes they've just got a technical and a non-technical meaning.  Sometimes they've got a whole bunch of non of technical  meanings.  So reliable, robust compos category failure, orthogonal, backend, coln platform  entropy.  Uh, nearly all of those have at least three or  four possible meanings.  So ambiguity is very easy to, uh, accidentally incorporate into  your requirements.  So separate.  So ambiguity is where something could mean two or more  distinct things.  Uh, vagueness is a different problem.  Uh, vagueness uh, is where you may have specified the  concept you're after perfectly well, but it's not clear exactly  what falls into it.  And what doesn't so tall is a vague concept because  there's no dividing line of, I don't know, 1.7 metres  or something, where we can say everyone who is above  that is tall, and everyone of that height or below  is not tall.  Uh, it's a vague concept.  The border is fuzzy, uh, so it can be difficult  to tell when exactly someone meets the criterion.  Uh, and the same is true of lots and lots  of other, uh, adjectives like fast performant.  Efficiently scalable, user friendly, secure.  All of those are vague.  Uh, sometimes they're ambiguous as well.  But, um, even when they're not ambiguous so efficiently, what  does that mean?  Efficient in terms of speed or efficient in terms of  storage.  Uh, even once you've narrowed that down, it's still gonna  be vague because you haven't specified are an exact border.  And the last issue is incompleteness.  So here we've got a user may specify a normal  or emergency mode when requesting system shutdown in normal mode,  pending operations should be logged in the system shutdown within  two minutes.  So that is obviously incomplete.  Ah, cos it said what what happens in normal mode?  But we've got emergency mode and it doesn't cover that.  So that's, uh, an easy one to spot.  But, uh, obviously, when you've got many more requirements and  the incompleteness is sort of split across several of them.  It can be much harder.  So those are the Those are the main sorts of  problem with requirements that formal methods are likely to help  with.  Um, there's lots of other ways that requirements can be  bad, so they can be just in bad English.  They can be overly long and complex.  Uh, they can have mixed levels of abstraction, undefined jargon,  terms.  Uh, they can be bad in that you might have  a requirement or a specification that specifies implementation.  Uh, they" metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="we display?  Sorry, it has to be the, uh, the identity, because  why would we be displaying the password on the screen?  But, um uh, As it stands, it's stands.  It's ambiguous.  Uh, should is also ambiguous.  Um is not necessarily clear whether that means the system  must do X or that this is AAA good to  have requirement.  That would be good if the system does X, but  it's acceptable if it doesn't.  And there's a whole bunch of other terms that, um  are ambiguous because they have more than one meaning.  Sometimes they've just got a technical and a non-technical meaning.  Sometimes they've got a whole bunch of non of technical  meanings.  So reliable, robust compos category failure, orthogonal, backend, coln platform  entropy.  Uh, nearly all of those have at least three or  four possible meanings.  So ambiguity is very easy to, uh, accidentally incorporate into  your requirements.  So separate.  So ambiguity is where something could mean two or more  distinct things.  Uh, vagueness is a different problem.  Uh, vagueness uh, is where you may have specified the  concept you're after perfectly well, but it's not clear exactly  what falls into it.  And what doesn't so tall is a vague concept because  there's no dividing line of, I don't know, 1.7 metres  or something, where we can say everyone who is above  that is tall, and everyone of that height or below  is not tall.  Uh, it's a vague concept.  The border is fuzzy, uh, so it can be difficult  to tell when exactly someone meets the criterion.  Uh, and the same is true of lots and lots  of other, uh, adjectives like fast performant.  Efficiently scalable, user friendly, secure.  All of those are vague.  Uh, sometimes they're ambiguous as well.  But, um, even when they're not ambiguous so efficiently, what  does that mean?  Efficient in terms of speed or efficient in terms of  storage.  Uh, even once you've narrowed that down, it's still gonna  be vague because you haven't specified are an exact border.  And the last issue is incompleteness.  So here we've got a user may specify a normal  or emergency mode when requesting system shutdown in normal mode,  pending operations should be logged in the system shutdown within  two minutes.  So that is obviously incomplete.  Ah, cos it said what what happens in normal mode?  But we've got emergency mode and it doesn't cover that.  So that's, uh, an easy one to spot.  But, uh, obviously, when you've got many more requirements and  the incompleteness is sort of split across several of them.  It can be much harder.  So those are the Those are the main sorts of  problem with requirements that formal methods are likely to help  with.  Um, there's lots of other ways that requirements can be  bad, so they can be just in bad English.  They can be overly long and complex.  Uh, they can have mixed levels of abstraction, undefined jargon,  terms.  Uh, they can be bad in that you might have  a requirement or a specification that specifies implementation.  Uh, they might overspecify something they might just not meet  the business needs.  So those we can't really do anything about with formal  methods There's other techniques for, uh, avoiding those, But, um,  the ambiguity, vagueness, contradiction and potentially some of the completeness  formal methods can help us with, uh and sometimes, uh,  just the process of trying to formalise something can reveal  problems with it.  Uh, I mean, you may have found that with with  programming that uh uh you may think you've got a  reasonable idea of how to implement something and the process  of writing it, uh actually reveals, you know, issues or  ambiguities with the problem.  OK, so in our formal specifications.  Uh, they usually have some sort of meaning defined in  terms of mathematics.  Uh, there's lots of different, uh, sorts of are formal  specification languages.  So things that we use to describe properties of systems,  lots of different sorts of languages and tools.  Uh, some of them are special purpose and fairly small  in scope.  Some are more general.  So a few of the smaller and more specific ones  someone sort of seems to be talking or mumbling quite  loudly, and it's a bit distracting.  If they could stop it, that would be nice.  Um, so, uh, some of the small and specific ones  we've seen our state charts.  We looked at that when we were looking at, um,  graph coverage, uh, b N f.  So we've seen B N F.  That lets us exactly specify, uh, what's called a context  free language.  Uh, regular expressions.  Uh, they So technically, the the maths form of regular  expressions, uh, defines a a subset of what B n  f does.  So they're a way of exactly specifying, uh, an even  simpler set of languages than the ones we've seen.  Uh, in practise.  Uh, most languages include something called regular expressions or they'll  call them Xes.  So python and Java both do both do, uh, those  are not the same as the math version.  They're actually a lot more powerful.  Uh, so all of those count as sorts of specification  language.  Uh, and, uh, pi calculus is another, uh, is used  to represent concurrent systems, so those are a small domain  specific ones.  Uh, you can also have very general specification languages, which  are designed to let you model almost anything you would  like or can think of.  So one of them is, uh, Z notation, which I  have seen used.  But I was surprised because, uh, it was developed in  the seventies, and, uh, it's not much used because I  don't think there's many tools that, actually, uh, will check  it for you, so it doesn't have very good tools  to go with it.  Uh, there's another one called t l a temporal logic  of actions which is very well suited for writing, uh,  specifications of, uh, concurrent and distributed systems.  So if you're worried about whether a system can, uh  uh so simple programmes um, which only have one thread  are usually fairly easy to reason about?  Once you've got something that, um, runs in multiple threads  or on multiple computers at once.  Uh, even a simple thing.  Like, um uh, something like Dropbox where you've got the  ability to sync between two computers as soon as you've  got, uh, two separate things that it becomes quite tricky  to, uh, reason about all the possible cases that that  can occur.  Uh, and, uh, a is very good at, uh, letting  you model those, uh, the specification language we'll be looking  at, uh is called alloy.  So it looks a bit like, uh, Java.  It has the advantage that, um, it's still being developed  today.  So new versions coming out, it has tools that go  with it so you can automatically check whether your specifications  have been written properly and you can check properties you  think should hold about them.  Uh, it's a bit influenced by Z, uh, and we'll  look at that in the last couple of lectures.  Uh, so for any formal method, uh, it can be  useful to think about where it fits into the scheme  of things.  So there will be some class of things that it  can be applied to, so b N f what does  it apply to?  It applies to grammars.  Uh, we can use those to pause things or generate  things.  Uh, t l a useful for concurrent systems.  So there'll be something it applies to fairly general or  fairly specific.  And there'll be some sort of system property that can  be used to specify or verify.  So, for B n f, it might be what commands  are accepted by our programme might be the the thing  we're specifying, Uh, and there's other sorts of properties that,  um ah, you your formal method won't apply to, so  it could be used to specify some sort of functional  requirement.  Um, so commands accepted would be functional.  Uh, it might be used to specify some sorts of  nonfunctional requirements.  So you can specify how fast something is supposed to  run or something about, um, say information and where it  can, uh, say you're trying to model a system that  can handle classified information.  Uh, you might mathematically model different levels of security.  So you've got sort of things like restricted confidential secret  top secret, uh, and properties about what systems that or  people can access those, uh, protocols like HTTP.  Um, all of those sorts of things are things we  can mathematically specify.  Uh, for any formal method, there is usually some sort  of syntax you use.  So some, uh, for B N f.  It is, well, B n f.  So there's some sort of rules about what makes up  a a proper B n f grammar and what doesn't?  Uh, there's some sort of semantics.  So what it means, uh, and often there's what we  call rules of inference, uh, techniques for, uh, given some  specification deriving some sort of useful information from it, Uh,  a few other ways we can classify formal methods, uh,  by how formal they are, Uh, how automatic they are.  So, um, I said that Z notation doesn't have very  good tooling.  It's very manual.  It lets you specify something, but, uh, when it was  developed in the seventies, there weren't really any, uh, tools  to go with it.  It was just something done by people on paper.  Uh, whereas these days in general, if we've got a  formal method, we expect it to be either, uh, completely  automatic or something That, uh, is partly automated.  Uh, and with hints from a user, uh, it can  be, uh, it can, uh, complete whatever task it's supposed  to do.  Uh, we can look at what properties.  We're We're verifying, uh, and whether there's just one property  or a lot.  Uh, we've seen we can look at what sort of  thing this applies to this technique.  Uh, so does it apply to hardware or software?  So we are gonna look at software, but there's also  formal methods for verifying things like circuit design and hardware.  Uh, you can look at does it apply to the  sorts of programmes you mostly will write at university?  So things that terminate a programme starts Does something finishes  or does it apply to what are called reactive systems?  So reactive systems are things.  Uh, so for a for a terminating programme," metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="applied to, so b N f what does  it apply to?  It applies to grammars.  Uh, we can use those to pause things or generate  things.  Uh, t l a useful for concurrent systems.  So there'll be something it applies to fairly general or  fairly specific.  And there'll be some sort of system property that can  be used to specify or verify.  So, for B n f, it might be what commands  are accepted by our programme might be the the thing  we're specifying, Uh, and there's other sorts of properties that,  um ah, you your formal method won't apply to, so  it could be used to specify some sort of functional  requirement.  Um, so commands accepted would be functional.  Uh, it might be used to specify some sorts of  nonfunctional requirements.  So you can specify how fast something is supposed to  run or something about, um, say information and where it  can, uh, say you're trying to model a system that  can handle classified information.  Uh, you might mathematically model different levels of security.  So you've got sort of things like restricted confidential secret  top secret, uh, and properties about what systems that or  people can access those, uh, protocols like HTTP.  Um, all of those sorts of things are things we  can mathematically specify.  Uh, for any formal method, there is usually some sort  of syntax you use.  So some, uh, for B N f.  It is, well, B n f.  So there's some sort of rules about what makes up  a a proper B n f grammar and what doesn't?  Uh, there's some sort of semantics.  So what it means, uh, and often there's what we  call rules of inference, uh, techniques for, uh, given some  specification deriving some sort of useful information from it, Uh,  a few other ways we can classify formal methods, uh,  by how formal they are, Uh, how automatic they are.  So, um, I said that Z notation doesn't have very  good tooling.  It's very manual.  It lets you specify something, but, uh, when it was  developed in the seventies, there weren't really any, uh, tools  to go with it.  It was just something done by people on paper.  Uh, whereas these days in general, if we've got a  formal method, we expect it to be either, uh, completely  automatic or something That, uh, is partly automated.  Uh, and with hints from a user, uh, it can  be, uh, it can, uh, complete whatever task it's supposed  to do.  Uh, we can look at what properties.  We're We're verifying, uh, and whether there's just one property  or a lot.  Uh, we've seen we can look at what sort of  thing this applies to this technique.  Uh, so does it apply to hardware or software?  So we are gonna look at software, but there's also  formal methods for verifying things like circuit design and hardware.  Uh, you can look at does it apply to the  sorts of programmes you mostly will write at university?  So things that terminate a programme starts Does something finishes  or does it apply to what are called reactive systems?  So reactive systems are things.  Uh, so for a for a terminating programme, you often  want to prove, um if I get this stuff in,  uh, then I can prove that my programme, uh, I  can prove my programme is implemented correctly and takes this  input and gives this output.  Uh, but reactive systems don't do that, so things like  Web servers are actually designed to run forever.  So it's pointless to say Are they correct?  And that they give the right output?  Uh, what?  You often want to show is things like, um, uh,  they never get stuck.  So there's a few other sorts of domain of application,  Uh, and you can also categorise them on, uh, when  they're applied.  So are they something you do early in development or  later?  Early is usual.  Usually better.  Uh, but sometimes you just don't have the techniques or  technology to, uh, to do them earlier.  Uh, it does happen.  Sometimes you have, uh, your system comes first, and then  you get the verification.  So that is often true for programming languages.  Very few people come up with a formal specification for  their languages from the start.  Uh, I mean, Java.  Java actually has a specification.  So it's, um it's got a lot more than many  languages do.  Uh, but when it was released in 1995 it turned  out that, um, there were contradictions in the Java specification.  So it had what's called an unsound type system, uh,  happened to another language called E f l as well.  So, uh, so on the one hand, uh, they didn't  apply formal methods to these.  And, um, it turned out that there were, uh, contradictory  aspects or unsound aspects, uh, of these languages, which is  bad, but, uh, on the other hand, um, they, uh,  writing a language is a a lot of work, and,  um, you might not necessarily want to hold it up.  Uh, just so that you can do a formal proof  that it sound.  So, uh, Java came out.  Uh, at least it was released.  Alright, so we've seen B n f.  We'll look at another, uh, example.  So I said once something is common, enough people tend  not to think of it as being a formal method  anymore.  They just sort of think of it as a a  normal part of programming.  Uh, and, uh, some of the more, uh, advanced or  interesting type systems are sort of on the threshold.  They're, um they're starting to become common in languages, but  they haven't really filtered through to everywhere.  So something like, um uh, some things are very, very  basic.  Something like enum classes.  So enum, uh, I don't think Java originally had them.  Python kind of has a version.  Now, um, the language is that pioneered, uh, good Enon  programming, uh, were, uh, things like m l and has,  and it's sort of starting to percolate into other languages  like, uh, typescript and rust.  And eventually, uh, eventually.  Java and Python had OMs, so you tend to get  techniques that start in a few more complicated languages.  And as it's realised that they're useful, they, uh, end  up in others.  Uh, some are still very uncommon.  So there's, um, a technique that uses, uh, called tinting,  uh, that you can use to check, uh, whether what's  in a variable is, uh, unsanitized or sanitised.  So it's handy for Web pages.  Uh, you've got something from the user.  Is it safe to display on a webpage, given that  it might contain malicious code?  When you get something from a user, you normally consider  it unsanitized.  And until it's been sanitised, it's not safe to to  output anywhere.  So that is actually a very useful technique.  But it as yet hasn't filtered through to languages like  Java or Python yet.  Um, so looking at OMs, uh, a very common poor  coding practise in uh, languages like Java and python is  to write programmes that are stringy typed.  It's called so where you're representing stuff as strings, which  you could have used the type system to help you  with.  Uh so for instance, you could have specified something as  an enum.  So let's suppose you've got a flight type, Uh, and  you need to store a flight type in a class  and pass it around.  Uh, you could store that as a string.  Uh, that would usually be bad strings if you if  something is a string, All you really know is that  it's a string.  Uh, and it also lets you do a whole lot  of operations on strings like, um, say, I don't know,  capitalising it or un capitalising it, which don't actually make  any sense for a flight type.  Really?  If you've got a bit of data in a programme,  you should be allowed to do exactly what's sensible and  no more.  Uh, and you shouldn't be able to say concatenate a  flight type with another string.  So better than that in Java at least, is to  use an enum and python has some sort of equivalent.  So, um, good programmers avoid stringy type programmes.  They use, um, proper types, but often they still use  numbers.  So if you've got an in it's not, it's almost  as bad as a string.  An in kind of means nothing.  It's just a It's just a number, Uh, or a  double.  Uh, actually, what you have in programmes is hardly ever  an inn.  It almost it almost always means something.  So it's velocity or body mass index or weight or  something.  And it doesn't make any sense to have that as  an inch that you could just add to other INTs.  Uh, and that can very easily lead to problems.  So I think, uh, one of the other NASA, uh,  rocket explosions.  Uh, besides the the challenger?  Uh, no.  Besides, the rover one I mentioned, uh, was due to  an inch being interpreted by one bit of the programme  as, uh, being in one sort of unit.  Uh, and another part of a programme is another.  So using just plain inch or doubles is almost as  bad as using strings.  Uh, what you really want instead is to be able  to tag agent with what it means or represents.  So, in high school, you would have seen that, um  uh, in science classes, physics and chemistry, you don't work  with plain numbers.  You always have a a unit to go with them,  or sometimes you will have, uh, ratios or proportions, which  are unit less.  And you've got rules about how those work.  So you can add two things with the same unit,  so it makes sense to add velocity to velocity.  Uh, and you can multiply or divide different things so  you can divide velocity by seconds.  Uh, but, um, uh, yeah, you can't add incompatible things.  Um, so in most programming languages, people just use fluting  point or INTs for everything.  For everything.  Uh, some languages actually have dimensionality and unit analysis built  into the language.  Uh, so you can you can multiply, uh, two sort  of tagged INTs, and it will keep track of what  that represents.  So if you have a length and another length and  you multiply them, you now have area, and it stops  you from performing nonsensical calculations.  Uh, and even in languages, which you don't have that  full dimensionality checking, uh, you can often specify that you  want just some subset of what, uh, the properties of  a double are.  So let's say we want to represent speed or velocity  as a double.  Um, you can in some languages.  So has is an example.  You can kind of" metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="that would usually be bad strings if you if  something is a string, All you really know is that  it's a string.  Uh, and it also lets you do a whole lot  of operations on strings like, um, say, I don't know,  capitalising it or un capitalising it, which don't actually make  any sense for a flight type.  Really?  If you've got a bit of data in a programme,  you should be allowed to do exactly what's sensible and  no more.  Uh, and you shouldn't be able to say concatenate a  flight type with another string.  So better than that in Java at least, is to  use an enum and python has some sort of equivalent.  So, um, good programmers avoid stringy type programmes.  They use, um, proper types, but often they still use  numbers.  So if you've got an in it's not, it's almost  as bad as a string.  An in kind of means nothing.  It's just a It's just a number, Uh, or a  double.  Uh, actually, what you have in programmes is hardly ever  an inn.  It almost it almost always means something.  So it's velocity or body mass index or weight or  something.  And it doesn't make any sense to have that as  an inch that you could just add to other INTs.  Uh, and that can very easily lead to problems.  So I think, uh, one of the other NASA, uh,  rocket explosions.  Uh, besides the the challenger?  Uh, no.  Besides, the rover one I mentioned, uh, was due to  an inch being interpreted by one bit of the programme  as, uh, being in one sort of unit.  Uh, and another part of a programme is another.  So using just plain inch or doubles is almost as  bad as using strings.  Uh, what you really want instead is to be able  to tag agent with what it means or represents.  So, in high school, you would have seen that, um  uh, in science classes, physics and chemistry, you don't work  with plain numbers.  You always have a a unit to go with them,  or sometimes you will have, uh, ratios or proportions, which  are unit less.  And you've got rules about how those work.  So you can add two things with the same unit,  so it makes sense to add velocity to velocity.  Uh, and you can multiply or divide different things so  you can divide velocity by seconds.  Uh, but, um, uh, yeah, you can't add incompatible things.  Um, so in most programming languages, people just use fluting  point or INTs for everything.  For everything.  Uh, some languages actually have dimensionality and unit analysis built  into the language.  Uh, so you can you can multiply, uh, two sort  of tagged INTs, and it will keep track of what  that represents.  So if you have a length and another length and  you multiply them, you now have area, and it stops  you from performing nonsensical calculations.  Uh, and even in languages, which you don't have that  full dimensionality checking, uh, you can often specify that you  want just some subset of what, uh, the properties of  a double are.  So let's say we want to represent speed or velocity  as a double.  Um, you can in some languages.  So has is an example.  You can kind of wrap that up in a type  so that you can't accidentally add it to, um, uh,  other other doubles, you'd have to specifically convert it.  And you can say I want to have these these  properties of a double.  Um, I'll I'll inherit or accept these.  So I want people to be able to, uh, uh,  accept it from the user.  The user should be able to type sort of 3.2  in a string, and I can interpret that I wanna  be able to show it like a double.  Uh, I want it to be able to add and  multiply with other things of the same sort.  Uh, I and I wanna be able to say two  of them are equal or one is less than the  other.  So you've got your your very good languages with full  dimension checking.  You've got ones that at least let you pick out  exactly what aspects of a number you want here and  stop you being careless.  And then you've got things like, uh, Java and python,  which provide no safety at all.  So, uh, dimensionality checking and, uh, painting are things that  haven't yet filtered through to most of the programming world.  All right, so it is 4.  12.  let's just have a very short five minute break.  Uh, we'll be back at, uh, 17 past, uh, and  if there's any project, queries or things that you want  to ask, then, um, Yep.  Bear those in mind, and I'll, uh, talk about them  after the break.  OK?  Mhm.  Did anyone have mood go down on them like, have  moole, uh, give server areas today?  OK, just about 2.  30 or so.  I think I saw, uh, giving, uh, database errors and  not responding.  There you go.  I take a picture, know, really old girl in my  Yeah, start film.  You Where that Mm.  OK, well, let's move on to the next topic.  So, still looking at, um, formal methods?  Uh, and the particular sort of formal method we're looking  at is, uh, programme verification.  So this is, uh, verifying that a programme meets, uh,  at least, uh, some of it's specific.  Yeah, Yeah.  Uh, yeah.  Can you?  Yeah, sure.  I mean, I'd email, but yeah, there's no Internet access.  Access.  Um, where was I?  OK, Daphne, right?  Uh, yeah.  Verification is showing that, um uh, at least most of  the the, uh, portions of the programme are verifiably correct.  You can prove that, um uh, for each function.  If the preconditions are satisfied, then the post conditions will  be satisfied.  Uh, it won't be able to prove, uh, nonfunctional bits  of the specifications.  So you can't prove you definitely to prove that, Um  uh, say your your tree map implementation takes log in  time.  Uh, but you can prove most of the other sorts  of precondition and post condition we've seen.  So programme Veri verification is proving that a programme satisfies  a formal specification of its behaviour.  And you do it because you want to be absolutely  sure that it meets some or all of those specifications.  Um, it's usually not so well, people don't do it  for all programmes because it does take, um, extra time  and effort and expertise.  Uh, Daphne is one of the easier languages to do  formal verification in.  So, um, some formal verification that's been done in the  past, Uh, one example was the, uh, the cell e  l micro kernel system.  Uh, that took many tens of thousands of person hours,  uh, of manual work to formally verify, um, the amount  of time and effort that's required has reduced a lot.  So definitely let's us verify that our specifications that our  programme meets the specifications.  Uh, it doesn't guarantee that the specifications were good or  sensible ones.  Um, we don't formally verify all programmes because for some  programmes, uh, there's just no, Well, there's no current tools  for doing so.  So, uh, things languages that are not statically type checked.  So things like, um Python and Java script, uh are  very, very difficult to automatically or partially automatically verify.  Uh, they tend not to have many tools for doing  so.  All of the the tools for verification, uh, mostly university  research projects, uh, things like Java.  There are some tools.  They take a fair amount of effort.  Uh, but, uh, but they exist.  And, uh, definitely, as far as I'm aware, is the  only language where the tools are are built into the  language.  So we don't verify all programmes because sometimes for some  languages, there's just no easy way of doing so.  So, uh, how do we verify something?  So proofs of programme correctness, uh, use techniques from formal  logic, uh, to prove that if the starting state satisfies  particular properties.  Then the in-state satisfies some other properties.  Uh, so this is what we've seen already when we  looked at preconditions and post conditions.  So preconditions are the things that have to hold at  the start of a bit of code.  And post conditions are the things that should hold after  the code.  Um, so even in languages that don't have verification built  in, we've seen that it's good practise to document what  the preconditions and preconditions are, uh, and that they act  as a sort of a contract between the developer of  the method in the caller.  So if the preconditions are satisfied by the caller, then  the method promises that, um, uh, it will discharge its  obligations by making the post conditions true.  But if the preconditions aren't satisfied, the method doesn't promise  anything at all.  And we have undefined behaviour.  And we saw an example.  We looked at, um, arrays, binary search in Java, and  the method there says the array must be sorted.  And if it's not sorted, uh, who knows what you'll  end up with?  Uh, in some cases, you might accidentally get the right  answer.  So it's it is not true to say that um  if the array the array is not sorted, you will  get a wrong answer.  You might not.  You might be lucky you might accidentally get the right  answer.  Uh, it's just that, um there's no guarantee of what  you'll get.  The the person who wrote binary search makes no promises  whatsoever about what could happen.  Uh, so undefined behaviour is not the same thing as  an exception.  Uh, so Java has, uh, a bunch of exceptions that  it can throw those just a one sort of push  condition.  So we said in languages that are more expressive than  java, uh, you might have a return type that actually  encapsulates all of these.  So you might if you've got something that opens a  file, uh, you might have in a in a better  language, you might be able to say, this method opens  a file, and it returns.  Uh, a type that is either an open file or,  uh, it returns something.  It returned some sort of error message saying why it  couldn't open the file.  Uh, but, uh, Java instead, uh, is only easily able  to return one type of thing.  Uh, any other thing that you want to communicate to  the caller.  You sort of have to communicate with an exception.  So exceptions there, uh, they just almost another.  Another way of returning things.  So Daphne looks a bit like Java or C sharp.  Uh, and once you've written something in Daphne, uh, you  can compile it to, uh, c sharp or Java or  Java" metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="take a fair amount of effort.  Uh, but, uh, but they exist.  And, uh, definitely, as far as I'm aware, is the  only language where the tools are are built into the  language.  So we don't verify all programmes because sometimes for some  languages, there's just no easy way of doing so.  So, uh, how do we verify something?  So proofs of programme correctness, uh, use techniques from formal  logic, uh, to prove that if the starting state satisfies  particular properties.  Then the in-state satisfies some other properties.  Uh, so this is what we've seen already when we  looked at preconditions and post conditions.  So preconditions are the things that have to hold at  the start of a bit of code.  And post conditions are the things that should hold after  the code.  Um, so even in languages that don't have verification built  in, we've seen that it's good practise to document what  the preconditions and preconditions are, uh, and that they act  as a sort of a contract between the developer of  the method in the caller.  So if the preconditions are satisfied by the caller, then  the method promises that, um, uh, it will discharge its  obligations by making the post conditions true.  But if the preconditions aren't satisfied, the method doesn't promise  anything at all.  And we have undefined behaviour.  And we saw an example.  We looked at, um, arrays, binary search in Java, and  the method there says the array must be sorted.  And if it's not sorted, uh, who knows what you'll  end up with?  Uh, in some cases, you might accidentally get the right  answer.  So it's it is not true to say that um  if the array the array is not sorted, you will  get a wrong answer.  You might not.  You might be lucky you might accidentally get the right  answer.  Uh, it's just that, um there's no guarantee of what  you'll get.  The the person who wrote binary search makes no promises  whatsoever about what could happen.  Uh, so undefined behaviour is not the same thing as  an exception.  Uh, so Java has, uh, a bunch of exceptions that  it can throw those just a one sort of push  condition.  So we said in languages that are more expressive than  java, uh, you might have a return type that actually  encapsulates all of these.  So you might if you've got something that opens a  file, uh, you might have in a in a better  language, you might be able to say, this method opens  a file, and it returns.  Uh, a type that is either an open file or,  uh, it returns something.  It returned some sort of error message saying why it  couldn't open the file.  Uh, but, uh, Java instead, uh, is only easily able  to return one type of thing.  Uh, any other thing that you want to communicate to  the caller.  You sort of have to communicate with an exception.  So exceptions there, uh, they just almost another.  Another way of returning things.  So Daphne looks a bit like Java or C sharp.  Uh, and once you've written something in Daphne, uh, you  can compile it to, uh, c sharp or Java or  Java script, Or go and then compile those into, uh,  a, uh, a running a run executable.  Uh, this doesn't actually exist anymore.  I'll take this slide out.  So the, uh the only reliable way at the moment  of using Daphne online is to use git pod, which  we've used for some of the labs.  Uh, so I've created a a repository that lets you  use, uh, Daphne from the browser.  And we'll use that in, uh, in our next lab.  Uh, so following that link, we'll bring up uh uh,  Microsoft V s code.  Um, interface.  Uh, and you can then open up, uh, Daphne code  and have a look at what it looks like.  Uh, so here we've got a method Main print.  Hello, Daphne.  A search that 10 is less than two.  Uh, that programme actually won't compile.  So Daphne won't let you compile code, Uh, unless it  can prove that everything in it is true.  And here you've asserted something that isn't true.  You've asserted that 10 is less than two.  Uh, Python couldn't pick that up at compile time.  Java couldn't pick that up at compile time.  Uh, but Daphne actually knows enough about numbers that it  knows 10 is not less than two.  So it won't even let you compile this programme until  you've taken that asses out.  So it says a session might not hold.  So what does Daphne look like?  Um, so, like I said, not not completely dissimilar to  java?  Uh, a few differences.  So one is, uh, Java was written to look a  lot like C and C plus plus, uh, and it's  got, um, uh, the type before the, uh, before the,  uh, parameter n uh, most more recent languages, uh, actually  let you specify types like this, and Daphne is one  of them.  You have the parameter first, uh, then a colon.  And then you say what type it is, and that's  easier.  Easier to write pauses for.  It's also usually easier to easier to read in Java  and C plus plus you can have a very long  type that says something like, um, a ray list of  some, uh, a ray list of set of something else.  Uh, and the actual name of the parameter is almost  hidden.  Uh, whereas this style of doing things, you put the  name of the parameter first and then the type.  Um, other things are, uh you have a way of  specifying a name for the value that's returned, so that's  not usual.  But, um uh, Daphne does it because we want to  make assertions about what's returned.  Uh, so we'll wanna say, you know, if this is  true, the return value is always blah, whatever it may  be.  So, uh, otherwise, aside from that, and aside from the  fact that it doesn't, uh, force you to put, uh,  if statements in parentheses, it's pretty similar to Java and  Java script and a lot of, um, race languages like  that.  So we could write a method.  Uh, abs, uh, to get the absolute value of something,  uh, Daphne code tends to follow the convention from C  sharp that, um, method names taken up a case initial  letter.  Uh, so we could say if X is less than  zero return negated X otherwise, return X.  And that's our abs method.  So we can write that, and it will compile and  run with no issues.  Uh, because we haven't yet put any preconditions or post  conditions in there.  So, uh, for that return value, I said we're able  to give the return value a name and talk about  it in, uh uh, uh.  Talk about it in post conditions and preconditions.  Uh, we've called it.  Why, uh, one common convention you might see is that,  um uh, if you've got an input parameter called X,  uh, often you'll call the return value X prime, so  x with an apostrophe after it.  So, in maths, the prime symbol usually means, uh, uh,  It's used for things like, um so x prime often  means, um X but at a later time, or, uh,  X with something different about it.  So, uh, in Daphne, we can include apostrophes in our  variable names, so that's quite a common one.  All right, so what do our preconditions and post conditions  look like?  Uh, so we can add preconditions, Uh, with the word  requires and post conditions with the word ensures.  So for an absolute value method that always has to  return a non negative number.  Uh, so let's put our push condition in.  We can say, uh, this always returns, Uh, a result  greater than or equal to zero.  So we can refer to the return value because we  gave it a name.  Uh, and that should compile, as is.  So Daphne doesn't actually need any help from us here.  Uh, it knows enough about maths and arithmetic that it  can work out that this is now true.  All of the, uh, all of the post conditions are  satisfied because it knows that, um, numbers can be positive  or negative.  If the number is negative, Uh, we return a positive.  If the number was non negative, then we still return  it.  So we've got a zero or a positive, therefore, that  post condition is always true.  So we don't have to include any, but there's no  point using Daphne.  Uh, without it, that's its main advantage as a language.  So, um, Daphne not only will verify that the post  conditions are true, uh, it won't let you call a  method.  Uh, unless you've satisfied the preconditions.  Uh, so here there are none So this compiles.  OK, uh, we've just said there's just a post condition  that always has to be non negative.  Uh, main calls, abs.  No issues.  Uh, if we said, um, you're only allowed, so this  would be a silly requirement, but suppose we said, um,  uh, a s can only take positive, uh, positive numbers.  Uh, then our programme would no longer compile.  Uh, Daphne would see that we're passing a negative number  in, and it wouldn't even let us call the ebbs  method.  So if we try that in, uh, git pod, uh,  we'll see that we get a compile error.  Uh, and it tells us, uh, a precondition for this  call might not hold, uh, down there where we've called  ABS, and it will actually show us the exact precondition.  So as, uh, formal methods go, Daphne is fairly user  friendly.  Uh, so we're allowed to add as many insurers, uh,  specifications as we want.  Uh, we can use the usual logic connective.  So we can use, uh, and and or, uh, in  general, uh, good style is, uh you should try and  think about, um, sort of distinct properties, uh, and give  each property its own insurers clause.  Uh, and if we don't put any insurers specification in,  then, uh, it's always gonna verify.  So, yeah, the whole point of writing in Daphne is  that we should be able to add, um, add these  insurers clauses and say these are the things that we  can prove for certain will be true.  Uh, so here's another one that compiles with no issues.  Uh, it's, uh it says it requires X to be  greater than zero.  Uh, and it ensures that the return value is great  and zero, and it returns, uh, one more than the  input thing.  So I assume from that I can't remember what sort  of in type Daphne has.  But, uh uh, it obviously doesn't have wrap around, cos  um, it definitely promises that this, uh, always returns a  positive.  Uh, then we can never have, uh, a y being  negative.  So I assume that, um, either Daphne has infinite precision  in I think that's what it does.  Uh, but yeah, it" metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="negative number.  Uh, so let's put our push condition in.  We can say, uh, this always returns, Uh, a result  greater than or equal to zero.  So we can refer to the return value because we  gave it a name.  Uh, and that should compile, as is.  So Daphne doesn't actually need any help from us here.  Uh, it knows enough about maths and arithmetic that it  can work out that this is now true.  All of the, uh, all of the post conditions are  satisfied because it knows that, um, numbers can be positive  or negative.  If the number is negative, Uh, we return a positive.  If the number was non negative, then we still return  it.  So we've got a zero or a positive, therefore, that  post condition is always true.  So we don't have to include any, but there's no  point using Daphne.  Uh, without it, that's its main advantage as a language.  So, um, Daphne not only will verify that the post  conditions are true, uh, it won't let you call a  method.  Uh, unless you've satisfied the preconditions.  Uh, so here there are none So this compiles.  OK, uh, we've just said there's just a post condition  that always has to be non negative.  Uh, main calls, abs.  No issues.  Uh, if we said, um, you're only allowed, so this  would be a silly requirement, but suppose we said, um,  uh, a s can only take positive, uh, positive numbers.  Uh, then our programme would no longer compile.  Uh, Daphne would see that we're passing a negative number  in, and it wouldn't even let us call the ebbs  method.  So if we try that in, uh, git pod, uh,  we'll see that we get a compile error.  Uh, and it tells us, uh, a precondition for this  call might not hold, uh, down there where we've called  ABS, and it will actually show us the exact precondition.  So as, uh, formal methods go, Daphne is fairly user  friendly.  Uh, so we're allowed to add as many insurers, uh,  specifications as we want.  Uh, we can use the usual logic connective.  So we can use, uh, and and or, uh, in  general, uh, good style is, uh you should try and  think about, um, sort of distinct properties, uh, and give  each property its own insurers clause.  Uh, and if we don't put any insurers specification in,  then, uh, it's always gonna verify.  So, yeah, the whole point of writing in Daphne is  that we should be able to add, um, add these  insurers clauses and say these are the things that we  can prove for certain will be true.  Uh, so here's another one that compiles with no issues.  Uh, it's, uh it says it requires X to be  greater than zero.  Uh, and it ensures that the return value is great  and zero, and it returns, uh, one more than the  input thing.  So I assume from that I can't remember what sort  of in type Daphne has.  But, uh uh, it obviously doesn't have wrap around, cos  um, it definitely promises that this, uh, always returns a  positive.  Uh, then we can never have, uh, a y being  negative.  So I assume that, um, either Daphne has infinite precision  in I think that's what it does.  Uh, but yeah, it promises.  It will always be able to add one to whatever  and we gave it.  So anyone calling that has to satisfy the preconditions.  Uh, and if we're writing it, then we're allowed to  assume that the preconditions already hold or we wouldn't be  here.  Uh, and in the middle of our code, uh, we're  allowed to write assess.  And these are much like assertions in other languages.  They they assert that something is true at that point  in the code.  Uh, the difference is that in most languages, assertions only  get checked at run time.  Uh, so you add an ass session and you run  your programme, and if the asses fails, then you look  at the the error messages that turned up.  Uh, Daphne, uh, it's a way of working out what's  true at particular points in the programme at compile time.  So, uh, for most programmes, compiling is easy.  And then you have lots of issues trying to work  out what's gone wrong at run time and definitely compiling  can be quite tricky.  Uh, and assertions are almost like a sort of a  print that you can put in the middle of a  programme that tell you what's going on at compile time.  So, uh, assertions, uh, they can include numbers, any sort  of variable you like.  They don't have to mention, uh, any of the parameters  or variables in your, uh, in your method, But usually  they're going to be more useful if they do.  So you can put assertions like that.  There definitely will check it and definitely won't let you  compile that method at all.  So here, uh, we've got our abs function.  Uh, we know that it always returns a non negative.  Uh, so if we just wanted to sort of check  that something is true, we could add an assert here.  Uh, so, like I said, it's almost a bit like  a a print or print F statement for debugging compilation.  We pop in our assert, uh, and, uh, if there's  anything wrong with our assumptions, uh, Daphne will tell us  that we pop here V is greater than zero, uh,  greater than or equal to zero.  And that should pass.  Uh, so we know that it's true.  All right, So if you get a verification error, there  are a couple of reasons why that might be so.  First of all, you might have actually, uh, made a  mistake.  So your code might be wrong in some way, but  the other is your code might be right, but definitely  isn't quite clever enough to prove, uh, on its own  that the assertions or whatever you've got hold.  So I said it is quite smart.  So the Daphne verifier it knows about positive and negative  numbers.  It can, uh, reason about, uh, a lot of basic  arithmetic.  Uh, but it can't do everything.  So, uh, sometimes the compiler needs a bit of assistance.  Uh, in particular, uh, loops are something that Daphne can't  work out on its own.  So, uh, when the, uh, compiler sees a method containing  a loop, uh, in general, uh, you can't tell in  advance how many times the loop is going to be  executed, and the verifier sort of works by, um, going  through all of the paths through a programme and proving  that everything holds true in all of them.  So, for instance, when you've got an if statement, uh,  Daphne kind of splits that up and says, All right,  we have to check that the insurers is true if  we go down this path and we have to check  that it's true if we go down this path, But  when it encounters a loop, uh, it's sort of like  there are infinite paths that could happen, uh, and so  it can't check them all.  So the solution here is to make use of another  sort of invariant.  Uh, it's called a loop in variant.  Ah.  So these are things that hold true.  You can sort of think of them as things that  are that are true outside of a loop.  So if you've got a loop, Uh, do we have  one?  Where's our loop?  Here we go.  Here's a wild loop.  Um, so a loop invariant is true just before the  block and just after the block inside the block, uh,  we're allowed to temporarily break it, so it's a bit  like, um, class invariants for class invariants.  We said, um uh, if you're writing a method so  the constructor has to establish the invariants, so they must  be true after the constructor runs.  Whenever you're writing a method, uh, you can assume the  class invariants hold before the method starts, and you have  to make sure they're still true after the method ends.  Uh, and so loop invariants are doing something similar.  When you're writing the body of a loop, you're allowed  to assume that the invariants are true just before the  block starts and you have to make sure that they're  still true after the block finishes.  So there are expressions that hold true before entering the  loop and after every execution of the loop body, Uh,  but in the middle of the loop, just like class  and variants, you're allowed to temporarily break them.  Uh, because you're always gonna have to, you know, alter  variable values to actually do anything as long as you  make sure they're in place again by the end.  Uh, so your loop invariants, uh, you put them just  before the loop block.  So here we've got, uh, as an invariant.  So we've said I is zero.  While I is less than n uh, increment.  I, uh, one thing we know about I is, uh,  it's always gonna be, uh, or less than or equal  to Sorry, uh, zero is gonna be less than or  equal to I because we know that it started off  at zero.  We only ever increment it.  Uh, therefore, that invariant is always gonna be true, uh,  around the body of the loop.  So the verifier goes through.  It says, um, is that invariant true before the loop  starts?  So it checks.  It says, um, I is 00 is less than or  equal to zero.  That's fine.  Then it checks to make sure that, um if the  invariant was true before the loop, it'll still be true  afterwards.  So it says that I is incremented by one.  And it knows that, uh, if you increment it by  10 will still be less than or equal to I,  uh, and it then includes, so therefore, the invariants gotta  be true afterwards.  So it was true before we didn't do anything to  break it.  It's gotta be true afterwards.  Therefore, it's safe to have that as a loop invariant.  Uh and that's kind of a very simple example.  But you can build up from that.  So, uh, imagine that, um, you were working in a  language that didn't have integer multiplication.  Uh, you only have addition and subtraction.  Uh, you can write a loop and effectively.  Of course.  This is what, um, processes do so multiplication.  Uh, in AC.  P u is just done by repeated edition.  Uh, so at a very low level, someone has to  implement the circuit.  Uh, that does this and prove that it works.  So to implement multiplication, we could say, Uh, let's have  a variable for our final result starts off at zero.  Uh, let's go through.  And, uh uh, keep detriment M.  And each time we do, we'll add n to total.  So we'll add in m times.  So while M is greater than zero, take one off  m and add another end to total.  Uh, and by the end of it total should equal  m times n so again, Still very basic.  But, um, this is kind of the next step up  for" metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="has to establish the invariants, so they must  be true after the constructor runs.  Whenever you're writing a method, uh, you can assume the  class invariants hold before the method starts, and you have  to make sure they're still true after the method ends.  Uh, and so loop invariants are doing something similar.  When you're writing the body of a loop, you're allowed  to assume that the invariants are true just before the  block starts and you have to make sure that they're  still true after the block finishes.  So there are expressions that hold true before entering the  loop and after every execution of the loop body, Uh,  but in the middle of the loop, just like class  and variants, you're allowed to temporarily break them.  Uh, because you're always gonna have to, you know, alter  variable values to actually do anything as long as you  make sure they're in place again by the end.  Uh, so your loop invariants, uh, you put them just  before the loop block.  So here we've got, uh, as an invariant.  So we've said I is zero.  While I is less than n uh, increment.  I, uh, one thing we know about I is, uh,  it's always gonna be, uh, or less than or equal  to Sorry, uh, zero is gonna be less than or  equal to I because we know that it started off  at zero.  We only ever increment it.  Uh, therefore, that invariant is always gonna be true, uh,  around the body of the loop.  So the verifier goes through.  It says, um, is that invariant true before the loop  starts?  So it checks.  It says, um, I is 00 is less than or  equal to zero.  That's fine.  Then it checks to make sure that, um if the  invariant was true before the loop, it'll still be true  afterwards.  So it says that I is incremented by one.  And it knows that, uh, if you increment it by  10 will still be less than or equal to I,  uh, and it then includes, so therefore, the invariants gotta  be true afterwards.  So it was true before we didn't do anything to  break it.  It's gotta be true afterwards.  Therefore, it's safe to have that as a loop invariant.  Uh and that's kind of a very simple example.  But you can build up from that.  So, uh, imagine that, um, you were working in a  language that didn't have integer multiplication.  Uh, you only have addition and subtraction.  Uh, you can write a loop and effectively.  Of course.  This is what, um, processes do so multiplication.  Uh, in AC.  P u is just done by repeated edition.  Uh, so at a very low level, someone has to  implement the circuit.  Uh, that does this and prove that it works.  So to implement multiplication, we could say, Uh, let's have  a variable for our final result starts off at zero.  Uh, let's go through.  And, uh uh, keep detriment M.  And each time we do, we'll add n to total.  So we'll add in m times.  So while M is greater than zero, take one off  m and add another end to total.  Uh, and by the end of it total should equal  m times n so again, Still very basic.  But, um, this is kind of the next step up  for Daphne purposes.  Um, it's actually handy to, um, make copies of our  variables because we wanna, uh, easily talk about, um, what  m and m were at the start And, uh, what  values things hold in between.  So let's, uh, assign variables A and B, and we'll  keep decrementing a and adding B to the total.  Uh, and what we want to prove is that it  returns m times n so we'll add that as a  post condition.  And at that point, Daphne will, uh, the compilation will  fail.  Daphne can't prove that that's true on its own.  So, uh, things that we can do, um, we can  add loop invariants.  So, uh, an invariant here is that, um regardless of  what happens to the total and to a here, it's  always true that, um, a times B plus the total  should always equal m times n So we're kind of  always taking stuff off of a and it's getting added  to the total.  Uh, so at any one point, that should still hold.  Uh, and if that invariant is true, then that means  at the end of the loop.  So the loop says while A is greater than zero  keep doing this at the end of the loop.  We know the day is zero or we couldn't have  got out of the loop.  So if a is zero, it follows that, um uh,  a times B is zero, uh, and therefore it follows  that total equals m times n.  So we can put that in as an assertion after  the end of the loop.  So these loop in variants, they're kind of, um uh  they're a bit tricky to come up with, um, like  it's not well for me.  At least.  I don't think it's immediately obvious from looking at the  loop that that's the invariant that holds, uh, usually for  any loop uh, you've got things that are changing and  things that are staying the same.  And you sort of come up with something that, um,  uh you sort of look for things that kind of  counterbalance each other.  So you try and put the things that change together,  uh, and come up with some property that always stays  the same.  OK, so we put that in, um, and it won't  actually compile because, um, it keeps decrementing, uh, a so  a is just a copy of M and Daphne will  point out to us that if m is negative, uh,  then we can keep decrementing it, and we'll never hit  zero.  We'll just keep on going.  We'll get an infinite loop.  Uh, so we need to add in a precondition.  We can say this multiplication routine works.  Uh, as long as M and N are non negative  numbers, and once we add that precondition in, uh, Daphne  will now compile it.  So we've got enough hints about what the loop invariant  is what's true after the loop, and we've added in  a strong enough precondition, uh, that Daphne can now check  that all of those hold and our method works so  Like I said, this one is just sort of a  toy example, because in reality, definitely already does have multiplication.  But, um, uh, loops are obviously, uh, a fairly common  feature.  So at some point, uh, for any interesting, uh, programme  that you're gonna write, there's gonna be, uh, loops appearing  in it somewhere.  Uh, and so this is the sort of thing that  you need to do to get them to, uh, compile  correctly.  OK, so we are actually out of time.  Um, So I will finish that off next week.  Uh, in this week's lab, we will be, uh, uh,  using Daphne in git pod.  Um, and I'm going to try and add something, uh,  about mocks, uh, in the lab if I have time.  Um, otherwise, I may just add that as something to  do in, uh, week 12, when we don't actually have  a lab.  OK, thanks." metadata={}
 
 
