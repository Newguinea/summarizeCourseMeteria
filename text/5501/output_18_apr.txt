这是个课堂录音，你来说说老师说了什么
page_content="cool.  Mhm.  OK, so I'm gonna finish off the, uh, uh, material.  Hopefully on, uh, syntax based testing today, Um, admin stuff.  Thanks to everyone who have got their reviews of, uh,  long answer questions in so marks for, uh, all of  the test stuff should be out, uh, later this week.  So for the, um, the first part, the the marking  is as usual, Uh, no surprises there for the long  answer Question, Uh, assuming I think that the, uh, the  mark, uh, which is a weighted average of, uh Well,  it's an average of what, um, the reviewers gave you,  assuming I think that's correct.  Then I will let that stand.  Uh, if I think you have demonstrated amazingly poor judgement,  uh, in assessing others, then I will, um, make all  of your ratings weight.  Zero, uh, some people most people have done, I think  have done a pretty good job.  Uh, some people have decided, uh, everyone got full marks.  Uh, even for cases when they quite clearly hadn't.  So, um, if I if I see that there's cases  where people either can't understand or weren't inclined to actually  apply the the marking criteria, I'll just remove their, um,  uh, their mark as a as a waiting completely.  And if I think, uh, everyone has done an appalling  job on, uh, assessing your submission, then I will just,  um, uh, mark myself and give it away.  But I don't think I've spotted any cases of that  happening, so they should be out later in the week.  Uh, we've also got the project coming up.  Uh, that should Yeah, that's right.  Uh, so that's due week 11.  Uh, and I normally make it.  So there's so it's reasonably easy to do in about  three weeks, so I'll probably release it next week.  Um, or the week after, um, and that will have  a few worked questions.  A bit of coding to do.  Um, it shouldn't be.  So.  I I generally try and, um, work it so that,  um uh, as long as you can put in, um,  about equivalent to what you'd spend on lectures and tuts  um, so at least, uh, a few hours each week.  Then it's possible to get it done in, uh, three  or four weeks.  So, um, yeah, that's coming up.  So for today?  Ah, if any queries about, uh, the test or anything  coming up or no?  OK, um so I'll carry on with the, uh, the  syntax based testing.  So I said that, um this mostly comes up when  you're, um, working on, uh, larger programmes that have a  fairly complicated command structure.  So that's the the big use case where I, um,  have seen this sort of, um uh, testing style will  be most useful.  Uh, I mentioned that, uh, it also becomes relevant for  when you're If you're ever writing your own language, that's  a lot less common.  So not, uh, not quite so many people write their  own.  Uh, even if it's just a small, uh, programming language.  Not so many people do that.  Um but, um, plenty of cases of, uh, validation of  things.  So validation of forms or data formats?  Um, those sort of things are are cases where this  is useful as well.  Um, it comes up as being useful in mutation testing,  which will look at, uh, in the next topic.  Uh, and, uh, it is, uh, somewhat useful when you're  looking at fuzzing as well.  So we'll we'll look briefly at fuzzing.  That's a sort of a randomised testing.  Alright, So, um uh last week, I got to somewhere  around here in the slides.  Uh, and I was just talking about, um what usually  distinguishes syntax from Symantec.  So, um, these sort of, uh, testing practises are good  for when you're trying to test the sort of things  that can have syntax errors.  So we said things like, uh, malformed dates or emails  or, uh, uh, command line arguments to programmes, that sort  of thing.  Uh, there's no there's no hard and fast line between  what people might call syntax and what they might call  semantic.  So people people might have a different opinion to this.  But, uh, in general, uh, if something can be described  using the sort of grammar that we've covered in these  lectures, then we usually call it, uh, a syntactical rule.  So it's a syntax rule.  Uh, and if it can't be described in that way,  if it's too complicated, then it's a semantic rule.  Um, so for, uh, general information, um, for anyone who's  interested, uh, the the class of things we're looking at  here are called, uh, context free languages.  Uh, so they're context free because the rules describing them  are are pretty simple.  So we've said what they are.  You've got a grammar.  It consists of a bunch of rules.  We've laid out what the left hand side can look  like and what the right hand side can look like.  And on the left hand side, we have said there's  always just one thing.  One non terminal, uh, symbol.  And on the right hand side, there's a sequence of  terminals and non terminals possibly connected by things.  So, uh, it's the fact that there's only one thing  on the left that makes these, uh, a fairly sort  of simple class of grammar and makes them, uh, what  we call context free languages.  If you could have, uh, multiple things on the left  hand side terminals and non terminals, then you'd be saying,  um, this thing on the left expands to this thing  on the right, but only in some particular contexts.  So that would be a sort of a more complicated  situation, and we're not dealing with it.  So we're we're dealing with, um uh, fairly simple, uh,  fairly simple formats.  Uh, another thing that comes up is that, um, the  grammars that we've looked at are describing textual things.  So dates or emails or that sort of thing.  Uh, so a question might arise.  There's plenty of things, uh, in software development that we  look at that aren't text, so we'll often have things  in binary format.  Uh, do the, uh, do the ideas we look at  here apply to those?  Um, well, they do.  The ideas generally do.  So when we talk about what constitutes thorough testing and,  uh uh, what we might do when we want to,  uh, test something particularly thoroughly, Um, those things still apply.  Uh, but how you write a how you write a  specification for a binary format, uh, is a bit different,  so b n f So the formalism we've seen here,  where you've got the the double double colons on equals,  uh, it's good for describing text.  So it's good for describing programming languages, dates, emails, all  that sort of thing.  Uh, it's not so great.  It's not especially convenient for describing binary formats.  Um, so if people want to do that, they typically  use, uh, other formalism.  So one that might come up is something called a  s n 10.1 abstract syntax notation one.  Uh, so we're not gonna be using that, but, uh,  uh, if you are ever are having to write, uh,  specifications for binary file formats, Uh, it's a useful thing  to know.  Uh, the other thing you occasionally see so I'll just  actually I'll go.  You go.  The other sort of thing you might occasionally see is  people will come up with their own.  Uh, well, they'll they'll either diagram things for simple formats.  So here's someone trying to, uh, describe the format of,  um, uh, what's called the TCP header.  So it's how, uh, a lot of traffic is sent  over the Internet.  Um, it's a fairly simple format.  And so they've just said, um, uh, it consists of,  uh, a number of, um, a number of things which  fit into, uh, several bits.  And they have said how many bits each thing is  and where it's positioned.  So that's fairly simple, because it's, um, it's kind of  fixed.  Uh, things like JPEG files are more complicated.  So for those, uh, people often rely on, uh, sometimes,  yeah, sometimes written descriptions.  Sometimes they come up with their own, uh, their own  way of diagramming or describing things.  Uh, sometimes if they know about it, they'll use this,  Um, a s n one syntax.  Uh, so we know that we can use this for  text.  Uh, we know we can apply the general rules to  binary files.  Uh, but we might want to come up with, uh,  a different notation for describing those files.  Um, is there anything else that we can, uh, describe  with grammars?  Well, um, if you've got some sort of a text  or binary format, uh, and you're processing it with a  programme, then at some point, you're gonna be storing it  in data structures.  Uh, so it will be held in memory.  Um, and so you can use the same kind of  grammars to describe those data structures.  All right, so, um, where are we gonna get our  descriptions of the syntax from, uh, occasionally we'll actually, we  might actually get them in a B N f format.  Someone might might be, uh, nice enough to, uh, write  out a syntax for us.  Uh, other times, uh, we will probably have to, um,  interpret a specification ourselves to come up with the, uh  uh, the grammar.  Uh, so places we might look are right in the  source code of programmes.  Uh, in the, uh, design documents.  Um, there might be, uh, written specifications of file formats.  Uh, so we'll we'll construct our our grammar from those,  uh, and in general, we'll write tests that, uh, we  would like to think, uh, thorough in some way.  So we want them to try and cover the syntax.  Uh, and we'll also typically write tests.  Ah, that show that, um when someone breaks the format,  we get whatever results we were expecting.  So if we have got a, um, bunch of java  classes for, um, parsing JPEG files, um, then they'll usually  say something along the lines of, um, here's our, uh,  here's, uh, jpeg class.  There'll be a public constructor for it.  Uh, that might take a path to a file or,  um, a set of bits or something.  And the specification for that will usually say, um, if  this is a valid JPEG file, then the class will  get populated with it, and you can then manipulate it  or query it, uh, the way you want.  If it isn't, then we'll throw an exception.  So we wanna write tests for both cases.  We wanna we wanna know that when a JP is  valid, it does get passed thoroughly.  But we also want to know that, um, when it's  fed, uh, incorrect formats, uh, it'll do the right thing.  So whatever the specification is through an exception" metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="called the TCP header.  So it's how, uh, a lot of traffic is sent  over the Internet.  Um, it's a fairly simple format.  And so they've just said, um, uh, it consists of,  uh, a number of, um, a number of things which  fit into, uh, several bits.  And they have said how many bits each thing is  and where it's positioned.  So that's fairly simple, because it's, um, it's kind of  fixed.  Uh, things like JPEG files are more complicated.  So for those, uh, people often rely on, uh, sometimes,  yeah, sometimes written descriptions.  Sometimes they come up with their own, uh, their own  way of diagramming or describing things.  Uh, sometimes if they know about it, they'll use this,  Um, a s n one syntax.  Uh, so we know that we can use this for  text.  Uh, we know we can apply the general rules to  binary files.  Uh, but we might want to come up with, uh,  a different notation for describing those files.  Um, is there anything else that we can, uh, describe  with grammars?  Well, um, if you've got some sort of a text  or binary format, uh, and you're processing it with a  programme, then at some point, you're gonna be storing it  in data structures.  Uh, so it will be held in memory.  Um, and so you can use the same kind of  grammars to describe those data structures.  All right, so, um, where are we gonna get our  descriptions of the syntax from, uh, occasionally we'll actually, we  might actually get them in a B N f format.  Someone might might be, uh, nice enough to, uh, write  out a syntax for us.  Uh, other times, uh, we will probably have to, um,  interpret a specification ourselves to come up with the, uh  uh, the grammar.  Uh, so places we might look are right in the  source code of programmes.  Uh, in the, uh, design documents.  Um, there might be, uh, written specifications of file formats.  Uh, so we'll we'll construct our our grammar from those,  uh, and in general, we'll write tests that, uh, we  would like to think, uh, thorough in some way.  So we want them to try and cover the syntax.  Uh, and we'll also typically write tests.  Ah, that show that, um when someone breaks the format,  we get whatever results we were expecting.  So if we have got a, um, bunch of java  classes for, um, parsing JPEG files, um, then they'll usually  say something along the lines of, um, here's our, uh,  here's, uh, jpeg class.  There'll be a public constructor for it.  Uh, that might take a path to a file or,  um, a set of bits or something.  And the specification for that will usually say, um, if  this is a valid JPEG file, then the class will  get populated with it, and you can then manipulate it  or query it, uh, the way you want.  If it isn't, then we'll throw an exception.  So we wanna write tests for both cases.  We wanna we wanna know that when a JP is  valid, it does get passed thoroughly.  But we also want to know that, um, when it's  fed, uh, incorrect formats, uh, it'll do the right thing.  So whatever the specification is through an exception usually, uh,  sometimes these are called the positive and negative tests.  So, uh, positive tests testing, um, that your code does  the right thing when things sort of follow the the  happy path through the code.  Um, and negative tests are there to show that, uh,  it does the right thing when, uh, odd or exceptional  things happen.  Um ah.  I will make a comment about the, um the long  answer questions.  I saw a lot of people.  Well, not a lot of people, but some people talking  about black box text testing that obviously didn't really understand  how the concept applied.  So I will mention so we looked at ISP input  space partitioning.  Um, So I will be going through and looking for  people who claimed that ISP is a black box testing  technique.  Uh, that's not an especially good way of characterising it.  Um, yeah.  Black box testing and white box testing are usually not  terribly useful terms.  Um, for ISP.  Uh, certainly you're supposed to construct your tests based on  exactly the specification.  Uh, but if someone talks about black box box testing,  then, um, firstly, they're probably from the eighties or something.  Cos not many people use that terminology anymore.  Um, but the idea was that you you write tests  without ever looking inside.  So you've, um you're given just the specification, and you're  you're not allowed to look at the, uh, the source  code.  Um, that's not terribly common these days.  Um, a lot of times, the people who write tests  will be the same people who are writing the source  code.  Um, and even though what you should be testing is  the specification, Uh, sometimes, uh, you may wanna point out  that the specification, you know, you may wanna tell whoever  wrote the spec that they have got something wrong.  Uh, there's, uh there's nothing wrong with, um, going to  someone and saying, uh, look, the spec needs to be,  you know, um, if we write something according to the  spec, uh, here's what will pass, and here's what will  fail.  Uh, it seems like from what you wrote in the  code, that's not what you intended.  So we need to fix something either Either the code  needs to be fixed or the spec does.  Um, so, yeah, I wouldn't really call ISP, uh, a  traditional black box testing technique anyway, so however, getting back  to the syntax stuff, um, so this, um uh, right  at formalising things as grammars and, uh, constructing tests that  way.  Um, do we want to apply that to every case  where something, uh, has a syntactic specification?  So, um, let's say you know, every time we've got  something that should be in date format, uh, do we  want to apply all these techniques?  Uh, not necessarily.  Um will usually focus on areas of high risk.  So, um, I don't know if if buzzing dates exactly  is kind of critical to the purpose of the software,  then, uh, we probably would pull out these techniques if  it's like, uh, a very small thing.  Like if it's, uh, just a field on a website,  and we're probably using, um, someone else's date pasing package.  Anyway, uh, we might settle for, uh, for less.  Uh, usually remember, it's our code that we want to  be testing.  Uh, not other people's.  So, uh, in that sort of a case, uh, we  might settle for, uh, just using something like input space  partitioning to, uh, uh, test whatever the code is supposed  to do.  So, um, if your software is all about passing dates,  then obviously this is important.  Um, pausing command line arguments once a programme gets big  enough, then that's usually sufficiently important that you should probably  test it.  Um, and it's, uh it's not uncommon for, uh you  to find errors in this sort of thing.  I actually, um, reported one, uh, in, uh a, um  uh, package management and builder system.  Uh, a couple of years ago, And, uh, I just  got a notification from github that, uh, someone has got  round to, uh, fixing that today, two years later, but  for, um, for two years, it was sort of doing  wrong and confusing things whenever someone, uh came up with  a particular set of command line arguments.  So yeah, it, um, it is easy to get these  wrong, uh, so it is worth, um, for large bits  of software, it is worth testing, Right?  So let's look at an example.  So we'll just go through a small grammar that's going  to, uh, represent simple arithmetic expressions.  So this will be one of the sort of mini  language, uh, sort of examples.  So the sorts of things that will be valid in  our language are just things like, you know, three plus  two, uh, minus five for the plus in, uh uh,  the plus and two in brackets.  So our terminal symbols are just gonna be numerals plus  minus and parentheses.  So let's see how we do that.  Uh, OK, so we want digits as always, So they're  the same as before.  Uh, and we will say that an expression is either  a digit.  So it's like, um, the simplest expression we can have  or it's an expression plus another expression.  Well, we'll we'll get a little more complicated than that.  We'll say it's either a digit or a smaller expression,  plus another or a smaller expression minus another or an  expression in brackets.  So, given that definition, we can say that, uh, if  we wanted to generate, uh, some particular expression, uh, we'd  start on the left with our non terminal symbol, and  we'd say, OK, what can this expand to?  Uh so it could expand to left parentheses, the expression  and a right parenthesis.  Uh, then we'd look at that again.  And we'd say, Can anything be expanded anymore?  Yes, it can.  So you might say that can be expanded to expression  minus expression.  Uh, each of those we'd look at and say, Can  that be expanded?  So we might say, Yeah, we'll expand that to three,  and we'll expand that to eight.  Uh, and we've now got something that, uh is inside  our language.  So three minus eight counts as something that is in  the language.  So, uh, once you've got a grammar, there's two ways  that you can, uh, use it generally, uh, you can  use it to generate something that's in the language.  Uh, and that's that's quite useful for randomised testing.  So given a specification for, uh, do A, we could  say, uh, here's the grammar that describes Docker Invocations.  Uh, generate me, uh, a bunch of random docker commands,  Uh, and we'll use those in our tests and see  how they work out.  Uh, so you can generate something that's, uh, in the  language.  Uh, and you can also look at something and decide.  Is it in the language or not?  So the first thing is called, uh, generation, So generating,  uh, a string, and the second thing is called passing.  So that's what a compiler is doing When it looks  at your Java programme, it's looking at some much bigger,  longer string.  Uh, that it knows is either made up from a  grammar or not.  So it either falls into the, uh, the class of  syntactically valid Java programmes or it doesn't, uh and it's  analysing it in terms of rules like these to see  if it, um if it fits or it doesn't.  Uh, so the generating thing" metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="came up with  a particular set of command line arguments.  So yeah, it, um, it is easy to get these  wrong, uh, so it is worth, um, for large bits  of software, it is worth testing, Right?  So let's look at an example.  So we'll just go through a small grammar that's going  to, uh, represent simple arithmetic expressions.  So this will be one of the sort of mini  language, uh, sort of examples.  So the sorts of things that will be valid in  our language are just things like, you know, three plus  two, uh, minus five for the plus in, uh uh,  the plus and two in brackets.  So our terminal symbols are just gonna be numerals plus  minus and parentheses.  So let's see how we do that.  Uh, OK, so we want digits as always, So they're  the same as before.  Uh, and we will say that an expression is either  a digit.  So it's like, um, the simplest expression we can have  or it's an expression plus another expression.  Well, we'll we'll get a little more complicated than that.  We'll say it's either a digit or a smaller expression,  plus another or a smaller expression minus another or an  expression in brackets.  So, given that definition, we can say that, uh, if  we wanted to generate, uh, some particular expression, uh, we'd  start on the left with our non terminal symbol, and  we'd say, OK, what can this expand to?  Uh so it could expand to left parentheses, the expression  and a right parenthesis.  Uh, then we'd look at that again.  And we'd say, Can anything be expanded anymore?  Yes, it can.  So you might say that can be expanded to expression  minus expression.  Uh, each of those we'd look at and say, Can  that be expanded?  So we might say, Yeah, we'll expand that to three,  and we'll expand that to eight.  Uh, and we've now got something that, uh is inside  our language.  So three minus eight counts as something that is in  the language.  So, uh, once you've got a grammar, there's two ways  that you can, uh, use it generally, uh, you can  use it to generate something that's in the language.  Uh, and that's that's quite useful for randomised testing.  So given a specification for, uh, do A, we could  say, uh, here's the grammar that describes Docker Invocations.  Uh, generate me, uh, a bunch of random docker commands,  Uh, and we'll use those in our tests and see  how they work out.  Uh, so you can generate something that's, uh, in the  language.  Uh, and you can also look at something and decide.  Is it in the language or not?  So the first thing is called, uh, generation, So generating,  uh, a string, and the second thing is called passing.  So that's what a compiler is doing When it looks  at your Java programme, it's looking at some much bigger,  longer string.  Uh, that it knows is either made up from a  grammar or not.  So it either falls into the, uh, the class of  syntactically valid Java programmes or it doesn't, uh and it's  analysing it in terms of rules like these to see  if it, um if it fits or it doesn't.  Uh, so the generating thing is pretty easy.  Um, I think anyone should be able to code something  like that.  Um, so it's just a matter of, uh uh, starting  on the left.  Uh, and you know, if you wrote a programme to  this, it would pick some random thing on the right,  uh, and then fill in the, uh, the non terminal  things until none were left.  So that's easy enough.  Pasing is a bit trickier, and we're not gonna cover  the details of how, um how parsing is done exactly.  Uh, we will in the labs, Um, look at using  a pasa, but, uh, we won't be writing any ourselves.  Uh, so typically, also, when we specify her grammar, there  will be some kind of a a start symbol.  So, uh, sort of the top level of whatever thing  it is we're describing.  So for a programming language, we might say a programme  file is defined as and have a bunch of bits  of pieces.  Uh, so what we call productions, uh, that it can  expand to, uh, for a date.  Then the top level thing that we'd be looking at  is date and so on and so forth.  So the two tasks I mentioned, uh, that I said  we can use grammars for.  We can use them to build recognizers, uh, and we  won't go into the details of how that is done.  We'll just, um uh, see, See an example in the  labs and see how we can use it.  Uh, and we can also use them to build generators,  which is a lot easier.  And I I hope that most people here probably could  code one of those.  Uh, but again, we'll see software in the labs that  does that for us, and both of them are useful.  Alright, So if we've decided that some sort of, um  pausing some sort of syntax.  It's important enough that we we do want test our  syntax thoroughly.  Uh, what kind of criteria are we gonna use for  that?  So there's a As with the other sorts of testing  I've looked at, there are some, uh, levels of coverage  that are very coarse.  So they, uh, don't exercise the grammar particularly thoroughly.  There are some that are probably far too.  Um uh, take far too much work for most purposes.  Uh, we'll try and find something in between.  So a couple of possibilities that might spring to mind  are, um we could write tests so that all of  our terminal symbols, uh, get used in our test.  So that's that's one possibility.  It's probably not a very interesting one.  Uh, so that would imply that for something like this,  um, we've got to make sure that our tests, uh,  make use of all the digits.  Uh, parentheses, pluses and minuses.  But so why is it probably not especially interesting?  Well, if we've got code that works for one digit,  it probably works for them all.  You know, there's, uh we can sort of apply some  of the ideas from our A S P here.  Um you know, our digits are sort of a an  equivalence class, uh, partition of their own.  Um, it probably isn't going to serve us terribly well  to make sure that we've tested, um, each one of  these.  So that's one possibility we could write, um, tests that  exercise each terminal symbol.  Uh, more interesting.  Well, a more plausible one, uh, is to aim for  something called production coverage.  So here, uh, a production is one of these things  on the right.  So, uh, we've got a thing on the left.  It can be expanded to, uh, one of four things.  So another idea is that we should write, um, tests  that cover all of those four things.  Uh, in this case for digit, Um, we will end  up having to write tests for all of these, but,  um uh, for all of the testing criteria, I said,  um, early on that, um, what we want is, um,  if we've done some kind of coverage analysis of our  tests, uh, and they show that we've missed something.  Um, then we wanna think about that.  Alright.  Um, you don't necessarily blindly want to just, um, write  tests and say, Oh, I must write, You know, 10  tests here to make sure I cover every example.  Uh, every digit, um, you might instead say, Well, look  doing, um uh, aiming for production coverage says I should  try and exercise all of these.  And that seems sensible.  Um, and if it says I should exercise all of  these, uh, maybe that's not quite so sensible.  Maybe we won't bother with that.  OK, so that's, uh, terminal symbol coverage and production coverage.  So terminal symbol is when we've written tests that use  every terminal production coverage is when we've written tests, uh,  that contain every production in this case.  Uh, if we've used every terminal, then we will have  had to use, uh, every production.  Uh, yeah, the digital.  The terminal is liberty in this case, only have 10,  but no, no, that's not true.  There's 10, 11, 12, 13, 14.  Oh, yeah.  Yeah.  And also the the the term is liberty.  Because it is, uh, 10.  And but the terminal is this product.  It is unlimited.  So, no, the productions are unlimited because of their own.  No, there's four.  Well, it depends.  Um, So, uh, are you going off?  Are you looking at the Where are you?  Where are you getting a definition of production?  From the definition production in the page that page 36.  I don't see a definition of production there it not  in the room?  Yeah, uh, in the page, uh, 20 and 30 with  this person for production.  Yeah, well, it says each alternative.  OK, so by alternative, I mean one of these things.  1234.  Every expression can be altered to by many, many, uh,  choices.  You're talking about something different.  So you're talking about, uh, what's called a a string.  Uh, so you've got a string that's completely made of  terminals?  Yep.  OK, so there are an infinite number of those.  Yes, but there are only a finite number of, um  uh, right hand sides for the rule.  So look at the grammar.  How many rules are there?  Uh, two.  There's two.  That's a rule.  And that's a rule.  OK, how many terminals are there?  We said there's 14.  Alright.  How many productions are there?  Ok, so I've said that production is one of these  alternatives, so it's a branch on the right.  So there's 1234, plus 10.  So, actually, there's just 14.  So by rewriting, I mean, uh, a portion of the  right hand side that says how you can do one  rewriting I don't mean one of the final strings.  So not the final.  No, no, no, no, no, no, no.  I didn't say we have to cover these five.  I didn't say anything about having to cover the final  strings.  We can't do that because there's an infinite number of  them, All right, I said there's four alternatives here.  So pro by production, I mean an alternative.  So I mean, part of the right hand side and  those there's only 14 of them.  And the interesting ones are probably these three, and so  we can aim to get good coverage of those.  OK, but yeah, for the final strings.  Um, yeah.  So for something like a date, uh, there's a finite  number.  So if we say dates are always, you know, uh,  44 digits for the year and two for the month  and two for the day, then that is a finite  number of strings.  Uh, there's no way that we'd really want to try  exhaustively testing those, but it is possible.  OK, so that that's a finite language.  Uh, and" metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="exercise all of  these, uh, maybe that's not quite so sensible.  Maybe we won't bother with that.  OK, so that's, uh, terminal symbol coverage and production coverage.  So terminal symbol is when we've written tests that use  every terminal production coverage is when we've written tests, uh,  that contain every production in this case.  Uh, if we've used every terminal, then we will have  had to use, uh, every production.  Uh, yeah, the digital.  The terminal is liberty in this case, only have 10,  but no, no, that's not true.  There's 10, 11, 12, 13, 14.  Oh, yeah.  Yeah.  And also the the the term is liberty.  Because it is, uh, 10.  And but the terminal is this product.  It is unlimited.  So, no, the productions are unlimited because of their own.  No, there's four.  Well, it depends.  Um, So, uh, are you going off?  Are you looking at the Where are you?  Where are you getting a definition of production?  From the definition production in the page that page 36.  I don't see a definition of production there it not  in the room?  Yeah, uh, in the page, uh, 20 and 30 with  this person for production.  Yeah, well, it says each alternative.  OK, so by alternative, I mean one of these things.  1234.  Every expression can be altered to by many, many, uh,  choices.  You're talking about something different.  So you're talking about, uh, what's called a a string.  Uh, so you've got a string that's completely made of  terminals?  Yep.  OK, so there are an infinite number of those.  Yes, but there are only a finite number of, um  uh, right hand sides for the rule.  So look at the grammar.  How many rules are there?  Uh, two.  There's two.  That's a rule.  And that's a rule.  OK, how many terminals are there?  We said there's 14.  Alright.  How many productions are there?  Ok, so I've said that production is one of these  alternatives, so it's a branch on the right.  So there's 1234, plus 10.  So, actually, there's just 14.  So by rewriting, I mean, uh, a portion of the  right hand side that says how you can do one  rewriting I don't mean one of the final strings.  So not the final.  No, no, no, no, no, no, no.  I didn't say we have to cover these five.  I didn't say anything about having to cover the final  strings.  We can't do that because there's an infinite number of  them, All right, I said there's four alternatives here.  So pro by production, I mean an alternative.  So I mean, part of the right hand side and  those there's only 14 of them.  And the interesting ones are probably these three, and so  we can aim to get good coverage of those.  OK, but yeah, for the final strings.  Um, yeah.  So for something like a date, uh, there's a finite  number.  So if we say dates are always, you know, uh,  44 digits for the year and two for the month  and two for the day, then that is a finite  number of strings.  Uh, there's no way that we'd really want to try  exhaustively testing those, but it is possible.  OK, so that that's a finite language.  Uh, and this one here, uh, represents an infinitely large  language.  Uh, so we definitely that's not even possible to test.  So we definitely wouldn't want to try and test all  of the, um, uh, all of the strings it can  produce, but yeah, by production.  I just mean one of these things on the right  hand side.  Yep.  So there's four there.  There's 10 there.  So that's why it says alternative.  So maybe rewriting is a less I I'd focus on  alternative rather than rewriting if it's confusing you.  Well, replace it.  Don't talk to me after all.  Alright, if it's confusing, you talk to me after Alright,  so production coverage is gonna subsume terminal symbol coverage.  Uh, if we've used every production, we've also used every  terminal, But in some cases, uh, and in this case,  uh, they actually end up being the same number.  So 11234 Oh, actually, no slightly less so.  There will be, uh, 10, 13, 14, 15.  Uh, well, there's a, uh there's gonna be, uh, a  certain number of terminals.  So 10, 11, 12, 13, 14, 14 terminals.  But if we've used every right hand side every alternative,  then we will have used all the terminals.  OK, so the thing you you were talking about, uh,  is actually what we call derivation coverage.  So that's when you've expanded something fully.  Uh, so you're looking at all the strings in the  language.  Uh, do we wanna try and do that?  Uh, in general?  No.  Firstly, because sometimes it's impossible.  So sometimes we'll have an infinitely large language, so we  can't possibly test it.  Uh, but even for much smaller languages, it's still usually  gonna be far too many tests for us to, um,  really want to do that.  OK, so just so we're clear on exactly, Um, how  many tests we'd need to get different sorts of coverage.  Um, so let's try another one.  Uh, if we wanted to get terminal symbol coverage of  this, uh, we look at how many terminals there are,  so there's 10.  So, uh, we would need, at most 10 tests, and  we'd have used every criminal.  Uh, we could actually get away with less.  So, um, if we apply this grammar, uh, we could  come up with the string.  So the string 987654321.  Oh, uh, that's a string that's in the language.  So if we wrote a single test, uh, that made  use of that string, uh, then we'd have achieved terminal  coverage.  Sorry.  Um, so 10 is the maximum number of tests that  we'd have to write to get production coverage.  Uh, how many productions are there?  So I said a production is one of these alternatives  on the right hand side.  So I've got 10, 11, 12.  So the maximum number of tests that we could possibly  need to write, uh, is 12, But again, we could  probably, uh, get by with far fewer, so it would  be possible to get that level of coverage with, uh,  many fewer tests.  Um, if we wanted to try and get this level  of coverage derivation coverage, uh, then for this grammar again,  we can't do it, Uh, because this language produces an  infinite number of strings.  So what the language describes is, um, all strings made  up of integers however long.  So, uh, there's no limit to how long a string  of integers could be.  So that means the language is infinite.  So we couldn't even in theory, uh, achieve, uh, derivation  coverage.  So in general, uh, derivation coverage is is usually not  gonna be, uh, well, sometimes it will be impossible.  Uh, but even when it is possible, it'll still usually  be, uh, not very feasible, so he wouldn't want to  do it.  Alright.  So I did mention before that, um, if we've got  a grammar for something, So let's say we were looking  at, um uh j peg image data.  So that's something from the Apache Commons library for processing,  uh, JPEG files.  Uh, or we might have something like, um uh, there's  AC library, lib p n g.  For manipulating, uh, p n g graphics files.  Uh, and there's a structure called P n g struck.  Um, for those, um, so the same ideas we've got  for, uh, levels of coverage.  We could apply to those classes as well if we  wanted.  So we could work.  Um, we could work from the specification of a of  A graphics format.  Uh, or we could look at the, um, the structure  of those classes.  Um, both of them end up being, um, something that  we can apply these ideas to.  So when we expanded something, what you end up with  is, um, I said that there's some kind of a  start symbol in every grammar.  So, um, here is something for English sentences.  Um, so this is what linguists call a pas tree.  We say, uh, so a simple model of English sentences  might say we can have sentences.  Uh, and, um, we can have a verb phrase which  consists of a verb, Uh, and then some kind of,  um uh, what most of us would call a noun  phrase.  Uh, so linguists call it a determiner.  Uh, so we could do the same sort of expanding  thing that we did with our little, uh, arithmetic language  and say a sentence expands to, um uh, well, what  most people would call a noun phrase and a verb  phrase that expands to that, uh, that we might have  a bunch of, um, uh, examples of verbs and, uh,  determiners so noun phrases so we could expand those out.  So that would be an example of generating a string.  So starting from the grammar and producing something, uh, going  backwards, uh, is the task of starting with Lucy won  the race and working out what rules were applied to  produce that, uh, in either case, you end up with  this sort of a a tree structure.  So it's called a pas tree.  Uh, and it can be a useful way of, um,  Visualising, Uh, what your grammar is doing.  Um, I can't remember if the library, if the tool  we're gonna use in labs shows you the pars tree.  I don't think it does, but, um, uh, a lot  of PSA software will produce those, so it's handy for  debugging purposes.  OK, so one place that, um, being able to generate  things comes in handy, uh, is for, uh, randomised Testing,  uh, is also quite handy for, uh, uh, load testing.  So for in the, um, the long answer question, uh,  from the week six test, um, that looked at requirements  for, uh, security and also requirements for, um, a system  being able to handle, uh, some level of load.  Um, so being able to generate things that follow a  syntax is quite useful for, um, stress testing and performance  testing.  So you might wanna, uh, sort of barrage your system  with, um, a very high level of valid things.  You might wanna, uh, apply some invalid things as well,  because not everything that your system receives is necessarily going  to be valid.  Uh, but it's, uh, this sort of this sort of  grammar is very handy for, uh, generating things that can  form to, uh, some sort of a a grammar or  rules for a structure.  So things like web requests, um, those also follow a  grammar.  So there's rules for those, uh, you can look up  the, um, the h CE p standard and say, um  uh, here are the rules for those, um, so I  said generators are usually, um, reasonably easy to write.  Um, but for that sort of thing for performance testing,  there's a lot of good software already out" metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="Um, we could work from the specification of a of  A graphics format.  Uh, or we could look at the, um, the structure  of those classes.  Um, both of them end up being, um, something that  we can apply these ideas to.  So when we expanded something, what you end up with  is, um, I said that there's some kind of a  start symbol in every grammar.  So, um, here is something for English sentences.  Um, so this is what linguists call a pas tree.  We say, uh, so a simple model of English sentences  might say we can have sentences.  Uh, and, um, we can have a verb phrase which  consists of a verb, Uh, and then some kind of,  um uh, what most of us would call a noun  phrase.  Uh, so linguists call it a determiner.  Uh, so we could do the same sort of expanding  thing that we did with our little, uh, arithmetic language  and say a sentence expands to, um uh, well, what  most people would call a noun phrase and a verb  phrase that expands to that, uh, that we might have  a bunch of, um, uh, examples of verbs and, uh,  determiners so noun phrases so we could expand those out.  So that would be an example of generating a string.  So starting from the grammar and producing something, uh, going  backwards, uh, is the task of starting with Lucy won  the race and working out what rules were applied to  produce that, uh, in either case, you end up with  this sort of a a tree structure.  So it's called a pas tree.  Uh, and it can be a useful way of, um,  Visualising, Uh, what your grammar is doing.  Um, I can't remember if the library, if the tool  we're gonna use in labs shows you the pars tree.  I don't think it does, but, um, uh, a lot  of PSA software will produce those, so it's handy for  debugging purposes.  OK, so one place that, um, being able to generate  things comes in handy, uh, is for, uh, randomised Testing,  uh, is also quite handy for, uh, uh, load testing.  So for in the, um, the long answer question, uh,  from the week six test, um, that looked at requirements  for, uh, security and also requirements for, um, a system  being able to handle, uh, some level of load.  Um, so being able to generate things that follow a  syntax is quite useful for, um, stress testing and performance  testing.  So you might wanna, uh, sort of barrage your system  with, um, a very high level of valid things.  You might wanna, uh, apply some invalid things as well,  because not everything that your system receives is necessarily going  to be valid.  Uh, but it's, uh, this sort of this sort of  grammar is very handy for, uh, generating things that can  form to, uh, some sort of a a grammar or  rules for a structure.  So things like web requests, um, those also follow a  grammar.  So there's rules for those, uh, you can look up  the, um, the h CE p standard and say, um  uh, here are the rules for those, um, so I  said generators are usually, um, reasonably easy to write.  Um, but for that sort of thing for performance testing,  there's a lot of good software already out there that  does the job for us.  So if you can, um, um, there's there's load and  performance testers.  Uh, and if you can give them, uh, a reasonable  description, uh, of what your traffic should look like, uh,  they'll produce it for you.  Um, so you can produce that at all sorts of  levels.  So, um, we looked at a little diagram that, um,  uh described TCP packets.  So network packets, uh, if we wanted to stress test,  uh, say, uh, router software or something.  Uh, we might want to generate lots of random TCP  packets.  Uh, if we wanted to stress test a web system,  we might generate lots of random web requests.  Um, so, um, yeah, it's quite handy for, uh, quite  handy for doing that.  So if we just generated Web web requests that, uh,  sort of met the h GDP, uh, sort of syntax,  uh, then most of those would be invalid.  So, uh, for our site, we'd end up generating a  lot of four Oh, four errors.  So, you know, the vast majority of, um, web requests  that you could create if you sent them to your  site, they probably wouldn't hit anything useful.  Um, So, uh, a lot of generators will, uh, ask  you for rules about, um, what kind of URL.  S they should be trying to hit what kind of  data they should be sending, if any, Uh, and they'll  get you, Um, uh, much more realistic.  Much more realistic traffic and results.  So, um, so we're not gonna use these?  I don't think in the labs, but, um, for anyone  who's interested, uh, if you ever do need data generators,  uh, then, to be honest, the easiest thing to do  is just Google for whatever train, whatever.  Just Google for, um, a generator and whatever kind of  thing you're after.  Uh, so for network traffic, uh, there's tools like a  sky sky is quite a good one.  So that's a python library flow grind.  Um, there's lots of tools for generating random network traffic  or traffic that falls within some set of rules.  Uh, GP.  Request generators.  Uh, GDP per is, uh, quite a good one.  Um, for some kind of file format, probably just google  something like, um, a JPEG generator or something.  Um, so, for for random bit maps, uh, you can  get, uh, random bit maps at random dot org.  Um, but yeah, it's it's not.  It's not a terribly hard task to write your own.  Um, so one thing we're not gonna look at is  I said that, um uh, when you are describing, So  the file formats are syntax as described are, um, something  called contact free.  And they're reasonably simple.  Um, if you're talking about something, uh, as complex as  a language, you may go beyond the syntax and start  to look at, um uh, look at semantics, and I'll  just mention that that's a a little more complicated.  And, um, so we're not gonna We're not gonna look  at that in this unit.  Um, sometimes you will have, um, things like, uh, check  sums that can't be captured by the grammars that we've,  uh we've looked at, so TCP packets.  Um, we saw a little diagram of what they look  like.  Uh, some of it can be described, uh, using our,  um our ideas of, uh, this B n f.  Grammar.  This context free grammar.  Ah, but check sums, which turn up a lot.  So in network packets or, um, credit card numbers.  So the end of a credit card number is, um,  actually a check sum that tells you whether the the  rest of it is valid.  Uh, those can't be captured by our grammar.  Um, So, um, if you are writing a generator and  you want to get traffic, that's valid.  That's something that you'll have to, um, manually add in  yourself.  So you may want to, uh, say I can randomly  generate you know, these numbers that look like a credit  card.  But we know that the, um, the last the last  few digits form a check sum, so we'll calculate those.  Um, so again, all of the, um, all of the  syntax that we look at will be, um, fairly simple.  Uh, but, uh, yeah, there's, um, lot of guides out  there for, um, should you need to do more complex  things.  Uh, OK, it is four.  So we'll just take a very brief 55 minute break  and come back at six.  Past, uh, and we will finish off.  Uh, this lecture will look at, uh, random testing and  go on to the next one.  Oh, any queries about that material so far?  No.  OK, can.  And so you to your feet.  The I to 10.  Yeah, numerous actors.  Two of them were from and OK, yeah, that you  place for the so thank you.  Go.  And art.  She was never on the left.  Yeah.  And you need that job during pre to make somewhere  from the home in the middle.  Some of the past three and four.  We are happy that Yeah.  All right.  So I said that, um, uh, generating render valid, um,  and for that matter, occasionally invalid.  Because I said sometimes we want to do, um uh  what I call negative testing.  So, uh, testing that are off the the main path  of our programme so that the right sort of exceptions  are being thrown, um, so useful for performance testing.  Uh, another place that comes in handy is, uh, for  what's called, uh, property based testing, which we will see  more of.  Uh, that's a sort of testing that, um, checks that,  um, invariants about functions hold.  So we've seen, uh, a few different sorts of invariants  so far.  This is a a new one.  So we will talk about property based testing and, um,  more detail, but, um, sorts of invariants that we can  have include things like, um, so we can have class  invariants.  Uh, they say they talk about what the the valid  sort of shapes of data in an object are.  So there are rules about, um uh, if data in  our in our object is gonna change, how can it  do so So, um, uh, it turns up in things  like, uh, well, things like dates.  So if we were writing a class to represent dates,  uh, one of our rules would be so it's in  one of the previous lectures.  So if this is not ringing a bell.  You can.  You might want to go back and have a look  at that.  Um, but if we had a class representing a date,  uh, then, uh, one of one of the invariants about  that class would probably be It should never contain incoherent  or inconsistent data.  So we should never end up with, uh, say something  being the 99th of February.  So that's a sort of invariant, uh, class invariant.  We can have invariants about a whole system.  Uh, so if we had a system with a database,  we might have rules about, um uh, so the example  that I used there was, um, we might have a  database of students and courses and enrollments, and, uh, our  invariants might be things like, uh, if you've got an  enrollment.  So it says, um, some student with this student number  is enrolled in the unit 655 Oh, one for 2023  semester one.  Uh, then there has to actually be a student with  that student number.  Uh, and there has to actually be, uh, such a  such a unit.  So, uh, that would be, uh, sort of a a  system level invariant.  Uh, these sorts of invariants are, uh, new ones.  So we'll talk about those more later.  OK, so a couple of final applications for, uh, the  syntax based stuff is we can use it for something  called mutation based testing, Um, which is not very commonly" metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="we will finish off.  Uh, this lecture will look at, uh, random testing and  go on to the next one.  Oh, any queries about that material so far?  No.  OK, can.  And so you to your feet.  The I to 10.  Yeah, numerous actors.  Two of them were from and OK, yeah, that you  place for the so thank you.  Go.  And art.  She was never on the left.  Yeah.  And you need that job during pre to make somewhere  from the home in the middle.  Some of the past three and four.  We are happy that Yeah.  All right.  So I said that, um, uh, generating render valid, um,  and for that matter, occasionally invalid.  Because I said sometimes we want to do, um uh  what I call negative testing.  So, uh, testing that are off the the main path  of our programme so that the right sort of exceptions  are being thrown, um, so useful for performance testing.  Uh, another place that comes in handy is, uh, for  what's called, uh, property based testing, which we will see  more of.  Uh, that's a sort of testing that, um, checks that,  um, invariants about functions hold.  So we've seen, uh, a few different sorts of invariants  so far.  This is a a new one.  So we will talk about property based testing and, um,  more detail, but, um, sorts of invariants that we can  have include things like, um, so we can have class  invariants.  Uh, they say they talk about what the the valid  sort of shapes of data in an object are.  So there are rules about, um uh, if data in  our in our object is gonna change, how can it  do so So, um, uh, it turns up in things  like, uh, well, things like dates.  So if we were writing a class to represent dates,  uh, one of our rules would be so it's in  one of the previous lectures.  So if this is not ringing a bell.  You can.  You might want to go back and have a look  at that.  Um, but if we had a class representing a date,  uh, then, uh, one of one of the invariants about  that class would probably be It should never contain incoherent  or inconsistent data.  So we should never end up with, uh, say something  being the 99th of February.  So that's a sort of invariant, uh, class invariant.  We can have invariants about a whole system.  Uh, so if we had a system with a database,  we might have rules about, um uh, so the example  that I used there was, um, we might have a  database of students and courses and enrollments, and, uh, our  invariants might be things like, uh, if you've got an  enrollment.  So it says, um, some student with this student number  is enrolled in the unit 655 Oh, one for 2023  semester one.  Uh, then there has to actually be a student with  that student number.  Uh, and there has to actually be, uh, such a  such a unit.  So, uh, that would be, uh, sort of a a  system level invariant.  Uh, these sorts of invariants are, uh, new ones.  So we'll talk about those more later.  OK, so a couple of final applications for, uh, the  syntax based stuff is we can use it for something  called mutation based testing, Um, which is not very commonly  used, but, um, it's sort of regarded as kind of  a, um almost a gold standard of testing.  So if you do, uh, it can be kind of  expensive to do, But, uh, uh, if you can do  mutation based testing, uh, of your system, uh, then it's  often regarded that, you know, you've you've tested your system  pretty thoroughly.  Um, So I said for, uh, for generators, we can  use those for, uh, property based testing and for fuzzes.  So these are both sorts of randomised testing.  So the first one of these we'll look at is  mutation testing.  So mutation testing is a bit different to the other  sorts of testing we've looked at so far.  So for all of the other things we've said, um  um, here's some Here's some artefact of the system.  Uh, so maybe a a specification or code for a  method or a class, Uh, and we would like to  write tests for that mutation.  Testing, uh, is kind of a bit different in that  it's testing out other tests.  So it's a way of, um, evaluating, I should say  sweet, not suit.  Oh, slide 15.  Um, so it's a way of evaluating, uh, a suite  of software tests.  So one way of evaluating them, uh, I said before  is, um, you might run them and, uh, do some  kind of coverage analysis.  So you might say, um uh, Or you might have  automated, uh, programmes that tell you, uh, has this given  us?  Uh, maybe, uh, well, edge coverage or node coverage of  our code.  So, uh, a lot of coverage systems will just call  those, uh, uh, statement coverage or, uh, decision coverage.  Uh, but, um, here, we're gonna apply this technique to  get, um, an idea about the quality of our tests.  So what we do is, uh we've got our existing  system, and we've already got a bunch of tests we've  written for it, so we used, you know, ISP and  graph based testing and syntax based testing.  And we've we've come up with what we think is  a good bunch of tests.  Now what we do is we take our original programme  and we mutate it in various ways.  So we modify our original programme.  Uh, we're basically introducing mistakes.  OK, so if we if we randomly modify our original  programme uh, almost certainly, uh, the new programme is not  gonna be right.  In fact, we should hope it's not gonna be right.  Uh, if if we could make random changes to our  original programme like if it had numbers in it and  we randomly changed those numbers, uh, or if it had  mathematical operators and we randomly changed some of those so  we flipped, uh, pluses to minuses.  Uh, we would expect that the new programme should be  wrong, so we'll modify the programme under test.  Uh and often these sorts of modifications are intended to  represent, um typical programme programming errors.  So typo is that you could make a wrong choice  of operator off by one, uh, errors, that sort of  thing.  And then we run our tests over the new programme.  So first of all, um, we So knowing that our  new programme should be wrong, we should expect, uh, tests  to now fail.  So if the tests don't fail, so if our If  our tests don't detect that the new code is wrong.  Then something is awfully, awfully bad.  Either our tests are terrible or our programme is really,  really unusual because you shouldn't be able to randomly change  stuff in the programme and still get one that works  correctly.  Um, one place that you might be able to do  that is I In an earlier lecture, I said you  might have dead code.  Um, so that's code.  That sort of Given the current logic of the programme,  you should never be able to reach uh, and some  some sorts of dead code compilers can detect and warn  you about.  Um, sometimes static analyzers, uh, will warn you about it.  Uh, so that's one possibility you might have, um, dead  code in your programme.  And in that case, mutation testing has told you something  useful.  It said, um uh, this code, it it it currently  doesn't matter what is in there.  Uh, the test don't reach it.  Ever.  And, uh, you know, whatever is in there, um, doesn't  seem to make a difference to the output of the  programme.  So that's a useful thing to know.  You now know you should probably get rid of it.  You should find out why you've got that dead code  there, and you should get rid of it.  Or, uh, your tests are wrong.  So your tests are testing the wrong thing, So your  test weight should detect and reject the mutated code.  Um, so a bit of terminology here.  So those, uh, those derivations when we said we fully  expand a string?  Um, when you look at mutation testing, uh, they call  those ground strings so that, uh, that sort of means,  um, ground means doesn't have any, uh, doesn't have any  things in it that can still be expanded.  So not having any variables.  So a ground string is is typically gonna be our  programme.  Our mutation operator, uh, is a rule that specifies ways  of generating, uh, a new syntactically valid programme from an  old one.  So, in most languages, uh, any place that you can  have, uh, a less than operator?  You could put a greater than operator there instead.  So one of our mutation, uh, operators might be, uh,  I if you see a less than symbol, pick one  at random and change it into a greater than symbol  and uh, if we've applied one of those mutation operators,  what we end up with, we call a mutant.  So we have our original programme, which was hopefully good.  We apply.  So in this case, if we pick this rule, we,  um we find a random less than symbol in there,  and we flip one of them into a greater than  symbol.  Uh, and our new programme we call a mutant, uh,  and for a mutation testing package.  Uh, and there's a few out there for both, um,  python and java.  Uh, what we want is a test suite.  Should be able to kill mutants.  So, uh, we look at one or more of our  tests and we say, uh, given the new mutated programme,  uh, do the tests kill the mutant?  I do.  They give a different result compared to the original.  If we do, then we say, uh, the tests, uh,  did kill the mutant.  Uh, if they don't, uh, then they don't kill it.  So here is a simple method that we might test,  uh, in a java like language.  So we have might, um, something like, uh, a moult.  Uh, so just perform as multiplication on two integers.  So it's a It's a a trivial example.  Uh, and you wouldn't actually write something like this, but,  um, uh, we're gonna use it here to look at  what might constitute good or bad tests for that, uh,  and how mutation testing can help us here.  So what if we said, um uh, a test for  my moult method is I think that, um, one times  one should equal one.  Is that an especially useful test?  Well, the answer is no.  Cos we could have mis coded our programme.  Well, or at least there's lots of other tests that  are more informative.  Um, because we could have mis coded our programme in,  uh, numerous ways and still get one for an answer.  So, for instance, suppose we mistyped uh, the asterisk.  So in in python, double asterisk is power.  Yeah, So in in Java, that's not actually a a  valid change you could" metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="of the  programme.  So that's a useful thing to know.  You now know you should probably get rid of it.  You should find out why you've got that dead code  there, and you should get rid of it.  Or, uh, your tests are wrong.  So your tests are testing the wrong thing, So your  test weight should detect and reject the mutated code.  Um, so a bit of terminology here.  So those, uh, those derivations when we said we fully  expand a string?  Um, when you look at mutation testing, uh, they call  those ground strings so that, uh, that sort of means,  um, ground means doesn't have any, uh, doesn't have any  things in it that can still be expanded.  So not having any variables.  So a ground string is is typically gonna be our  programme.  Our mutation operator, uh, is a rule that specifies ways  of generating, uh, a new syntactically valid programme from an  old one.  So, in most languages, uh, any place that you can  have, uh, a less than operator?  You could put a greater than operator there instead.  So one of our mutation, uh, operators might be, uh,  I if you see a less than symbol, pick one  at random and change it into a greater than symbol  and uh, if we've applied one of those mutation operators,  what we end up with, we call a mutant.  So we have our original programme, which was hopefully good.  We apply.  So in this case, if we pick this rule, we,  um we find a random less than symbol in there,  and we flip one of them into a greater than  symbol.  Uh, and our new programme we call a mutant, uh,  and for a mutation testing package.  Uh, and there's a few out there for both, um,  python and java.  Uh, what we want is a test suite.  Should be able to kill mutants.  So, uh, we look at one or more of our  tests and we say, uh, given the new mutated programme,  uh, do the tests kill the mutant?  I do.  They give a different result compared to the original.  If we do, then we say, uh, the tests, uh,  did kill the mutant.  Uh, if they don't, uh, then they don't kill it.  So here is a simple method that we might test,  uh, in a java like language.  So we have might, um, something like, uh, a moult.  Uh, so just perform as multiplication on two integers.  So it's a It's a a trivial example.  Uh, and you wouldn't actually write something like this, but,  um, uh, we're gonna use it here to look at  what might constitute good or bad tests for that, uh,  and how mutation testing can help us here.  So what if we said, um uh, a test for  my moult method is I think that, um, one times  one should equal one.  Is that an especially useful test?  Well, the answer is no.  Cos we could have mis coded our programme.  Well, or at least there's lots of other tests that  are more informative.  Um, because we could have mis coded our programme in,  uh, numerous ways and still get one for an answer.  So, for instance, suppose we mistyped uh, the asterisk.  So in in python, double asterisk is power.  Yeah, So in in Java, that's not actually a a  valid change you could make in Java.  You end up having to call, um, mass dot power  or something, but let's imagine that, uh, we've got a  language a bit like python.  Uh, where you could make that typo you could type  double star.  Um, in that case, 1 to 1 is still one.  So that's probably not the best test.  Like, if I was wanting to test something, I would  probably choose two prime numbers because lets say you multiply  three and five.  The only thing that you can apply to three and  five and get the correct correct answer is gonna be  multiplication.  So in general, that's kind of a more useful test.  So here, uh, if we applied some kind of mutation  testing to this system, uh, then that's something that could  be picked up.  It would try and imitate the sorts of errors that  programmers could typically make, uh, like changing multiplication to power.  Uh, if our tests do pick up, uh, the, uh  uh, the mutated programme as being wrong, then that's good.  Um, if they don't, then our test suite is pretty  poor.  So what are a few examples of these?  Ah, so pit is, uh, the most popular one I  know of for Java.  So originally, Pitt stood for, um, parallel isolated test.  Um, the python one I know of is actually a  bit easier to use.  So mud pie, um, and there's also mutation tests for,  um say C sharp and rust uh, so for most  popular languages that you choose, there should be some mutation  testing system out there.  Uh, it is quite computationally intensive to do this.  So, uh, remember, what you're doing is you're taking your  original programme, and the longer your programme the the more,  uh the more places there are that you could randomly  mutate things.  So the more mutants you can generate from it And  for each of those mutants, you may be wanting to  run your entire battery of tests or maybe just the  unit tests.  So your your system tests, uh, probably are gonna take  too long, but you might try running.  Um, uh, all of your unit tests for each of  these mutants.  So it is it.  It is quite a computationally expensive thing to do, so  some advantages and disadvantages of it.  So the big one is This can be time consuming.  There might be, uh, lots of possible mutants that could  be generated.  So if you want to get, uh, sort of good  coverage, you may wanna leave it running overnight or something.  And that's typically what people do.  So if people are gonna do, in fact, that's true  for a lot of sorts of randomised testing.  So this counts as a sort of random testing.  Um, uh, so does fuzzing.  Uh, and for both of those, uh, people will typically,  um, leave those running for days or weeks, uh, and  then check to see what's been reported.  Uh, and if you can, uh, it's a good, uh  uh, if you've got access to something like AAA reasonably  cheap cluster.  So, um, u w a u W u a Does,  um, we've got, um so I don't know.  I don't know if, um, high performance computing is part  of anyone's degree here.  Uh, I it's I don't think it's part of the  m i t.  Uh, maybe part of the Oh, yeah.  OK, so, um, what did you which?  Um, which of the systems that u A did you  end up using for that?  Ok, um, so I know there's a there's apparently a  bunch that, um, I've never actually used, but, um, uh,  yeah, if you if you do want to do sort  of, uh, serious or mutation testing, then, um, if you've  got, um, uh, clusters of computers handy, it can be  a, uh, a good time to use them.  So you just farm it out to, uh uh, either,  um, high performance machines or a lot of cheap machines.  Um, another disadvantage is you do need to be, uh,  a bit familiar with mutation testing to understand what it's  telling you.  But it does have some good, uh, advantages.  So, uh, it actually tells you, but it gives you  some idea of how good your tests are.  Um, it'll tell you if you've got weak or ineffective  tests, Um, and it also helps you quantify how useful  your tests are.  Uh, so one thing that you know, one thing that  you might find out is if, um, say two of  your tests always end up giving the same result.  So if, um, when some of the mutants are killed,  um, you've got tests that always correlate Exactly.  You might wonder how useful it is to have those  multiple tests.  Um, so it might be worth looking in to see  if you've got, um, uh, redundant tests.  So I said, uh, in an earlier lecture that, um,  ideally, you know, each test you write, uh, there is  some cost to having a test.  You know, it's an additional bit of software to maintain,  um, so every test should carry its weight.  It should do something useful.  Uh, and so mutation testing, uh, can potentially tell you  problem areas where you might have tests that aren't really  carrying their weight, because you may have.  Yeah.  Two or more tests.  They're always giving the same result.  So maybe they're not actually testing for anything really different.  Um, so a coverage criterion.  And well, so there are coverage criteria for mutation testing.  Um, I will say most people don't really worry about  them too much.  They're usually happy to say, um, uh, express things in  terms of time limit.  So they may say, you know, we can afford to,  um, you know, run mutation testing for a few days  or a week or a couple of weeks, Uh, and  leave it at that and say whatever we end up  finding out at the end of that is enough.  Uh, but for anyone who is interested in, uh, uh,  sort of trying to achieve particular levels of coverage.  Um, so this this level here mutation coverage is sort  of, um, saying for every mutant, there should be some  test that kills it.  So That's a pretty decent level of coverage to aim  for.  Uh, and the amount of mutants killed is called the  mutation score.  Um, so that one?  Yep, that's that's reasonably useful.  That that is probably a good thing to aim for,  uh, these ones potentially, uh, like I said potentially less.  So, uh, people are probably gonna just make do with,  um, having something run for a set time limit.  But you could say, um, for each mutation operator, I  want to make sure that, uh, basically it's applied in  all the places that it can be.  So it says, um uh to create one mutated string  that includes every production that can be mutated by that  operator.  So basically, what that means is, if I've got something  that flips less than signs to greater than signs, uh,  then getting mutation production coverage means it has been applied  to every less than sign in the programme.  So that could be quite a lot.  Um, so that's that's one reason why people might just  say, you know, we'll leave it running for two weeks,  and that will be good enough.  Uh, you could have as a coverage criterion and, uh,  every one of the, uh um every one of the  mutation rules everyone.  So we call them operators.  Mutation operators has been applied.  That's not a particularly interesting one.  Because sometimes we might have, uh, operators that just don't  apply.  So I don't know, we might have some programme that  doesn't have any less" metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="always end up giving the same result.  So if, um, when some of the mutants are killed,  um, you've got tests that always correlate Exactly.  You might wonder how useful it is to have those  multiple tests.  Um, so it might be worth looking in to see  if you've got, um, uh, redundant tests.  So I said, uh, in an earlier lecture that, um,  ideally, you know, each test you write, uh, there is  some cost to having a test.  You know, it's an additional bit of software to maintain,  um, so every test should carry its weight.  It should do something useful.  Uh, and so mutation testing, uh, can potentially tell you  problem areas where you might have tests that aren't really  carrying their weight, because you may have.  Yeah.  Two or more tests.  They're always giving the same result.  So maybe they're not actually testing for anything really different.  Um, so a coverage criterion.  And well, so there are coverage criteria for mutation testing.  Um, I will say most people don't really worry about  them too much.  They're usually happy to say, um, uh, express things in  terms of time limit.  So they may say, you know, we can afford to,  um, you know, run mutation testing for a few days  or a week or a couple of weeks, Uh, and  leave it at that and say whatever we end up  finding out at the end of that is enough.  Uh, but for anyone who is interested in, uh, uh,  sort of trying to achieve particular levels of coverage.  Um, so this this level here mutation coverage is sort  of, um, saying for every mutant, there should be some  test that kills it.  So That's a pretty decent level of coverage to aim  for.  Uh, and the amount of mutants killed is called the  mutation score.  Um, so that one?  Yep, that's that's reasonably useful.  That that is probably a good thing to aim for,  uh, these ones potentially, uh, like I said potentially less.  So, uh, people are probably gonna just make do with,  um, having something run for a set time limit.  But you could say, um, for each mutation operator, I  want to make sure that, uh, basically it's applied in  all the places that it can be.  So it says, um uh to create one mutated string  that includes every production that can be mutated by that  operator.  So basically, what that means is, if I've got something  that flips less than signs to greater than signs, uh,  then getting mutation production coverage means it has been applied  to every less than sign in the programme.  So that could be quite a lot.  Um, so that's that's one reason why people might just  say, you know, we'll leave it running for two weeks,  and that will be good enough.  Uh, you could have as a coverage criterion and, uh,  every one of the, uh um every one of the  mutation rules everyone.  So we call them operators.  Mutation operators has been applied.  That's not a particularly interesting one.  Because sometimes we might have, uh, operators that just don't  apply.  So I don't know, we might have some programme that  doesn't have any less than or doesn't have any greater  than symbols in it.  Uh, so that may not be an especially useful, uh,  sort of coverage to want, but, um, yeah, the first  one mutation coverage.  Definitely useful.  All right, so let's see an example of it.  Um, So let's suppose that we've, uh oh, and this  is taken from, uh, there's a quite a good, uh,  blog post called mutation Testing by example.  Uh, So if any of the terminology is not making  sense, then, uh, I'd say that blog post is probably  quite a good place to look, So let's imagine we've  got a cat door, uh, and it's gonna be implemented  as hardware with embedded software.  Um, we can still test that perfectly well.  Um, so if we can express specifications for how it's  supposed to work, then all our existing testing techniques can  apply.  So one sort of thing that we might have is  a is a user story.  Uh, so for, uh, all the sort of examples of  specifications you might have use cases.  Uh, a more recent one used in agile development is  the user story.  So an example of his u user story is, um,  using my home automation system.  I want to control when the cat can go outside  because I want to keep the cat safe overnight.  So a user story, uh, talks about, uh, something that's  being used.  So some bit of system or, uh, some kind of,  uh, component of the system.  It says, um, something that's more or less like a  a requirement.  So the agile equivalent of a requirement something, uh, some  goal or something that I wanna do, Uh, and what  the what the value is to the user of achieving  that.  All right.  Uh, so let's suppose we've got an interface for our  cat door.  Uh, and, uh, it gets fed a string called Day  or Night, which lets us control the status of the  cat door.  Uh, and other things we can do.  Uh, we've got an accessible method.  So we've got get status uh, so for the control  method, uh, the description here says if day is fed  in, unlock the door.  If night is fed in, uh, lock the door, Uh,  and, uh, the access just tells us is it locked  or unlocked?  Alright, So, uh, here's a scenario that we're gonna test,  given that, um uh, some detector.  So we'll assume that's not the the, uh the the  the bit the component under test here, But, um, assuming  that we've got some sort of day night detector, uh,  and we won't worry about how that's implemented, but assuming  it has detected that it's night time, uh, it notifies  the home automation system, and the home automation system disables  the cat door.  So here is a possible implementation.  We've got our class cap door implements the interface that  we gave before, Uh, and it provides an implementation of  control.  So when it's night, lock it Otherwise, unlock it.  Um, and for our test.  So we follow our normal pattern of, um, a range  So set up our new cat door.  Uh, then we act.  So we pass at night, and then we set up  some kind of assertion, so we expect that it should  now be locked.  So it's a a very minimal sort of an example.  But, um uh, it allows us to write, um uh,  to apply mutation testing to it.  That will run pretty quickly.  Um, so we can start pit.  So pit is the Java mutation library that I talked  about, uh, for a programme this small, it's gonna complete  very quickly.  Uh, it'll have a bunch of mutation operators that that  it can apply.  Uh, here.  So it ended up applying one called r O R  three mutter it generated one mutant, and it killed one  mutant.  So we've got, um uh, 100% coverage.  Uh, so 100% kill rate for the mutants there?  Uh, we've got another mutated here, So void, Method call  mutated, uh, generated.  Two mutants killed them both, Uh, and there will be  more output after that.  Uh, the other thing that pit will produce is it'll  show us, uh, exactly what bits of code got.  Um, uh, covered.  Got executed.  Uh, and what bits didn't, uh, so that can be,  uh, useful.  Uh, and if there's mutants that, uh were generated and  we didn't manage to kill them, it'll tell us about  those.  So, uh, here there are a few that, um, it  created that survived.  So most got killed, so that's good.  Uh, there's a few.  So we've got changed equal to less or equal to.  So that, uh, mutation was applied and something survived it,  Uh, and we've got another mutation operator removed.  Assignment?  Uh, and something survived.  So what is this telling us?  So one of these is, um in some cases, you  can end up, uh, passing something.  So given our existing battery of tests, which weren't very  large, so it was just, like one test.  Um, uh, it's telling us that in some cases, uh,  you could basically get rid of that assignment, and the  tests would still pass.  So that's a gap in our tests.  Um, And what was the other one change equal to?  To less than or equal to?  Ah, yeah.  So, uh, that's saying that it changed, um, uh equals  here so to, uh, less than our equals And things  still survived there.  So that's something to look at as well.  We might want to, um, beef up our tests.  So, uh, one thing that one reason why our tests  are kind of, um Well, our one test here, uh,  is kind of sloppy.  Um, is that we're using a string for something that  really shouldn't be a string.  So programmes that do this are sometimes called, uh, string  typed.  They try and, uh, cram stuff into strings.  Uh, when it's not particularly appropriate.  Uh, can anyone say for this sort of programme here?  So for this interface, uh, string day or night, what  in Java would be more appropriate than a string?  And, um and, um, yeah, um, far better than a  string day or night would be to code this as  an om uh, string allows any number of possibilities to  go in there, uh, all sorts of.  So it does say when day is supplied, unlock the  door when night is supplied or lock the door.  It doesn't say what should happen in other cases.  And, um what the, uh, mutation testing thing is telling  us it is, um, saying something is, uh, just, uh  less than night also ends up being good enough, which  is true.  So it's not a, uh there's not a particularly sort  of, um, tightly designed programme.  That's, uh uh, there's a lot of improvements we could  make.  We should probably change.  We could, but we shouldn't.  Why shouldn't we?  Why not?  Well, what's true and what's false?  When you look at a bull in, you know something's  true and something's false, but it's not very informative.  Whereas if you've got an enum so in, um, you  know exactly what they mean.  You can't be confused.  Uh, if I see, uh, if true, then do something  or other I have to think about.  Oh, so what is true?  It does true mean it is night or does true.  Man, it is day bullying, so stringy typed programmes are  what's called the code smell.  They're they're not great design, But overuse of bullion is  also very bad because bullion mean nothing.  They they inform you of very, very little.  So it's nearly always better to use.  Um Well, uh, it it's usually better to use meaningful  OMs than it is to use a bull.  Uh," metadata={}
 
 
这是个课堂录音，你来说说老师说了什么
page_content="uh, here there are a few that, um, it  created that survived.  So most got killed, so that's good.  Uh, there's a few.  So we've got changed equal to less or equal to.  So that, uh, mutation was applied and something survived it,  Uh, and we've got another mutation operator removed.  Assignment?  Uh, and something survived.  So what is this telling us?  So one of these is, um in some cases, you  can end up, uh, passing something.  So given our existing battery of tests, which weren't very  large, so it was just, like one test.  Um, uh, it's telling us that in some cases, uh,  you could basically get rid of that assignment, and the  tests would still pass.  So that's a gap in our tests.  Um, And what was the other one change equal to?  To less than or equal to?  Ah, yeah.  So, uh, that's saying that it changed, um, uh equals  here so to, uh, less than our equals And things  still survived there.  So that's something to look at as well.  We might want to, um, beef up our tests.  So, uh, one thing that one reason why our tests  are kind of, um Well, our one test here, uh,  is kind of sloppy.  Um, is that we're using a string for something that  really shouldn't be a string.  So programmes that do this are sometimes called, uh, string  typed.  They try and, uh, cram stuff into strings.  Uh, when it's not particularly appropriate.  Uh, can anyone say for this sort of programme here?  So for this interface, uh, string day or night, what  in Java would be more appropriate than a string?  And, um and, um, yeah, um, far better than a  string day or night would be to code this as  an om uh, string allows any number of possibilities to  go in there, uh, all sorts of.  So it does say when day is supplied, unlock the  door when night is supplied or lock the door.  It doesn't say what should happen in other cases.  And, um what the, uh, mutation testing thing is telling  us it is, um, saying something is, uh, just, uh  less than night also ends up being good enough, which  is true.  So it's not a, uh there's not a particularly sort  of, um, tightly designed programme.  That's, uh uh, there's a lot of improvements we could  make.  We should probably change.  We could, but we shouldn't.  Why shouldn't we?  Why not?  Well, what's true and what's false?  When you look at a bull in, you know something's  true and something's false, but it's not very informative.  Whereas if you've got an enum so in, um, you  know exactly what they mean.  You can't be confused.  Uh, if I see, uh, if true, then do something  or other I have to think about.  Oh, so what is true?  It does true mean it is night or does true.  Man, it is day bullying, so stringy typed programmes are  what's called the code smell.  They're they're not great design, But overuse of bullion is  also very bad because bullion mean nothing.  They they inform you of very, very little.  So it's nearly always better to use.  Um Well, uh, it it's usually better to use meaningful  OMs than it is to use a bull.  Uh, so yeah, in this case, we didn't have a  lot of tests.  We only had one test, but we did pick up  some problems with it.  Um, so some problems are kind of, uh, easy to  It's easy to interpret what the, uh what the mutation?  Uh, testing package is telling us.  So in some cases, it's telling us you just need  to write more tests.  Uh, yeah.  So in this case, we had, um uh, it's possible  to, uh, never execute some bit of the programme, and  it still passes all your tests.  So you need to write more tests.  Uh, in other cases.  So it says I was able to change equals to  less than or equals to.  So one interpretation could be we need to write more  tests, but another interpretation could be, uh, we're using the  wrong sort of thing to represent day on day or  night here.  Uh, we're using a string.  Uh, we could get by with kind of a a  less than night, given the the tests and the code  that we've got.  Uh, and, uh, what we should be using here is  an enum.  OK, so that is it for, uh, syntax based testing,  Uh, next week.  So I'll release the, um, the lab for this week,  uh, tomorrow and solutions for, uh, last week.  Uh, like I said, we should have, um, results for  the test.  Hopefully later.  This week.  Uh, and look at, uh, testing, OK, And any questions  about that?  So if you want to clarify sort of production versus  denervation at all and let me know, OK, thank you  so much.  I have another question about Well, because there is a  business programme that will that will then killed the red,  the red be like testing the So we test in  case it, it would be a night that we we  use the the the uh So when this up actually  gets produced, you can actually click on it too.  And if you go putting on the two or taking  shoes, Actually, it's not showing here, but I think it  was that one.  I must have did something, but, um, yeah, I think  that to make friends sort of set this corresponds to  I end up on an assignment so we could drop  the assignment and our test still pass, which is bad.  You know, in the tax did stop on.  If you drop off the if you remove the assignment.  One test.  Yeah.  So?  So the mutation test, from my point of view, is  not for test.  The programme is for the test.  The test case.  That's what I said.  Yeah.  Yeah.  So, yes.  So, um, this is a message to test the Is  it the test test case is That's what I said.  The first one, I said it a way of your  test.  Oh, thank you.  Thank you so much.  See you soon.  Yeah." metadata={}
 
 
