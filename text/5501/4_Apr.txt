OK?

Yeah.

OK.

Ah, Mhm.

OK, let's make a start.

OK, so the, um uh, the Multichoice and short answer

portion of this week's test is out.

Um, and there's a password for that on the l

MS and that, uh, that will close.

Uh, Friday five PM.

Uh, so extra time Because I didn't get it out

till today.

Uh, it should be fairly straightforward as, um as with

most of the tests and quizzes, it should take about

an hour to do.

The long answer bit, uh, is a bit fiddly to

release in mood, but that should be out after today's

lecture.

So, um, I'll put a longer deadline on that.

Maybe, I don't know Sunday midnight or something, but, um,

it also shouldn't take terribly long to do.

There's a sort of there's a scenario to read.

So a question to read?

Uh, you might want to think about it.

You might wanna look at, uh, look at the textbooks.

Uh, write an answer.

Just a a couple of paragraphs is enough.

Uh, and then you're done.

So, uh, once those are all submitted, uh, it'll open

up for reviewing, so you'll get the chance to uh,

Mark.

So So, to review other students answers, uh, and, uh,

give a mark out of 10 and, uh, give a

comment, and that will close at the end of next

week.

Um, so that should hopefully give people a good opportunity

to see what?

Well, to to write an answer to a a fairly

open ended question yourself.

So one where there's not necessarily a wrong or a

right answer.

But there are probably some that are better than others.

Uh, and to see examples of, uh, other people's answers.

So, um, I'm hoping it will, um mean that, um,

yeah, people have more experience with that kind of, uh,

question going into the, uh, exam at the end of

the year.

Um, it yeah, that's probably all I'll say about that.

Unless there's any questions.

Uh, is there anything that, um, people would like to

know more about?

For with that, there's two parts.

Yeah, So there's, um, so won't let me make it

just one thing.

There's, um there's a multichoice and a short answer section,

and that's very similar to what you've done before.

And then there's a, uh, or write a short answer

and the the write a short answer bit.

Uh, I could put it in the in the the

sort of the main test, But the, um, let other

people comment on it apparently means I need to sort

of split it out as a separate thing.

So that'll, uh, that'll go up after after the lecture.

So you said internal time.

So Yeah.

So there's 90 minutes for the, uh uh, for the

multi choice and short answer bit.

Um, so anyone who's got, um, pre-arranged time extensions on

tests or anything?

If you want to shoot me an email, then I'll,

uh, happily arrange those, uh, for the, uh, for the

English question.

So the long answer question.

Um, there's no time limit on that, because there's just

one question you're just paste in your answer and eventually

submit.

Submit it and you're done.

So there's, uh, all of this right to do.

Yeah.

After the review says it is worth 3.5%.

Um, it basically will be, uh, assessed on the, uh

Well, whether you did it, it's worth much to the

marks, uh, whether you gave some sort of comment justifying

it, so I'll put up a a rubric.

But as long as you've got, uh, some sort of

reason, then, uh, we'll assume that it's in good faith.

Um, so it's almost it's almost a free 2.5% But,

um, it would be nice if people, you know, took

it seriously.

Any other queries about that?

So, yeah, the breakdown is, um, five per cent for

the multichoice and short answer bit, 2.5% for the the

long question and 2.5% for reviewing other students answers.

OK, so I think I covered everything in, uh, the

material on graph based testing.

Uh, let's just have a quick quiz at that graphs

for So last week's lab had a sample, uh, programme

to, um, try writing a graph four and their solutions

are up for, uh well, a sample solution up for

that on, uh, the website.

So I wasn't gonna go through the, uh, go through

the example that's given in the lecture slides, but I

did get through.

I think all of this material, uh, in case I

didn't I'll look at the last slide here.

Yep.

So we looked at prime paths.

We said what is a prime path.

Uh, So, um, the idea behind this sort of coverage

level is that, um if you've got prime path coverage,

you should have pretty good coverage of a piece of

code.

Um, sometimes you'll wind up calculating prime paths for a

graph, and they actually, for some reason, can't be executed

at all.

Um, it is possible.

So, uh, reasons are there could be completely dead code

in your programme, So there might be a a section

of programme that, um uh at run time will never

actually be executed at all.

That's certainly possible.

It's usually not a good thing to have.

So if you're coverage, if your tests and coverage have

identified stuff and you've worked out, actually, I have no

way of ever executing that you might want to think

about whether it should be there at all.

One way that, uh, one way that errors can creep

into programmes is you've got code that previously used to

be dead.

There was no way it could be reached something somewhere

else.

Changes that now can be reached has never been tested

and something terrible happens.

OK, so that's one possibility.

Uh, another possibility is, it might just require a bit

of thinking to work out how to write a test

for something.

So here is, uh, Oops.

Where is zero?

Right, that's a bit better.

OK, so, uh, here's a sample.

Sort of a graph that we've got.

You take a look at this.

Uh, You see, there's a There's a loop in there,

so, uh, we've got, um it doesn't really matter too

much what the source code is.

But you see, there is a loop in this area.

It goes C two.

So some sort of a conditional in a loop.

Uh, S three s, four s, five s six.

A bunch of statements, uh, and that will go back

to the conditional.

So you work out alright?

There are a bunch of prime pas there.

There's one starting at C two, looping round and coming

back to C two.

There's one at s three.

It loops around and comes back One at s four

s, five s six.

So every time you've got a loop, you actually end

up with, um uh, a bunch of prime paths coming

out of it.

Uh, and when you run your tests and look for

code coverage and in labs.

We'll see.

Uh, what code coverage reports tend to look like, Uh,

you might discover.

OK, something here is not tested.

So you look at the path, and then you kind

of have to work backwards to execute that code.

So you have to say, Alright, So if I want

to get to these nodes here, what does that condition

have to be?

Uh, and that condition executes after s two.

So that might have some influence on, um What?

The variables are there.

Uh, if I want to get to s two, Uh,

I have to have the right inputs to this condition

at C one.

Uh, so what variables do I have to have there?

Uh, and you work your way back to what the,

uh what?

The code as a whole looks like.

So this is code that operates, uh, uh, on an

array.

It's a sorting routine.

Um, so you sort of have to, um it's a

bit of a It can be sometimes a bit of

a tricky exercise, but you have to um, uh, often

a good way is to, um, feed in, uh, some

fairly standard sort of an input, like the Happy Path

input, Uh, run through a debugger and, um, through a

visual debugger and, uh, step through the code, get a

good idea of how it works and then work out.

OK, So if I want to execute this line and

this line what, um what inputs exactly do I need

to have to my routine, Uh, in this case, uh,

in this case, it's a a sorting routine, and everything

ends up getting exercised, but in general, you can end

up where cases where it's, um not completely obvious.

Uh, what inputs to the function as a whole need

to be passed in to get to some specific spot

in the code, So, uh, it can be tricky.

Uh, other things are.

So I said, if you've got prime co coverage, uh,

that's pretty good.

Uh, should that be a hard and fast rule like,

um, is it good for teams to say?

You know, we insist that there should be, um, complete

lane coverage.

Uh, you know, every lane in the code base should

be executed at some point in our tests.

Uh, we should have prime path coverage.

Um, the answer is, it's probably something that you should

try and aim for, but it's probably not a good

idea to have as a as a hard and fast

rule.

Once you make something a a hard and fast rule,

people tend to aim for that goal and forget about

why they're aiming for it.

So what you really want is, um, good and thorough

tests, so every test should contribute something.

Uh, ideally, you do want all bits of the code

base executed, but, um, yeah, it's a less I.

It's a less good idea to have to sort of,

um, uh, arbitrary benchmarks and say, you know, we must

have 90% or 100% line coverage.

Alright, so we'll look at, um Oh, wait, There was

another slide there.

So, uh, when we're looking at, um, code listings and

control flow, specifically, uh, different sorts of coverage will correspond

to sort of different things about the programme.

So we said you can you can use graph, uh,

graph testing techniques to look at all sorts of things

you can look at, um, activity diagrams, so sort of,

uh, flow charts that show the, uh, interactions between a

user and a system.

Uh, we said you could use them on other things.

So u m l state charts, which we, um uh

we don't look at in any detail in this unit,

but, um uh, there's lots of things out there that

can be represented as graphs, and this works for all

of them.

But for, uh, for code list things in particular when

you say that you've got node coverage.

Uh, what your nodes represent are statements in the code

in general.

Sometimes they'll represent a bit of a statement.

So if you've got a A loop a full loop,

there's actually three parts of that.

It's, um it'll typically look like, um, for entire.

Let's write that out.

So a full loop has three parts.

So occasionally, no coverage will actually be a little bit

bit more detailed than just a line you'll be able

to execute.

Uh, so the I equals a plus one bit will

be executed, uh, 10 times, no nine times.

And, uh, the I less than 10 bit will be

executed 10 times, but the I equals zero bit will

only be executed once.

So if you are asked to draw a uh, a

diagram in an exam question, which I probably won't ask

you to do because they're really annoying to Mark, because

I want us to look at, uh, 80 or so

flo sort of graphs of varying levels of neatness and

work out if they all correspond to some idea ish

kind of an answer.

So we probably won't ask that, but, uh, if we

do, uh, it can be handy sometimes to say I

don't know.

This is line 10.

We'll call that 10 a that 10 b and that

10 c.

So that's something you might see.

Uh, sometimes if people are a bit want to sort

of save space if they've got three statements in a

row.

And they say, you know, either all of those get

executed or none of them do, uh they might just

make all of those statements One node.

Uh, so you might see sort of various variations on

how, uh, graphs of control flow are shown, But, uh,

in general, if a graph of control flow has got

node coverage, uh, it it will be equivalent to saying

every statement in this method or class or entire system

has been executed at least once in the tests.

Uh, and as I said, actually, it's a little stronger.

So something like a four statement, uh, actually ends up

being probably two or three nodes.

Uh, edge coverage means every branch in a condition or

has been executed.

So for if statements, it means we've executed the If

case, uh, if there's a then case, we've definitely executed

that if you've got a switch statement which says, um,

switch on the value of, say, an integer, uh, that

satisfies case one case two, case three.

Uh, then we've executed each of those, uh, so that's

what those correspond to.

But, um, whenever you do see, uh, if statements or

uh, loops that have conditionals in them, it doesn't drill

down into the into the details of what's in the

conditional.

So let's add something here, so I don't know, maybe

we're looking at an array, uh, and we say something

not only about the loop variable so high, less than

10.

Uh, but also something about what cell of the array

we are looking at.

Um, so graph based testing will say, Have we looked

at the case where all of that comes out as

true and all of it comes out as false.

But it doesn't drill down into any kind of analysis

of the the small bits of it, these little bits

that we call clauses.

So that is what logic based testing does, which we

will look at now.

So logic based testing is, um, drilling down into the

internal structure of bullying conditions, uh, modelling the structure of

those conditions.

So the little parts of them and seeing how well

we've exercised those, um it is, um, alright, in in

my experience, it's kind of rare.

I've never actually had to, uh, do do this for

projects, But, um, it does, it does turn up.

It is a sort of a a well accepted sort

of testing.

Um, so logic expressions in general conditionals uh, turn up

all over the place so they might represent decisions in

programmes uh, decisions in a state chart about, um So

we saw you could write a a state diagram of

something like an automatic door, and you have conditions that

say, when should it move to a different state?

So you might have a condition like if a person

is detected by the sensor in front of the door.

The door should open use cases.

So when we're writing out, uh, use cases or user

stories, we might have, uh, conditions that say, when the

user does this, the system should do that.

Uh, so, yeah, you know, that pretty ubiquitous in, uh,

both code and design in software, Uh, they also turn

up in requirements.

So we'll say something like, uh, when a user logs

in, they must fill out, uh, an email address, Uh,

a user name, a password.

The password must satisfy these conditions.

It must be longer than eight letters.

It must contain punctuation.

Uh, so requirements and specifications can contain conditionals.

Uh, and logic based testing is good for drilling down

into those.

And for anyone who's done databases, uh, they also turn

up a lot in, uh, in databases.

Whenever you write, um, select statements or queries.

Those tend to be full of conditionals.

So lots of places, Um, and, uh, as with graph

models, we can assess what kind of coverage we have

of our conditionals and perhaps decide.

Uh, I need to write new tests to make sure

this is thoroughly covered.

Uh, or I can, um uh look at what the

coverage is of my existing tests, uh, and potentially spot

problems in our system.

So we might spot that, Um, uh, bits of those

conditionals have never been properly tested.

We might have written redundant clauses in our logic expression.

Uh, and where this does come in useful is for

some areas in software.

It's actually mandated that you do logic based testing.

So the big one, the big example that, uh, everyone

gives is, uh, aviation software.

So software for, uh, plane navigation systems and that sort

of thing.

Um, those require a stand.

Those in the US.

They have to, um, meet a standard called, uh I

think it's m CDC modified conditional decision coverage or something

like that.

Uh, and that is based on, uh uh, amongst other

things, logic based testing.

Uh, would you do this for all sorts of systems?

Well, probably not.

Uh, as I said, I've never actually used this technique

for software that I've written.

But, um, if you decide, here is some component of

my system that's, uh, especially risky or dangerous or critical

or or I have to, because this is mandated by

legislation, you might say, Well, this component, we're gonna test

extra carefully.

So, uh, yes, we would use logic based testing for

this.

All right, so what do your logic expressions look like?

Here is a sample expression.

Uh, we've got I less than J and C is

alpha.

So we're calling a function, uh, or B or And

we've got an expression, uh, checking how several variables relate

here.

M is greater than or equal to n times zero.

Uh, and the things that this contains are, uh sometimes

we might have bullying variables.

So be here.

It just is, uh, a true or a false or

bully and literals, but there would be no point in

sticking in the word true or false There, uh, we

might have function calls that, uh, return bulls.

So here is Alpha C.

Would return a bullion.

Uh, we might have predicates that operate on values and

evaluate to a bullion.

So, uh, really, these are These are basically the same

as functions, except that they're so common we've given them

their own syntax.

So I is less than J.

Takes in two arguments I and J and spits out

a bullion, uh, greater than or equal to again, takes

out, takes in two arguments and spits out a bullion.

Uh, some languages are very free and loose about what

they consider evaluates to bullion.

So java is very strict.

Java says, um, the only thing that can go in

Uh uh, a conditional expression.

So after an if statement has to be exactly of

type bullying, So the whole thing has to evaluate true

or false, uh, other languages are often more flexible.

So ah, in python python has the notion of sort

of truth and false uh, there's, uh, things that evaluate

to sort of true and things that evaluate are sort

of false.

So in python uh, an empty list.

So python just assumes if you say if and give

it a list, uh, it says, Well, what would someone

want to do with the list?

They probably want to know whether it's empty or not.

So it just assumes that an empty list evaluates, uh,

as a condition to false and a nonempty list evaluates

to true.

So, um, we're not actually gonna be using, uh, Python,

but, um, just a a pointer.

It does make some languages, Uh, a little more complex

in that way.

So, uh, all of these little bits I j c

b m n o we can think of as inputs

to to the expression, uh, they get joined by connectives.

So Oh, sorry for anyone who hasn't seen these before,

these are the mathematical symbols for end, or or so,

uh, the wedge pointing upwards is and and the wedge

pointing downwards is or so in Java, Java uses a

double for and and it uses a double, uh, bar,

vertical bar or pipeline for all.

And, uh, Java has a few other, uh, logic connectors

as well.

Uh, Python, on the other hand, uh, uh, uses, um

the, uh the words and or and not so we've

got our inputs.

We join them with our logical operators, and we get

an output.

Uh, in general, if we've got, say, three.

If we've got only one input to a conditional, then

there's two options.

Two possibilities.

If we've got two, then there's four.

If we've got three, then there's eight.

Uh, so in general, for the number of, um, small

little bits that can evaluate true or false, there's gonna

be true to the end.

Whereas the N is that number, uh, of possibilities.

So, uh, if we wanted to do very, very, very,

very thorough testing of a logic expression, we could try

and cover all of those cases.

So if we've got three variables or 33 bits that

evaluate draw false, we could write eight tests.

Uh, but it does get large quite quickly.

So if we have, um, something with, uh, six bullying

things in it a conditional with six bullying things that

comes out to 64 choices.

And if we've got, um, a few 100 of those,

admittedly, this would be a reasonably complicated looking programme.

Um, often, when you do look at code, you discover

that, um, uh, a lot of conditionals usually only have

one or two or three, uh, sort of bits in

them that evaluate true or false.

So, uh, it's actually reasonably rare in something like Java

code to see a lot of conditionals.

Where you do see, a lot of conditionals, uh, is

usually in database code, uh, and in things that represent,

um, what we call business rules.

So, uh, as an example, I imagine you're writing software

that handles, um, uh, in, uh, income tax.

And people might fall into different categories based on various

questions you could ask.

And, uh, the questions might be things like, you know,

did you earn at least blah, blah dollars?

Was any portion of it tax exempt?

Did you?

Do you have health insurance, et cetera, et cetera.

So in these sorts of business rules, you actually can

end up with very, very, uh, long and complicated expressions.

Uh, but typically, uh, so this isn't a hard and

fast rule, but typically in the sort of, um, code

you see in languages like python or java, the conditions

are usually fairly small, but, um so theoretically, you can

end up with a huge number of tests, and it

would be nice to find out if we could do

with fewer of those.

Uh, so that's what we'll look at.

Um, as with a lot of sorts of coverage, uh,

we can say there is a way of testing this

very, very thoroughly, but it tends to get intractably large,

so you probably don't want to do it.

So we'll look at a way of defining uh uh,

a level of coverage.

That's thorough.

But, uh, doesn't take nearly as much time as, um,

sort of, uh uh, all looking at all combinations of

those, uh, little bits.

So, uh, the little bits, What we're gonna say is

we're gonna call them predicates.

So a predicate is something that evaluates to true or

false.

So this as a whole is a predicate.

Uh, B is a predicate.

I is less than J as a predicate.

Is alpha C as a predicate?

Uh, so there's a big predicate, and it's got smaller

bits of it.

Uh, predicates can contain smaller bits.

So bullion variables, uh, things joined by relations and things

that return a bullion.

Uh, predicates can get joined by connectives.

So here are all the ones we're using.

Logical and logical or, uh, logical, not.

And a few less common ones are which I'm not

planning to use Are, uh, implication Exclusive or so A

Or B, but not both.

And logical equivalents.

Actually, we we can use logical equivalents.

It's just, uh, uh equals.

So equals equals, but between, um, bully and variables, Uh,

and what we'll say for the small bits is will

call something a clause if it's got no connectives in

it.

So that's a predicate.

The whole thing.

That's a predicate.

The small thing.

Uh, I less than J.

But I less than J is also what we'll call

a clause.

It's kind of an atomic, a predicate expression that you

can't get smaller then, so something that contains no logical

connective.

So if we wanna cut the clauses here, we'd say

1234.

Uh, and, like I said in practise in most sort

of hard coded, uh, conditionals in languages like, um, Java

and python, most predicates only have, at most about sort

of three or, uh, four clauses.

Uh, but, uh, things like, uh, business rules.

And, uh, databases tend to have a lot more.

OK, uh, a little more on the the definitions.

So we'll tend to use, um, when we're looking at

something like a A method or a class or a

whole system, we'll say big P is the set of

all predicates.

Little P is a single predicate.

Big C is a set of all clauses uh, C

with a P.

Next to it is the clauses in one predicate and

the little C is a single clause.

So, uh, what are some sorts of, uh, coverage that

we could have here So we could look at, uh,

every predicate.

And, uh, we could say, I wanna make sure I

have tests where that predicate comes out as true and

where it comes out as false.

Ah, but that's actually very coarse grained.

That's actually we've already got that when we did, uh,

graph, uh, graph based testing cos that's just saying, um,

for each place where I can make a decision, Have

I taken each path?

Uh, we could look at the, uh, tiny little bits.

So the clauses within a predicate and we could say,

Have we tested all of those Have I made sure

every one of those comes out to both true and

comes out as false.

But, uh, that ends up, uh, being a very large

number of tests, potentially, uh, so we tend not to

do that.

What we do tend to do instead, uh is the

idea is you want to look at, um, each little

bit of the condition.

So each clause, uh, and you want, uh, that you

test it independently from all of the others, so This

is a bit like when we were looking at, um,

base choice coverage.

We sort of said, um, go through characteristics one by

one.

Uh, keep everything else the same, but vary one of

those characteristics.

This is a sort of a similar idea.

It's the idea that, um we look at some predict

and we go through the clauses one by one, and

we keep all of them the same and vary one

of them.

And what we're aiming for is for the little bit

that we're testing the clause that we're testing, uh, to

actually, uh, make a difference to the value of the

predicate as a whole.

Um, so the textbook a man and off, uh, says

that what we're doing here is we're making each clause

active in turn.

So, uh, it talks about what are called, um, active

clauses.

So if we are looking at a predicate like this,

So let's say we've got, um A is less than

B or D and M greater than are equal to

n times O, let's say we pass in.

We come up with some test values here, so we

say, OK, I'm gonna make, uh, a five and B

10, so that'll come out as true.

Uh, I'm gonna pass in true for D, and I'm

gonna pass in, uh, one for m n N o.

So that will be one is greater than or equal

to one that'll come out as true.

So we've got, um, true here through here and true

here.

But the thing is, uh, since a is less than

five is true because we've got an O here.

Uh, if a is less than five, uh, we never

end up looking at the value of D.

So, uh, in most languages, logic connectives are what we

call, uh, short circuiting.

If I've got, um, a condition that says, uh, a

or B Uh, and let's say maybe they're, um let's

say a is a variable and B is a a

method call.

If a is true.

Well, I know that a or B is as a

whole is always true.

So the language never looks at B.

It never evaluates it.

It never calls the method.

So that would be something like if a in python,

uh, if we have something like a or test whether

something's alphabetical.

If a is true.

We never end up calling.

Uh, is alpha whoops.

So that means that you can pass in values for

some of these.

And some of those values were kind of pointless.

You you haven't sort of done a a thorough test.

Uh, because, uh, due to the values you passed in,

bits of the clause are are never actually tested bits

of the predicate I should say.

So what we want is we want to say, uh

to really do thorough testing.

Uh, whatever, claw.

We should focus on one clause at a time, and

that clause should be the determining factor.

Uh, that tells you the value of the predicate as

a whole.

So we want each clause to Actually, we want a

test where, uh, each clause individually has made a difference.

Then we've got a a pretty thorough test.

Uh, so this is just, um, giving a sort of

a a slightly more verbose, uh, definition of that.

We have a big predicate p.

It's got a bunch of little clauses in it.

Uh, we look at one little clause, call it C

uh, if everything else in the predicate is set up

so that when we change that one clause, Uh, the

value of the predicate as a whole flips.

Then we say the clause determines the value of P.

So the value of the predicate as a whole hinges

on exactly that clause.

And here's the the textbook definition.

So it says, uh, given a clause C I and

predicate P.

We say that it determines P if, uh, it basically

means here all the other clauses have values.

So that changing the truth, truth value of the clause

we're looking at changes the value of the predicate as

a whole.

So that's the the textbook definition.

Uh, it's just equivalent to what I've said on this

slide.

Alright, so simple example.

Uh, let's look at and state and connectives.

So if you've got A and B uh, we wanna

know when will a determine b Well, what do people

say?

When will a determine B?

So in this case, uh, a will determine B uh,

when B is true.

So if b were false, then it wouldn't matter what

we put in for A the value of a whole

would always come out as false.

But when B is true, then the value of the

predicate as a whole does hinge on what we put

in for a So when B is false, the whole

thing is false.

So a doesn't determine the value that when B is

true, uh, then US changing the value of a will

flip the value of the predicate as a whole, so

a does determine the value of it.

So we say a determines the A determines the value

of the predicate when b is false.

So if we were writing a test and we're drilling

down and we want to, um uh, do active clause

testing for a, uh, we need to set B to

true.

And then we'll write two tests.

One where a comes out as true and one where

it comes out as false so a determines the value

of the thing as a whole.

So, uh, clause and predicate coverage, uh, we've said, are

a bit too coarse grained, uh, if we try to

test uh, every possibility for the bits of clauses that

tends to be a little too expensive.

Uh, what is usually considered a good medium is what

we're looking at here.

So it's called active clause coverage.

So we basically, uh, look at a condition.

So a big predicate, uh, we kind of go through

each of the little clauses that makes it up.

And in turn, we say I'm gonna test this one

clause.

So I need to find values for all the other

clauses.

Uh, that will make, uh, this clause that I'm testing

determine the predicate as a whole.

Uh, there is and ambiguity about active closed coverage, which

I'm actually not going to go into, Uh, because I

think it's kind of a bit, um it's a fairly

obscure kind of a case.

Uh, I'll, I'll leave the slides there for anyone who

does want to, uh, read through it, and it's covered

in the textbook.

Uh, but, um, there's a sort of a, uh, an

obscure case when, um, people can write tests which, uh,

technically satisfy active clause coverage.

But if you looked at them, you'd say that's a

pretty poor test.

Um, and so technically, the flavour of testing that we're

using is something called, uh, restricted active clause coverage.

But, um, uh, I am just gonna assume that what

most people come up with will probably be the right

thing you sort of have to, uh, almost deliberately do

the wrong thing for it to make a difference.

So we will, uh, not cover those slides.

Um, so where this comes up, as I said, uh,

it turns up in, uh, uh, aviation software, Uh, in

a a standard for testing called modified condition decision coverage.

M CDC, uh, which is considered to be, uh, very

thorough.

Uh, coverage of a bit of software.

Uh, it mandates that every entry and exit point, uh,

to a, uh, procedure or functional method has to be

invoked.

Uh, every decision takes every possible outcome.

So that's equivalent to, um, uh, What we call brunch

or edge coverage.

Whenever you see a conditional you have to take, uh,

your tests must have exercised both paths.

Uh uh, every condition in a decision.

It takes every possible outcome.

So what they mean by condition is what we're calling

a clause.

So it's a a small little bit of a bully

and expression, so that's equivalent to clause coverage.

And, uh, each condition is shown to independently affect the

outcome.

So that's equivalent to what we're calling active clause coverage.

Um, if you had, um a bit of software where

all of your, uh, conditions only had one clause in

them.

Uh, logic expression.

Would logic testing would be superfluous because the whole point

is to kind of drill down into the the clauses

within, uh, a logic expression.

Uh, so if they all only contain one clause, uh,

it adds nothing.

So it's no better than, uh, graph testing, say, uh

so when a predicate only has one clause, uh, all

the sorts of logic testing just collapsed down to predicate

coverage.

Uh, and as we as we've said, um, that turns

out to be the same as edge coverage for a

graph.

All right, so, uh, logic testing, uh, can be like

graph testing.

It can be kind of tricky.

Um, it doesn't necessarily sound that hard.

So, you know, we we look at a an an

expression.

We go through it clause by clause.

Uh, we say, um alright, I wanna test this clause.

So here's what I have to set all my other

clauses to to get that, uh, but then you remember,

Um, uh, we actually have to get to that line

of the programme first, so we have to actually, uh,

reach that statement.

Uh, depending on what sort of things we feed into

where the method or, uh, procedural function that we're looking

at.

Uh, So, again, as with graph based testing, uh, this

is often an exercise in, uh, starting in the middle.

So saying here's what I want to test and working

backwards, you say so in order to test, uh, in

order to thoroughly test this condition I've come up with,

Um uh, these test values.

Now I have to work out.

Um uh, What?

I need to feed into the method to get to

that point in the programme with the right test values,

so it can be tricky.

Uh, remember also that we can take, Um uh, we

don't just have to do logic based testing on code.

We can do it on specifications or requirements.

Uh, anything where we've got, um, various sorts of complicated

conditionals.

So, uh, specifications are a good place to, uh, look

for things.

Uh, like I said, if you have something like, um,

uh, a system that did, uh uh, income testing income

tax.

Uh, assessment.

Uh, you wouldn't necessarily even have to look at the,

uh, the code to come up with tests for that,

uh, the specification of what the software was supposed to

do, uh, would already have usually, uh, a very large

number of, um, predicates in it.

So specifications.

Sometimes we'll write them fairly informally.

Uh, sometimes we'll write them, uh, a bit more mathematically.

Uh, but nearly always, they do include logical expressions.

Uh, and often when you do turn things when you

do take, um requirements written in natural language and you

start to, um, uh write them out as mathematical notation.

Uh, you do often discover, uh, either ambiguities or vagueness

or mistakes in the requirements, so specifications are a very

rich source of predicates.

So here is an example requirement for something.

Uh, let's assume, uh uh, some it's a It's a

requirement for, uh, uh someone who apparently, uh, has a

in a dungeon somewhere.

Uh, and they've got this conditional, uh, for the door

to it.

It says release the monster when the sky is clear.

In addition, the moon must be full and all the

wind calm.

So if we were to take that natural language and

rewrite it as a logic expression, uh, we end up

with, um, a few things to represent clauses in that.

So we would say Let m b the moon is

full.

So a boolean expression there.

Where s B?

The sky is clear and w b the wind is

calm.

Uh, so we can model the predicate as a whole

as, uh, s So the sky is clear, Uh, in

addition means that we have an end.

Uh, the person is used, uh, and slash Or so

they mean, uh or there m o w.

If they just use the word or, uh, we might

have to think about Do they mean inclusive or, uh,

or do they mean exclusive or so this or this,

but not both.

So natural language, uh, in natural language or is, uh,

a bit ambiguous.

It's not clear whether it's inclusive or exclusive or but,

uh, here we know that it's inclusive.

So, uh, our predicate is s and m o w.

Alright, so it is almost four, so I will break

for a wee bit.

Let us come back at five past four.

So, uh, that will give time for people to grab

a drink or anything if they want.

OK, OK.

I'm sorry.

Um, could you explain to me what I to be

as small as I thought it would be?

Wouldn't be true.

That is probably a mistake that's been there for several

years Now, Can you maybe email me and point out

that because I obviously ignored my note to myself from

last year to fix that?

Because I'm pretty sure I remember writing that down, and

I still haven't fixed it.

64, right?

Yeah.

Yeah, OK, now.

So OK, five passed, so I'll start again.

Um, it was pointed out to me that there is

a, uh, mistake on slide 25 which actually was also

pointed out to me last year and obviously hasn't fixed.

Haven't fixed.

So the line down the bottom here should have said,

um, a determines p when B is true.

Uh, so the last the second last line on the

slide is the opposite of what I actually said.

So, uh, uh, I will fix that and, uh, upload

these again.

All right.

OK, so, uh, I will I'm going to step through

an example of, um, how we'd apply active clause coverage

to testing.

Uh, the sample, uh, predicate uh, from the requirement we

looked at.

So we modelled that as s and M or W

uh, so I'm just gonna step through that as an

example and talk about, um a If you're doing this

for a test or a project or something, what would

be the best way to, um, give your answer?

So first of all, um, if we're asked to come

up with tests that will satisfy active clause coverage, uh,

then we start by saying, Well, we've got to step

through the clauses one by one s, uh, M and

W is usually easiest to tackle them in exactly that

order.

Uh, that makes it clearer to your readers what you're

doing.

And if someone is mocking it, uh, it makes it,

uh, was she clearer?

What bits of your, um, working correspond to what, Uh,

so we'll make each one active in turn, and we'll

have to come up with values for the other two

clauses.

Uh, that will make our active clause determine the predicate

as a whole.

Uh, and then we'll vary the the the clause that

we're looking at, and we'll get it to come out

as true and as false.

And then we've got two tests.

All right, sir, To make s active.

Uh, it's joined by an end, so we need, uh,

m or w to be true.

So we just need to pick values of M o

w of m and W That will make m o

w true.

So, uh, anything is fine there.

Uh, let's choose m is true and w is false.

Uh, that'll come out as true.

And that will mean that s is now active.

So, uh, given that we set m to true and

w to false, the value of s now determines p

so we can say, Alright, I have a test.

Uh, I have, um I know how can have two

tests, uh, based on making, uh, s active.

Uh, in both cases, I'll, uh, choose er m equals

true and w equals false.

Uh, and they'll vary in that.

I'll have a test where s equals true and another

test Where s equals?

False.

So usually the best way to write all this out

is to put it in a table.

OK, so, uh, this is just a suggestion.

Um, if you can think of another way of sort

of writing this out clearly, then feel free.

But I'd suggest that, uh, if you're answering questions like

these, you put stuff in a table, you say something

like, um, in the first column, let's put our active

clause and call the second column.

I don't know, test details or notes or something like

that.

Uh, say, uh, what your working is so what your

reasoning is.

So to make us active, we need this to be

true.

So let's set these values and then you'll end up

with two tests.

Uh, so just give the, uh uh the test values,

uh, that you'll need for each of those two tests.

Uh, if we want to make him active.

Uh, so on the outside here, we've got an and

so we want s to be true.

Uh, otherwise the M or W bit will never get

looked at.

So we know we have to set to true, uh,

for an a statement.

It's the other way around.

If we're focusing on him, we need, uh, w to

be false in order for M to influence the value

of the predicate as a whole.

So we now know what the other clauses have to

be We need, uh, s equals two w equals false.

That will mean that M determines the value of P.

So we'll get two tests, uh, based on making m

active and finally, uh, if we want to make, uh,

w active.

This is pretty similar to, uh, making m active again.

We'll wanna make s true, Uh, and as a kind

of mirror image to the last case, we'll wanna make,

uh, m false.

So s must be true.

M must be false.

And then w will determine the value of p.

So again, we'll end up with two test cases, uh,

based on making w active.

Ok, so, uh, here is a sample of the tests.

Like I say, I'd probably put a I probably wouldn't

write this out in exactly this format for, uh, something

like an exam question.

I'd kind of leave space for working, but, um uh,

in general, uh, what you want is you want, um,

to make sure that it's obvious what's being made active,

at least So, uh, in this you've got a test

description, so it says make s active M then w

and each of the cases there.

Uh, there is a list of, uh, what the inputs

are.

And there's an expected output, which is fair enough because

for any test case, uh, we want to know, um,

what behaviour it is that we're looking for.

So monster is released or monster is not released in

each case.

OK, so that is, uh, logic based testing.

What I will suggest is, I will, um, So we'll

go on to syntax based testing the next, uh, the

next topic.

Um, while I'm bringing the slides up, just, um, have

a think about whether there's anything in the logic based

stuff that, uh, is unclear or is not making sense

or something.

Uh, or you've spotted another error in my slides.

Uh, because, um, yeah, I'm happy to sort of look

at this in more detail, if needed.

And there will also be, um, uh, lab or mood

based exercises on this.

Ok, All right.

Any, um, any queries about the the logic based stuff?

OK, so syntax based testing, um, actually, for um, for

all of the topics of, um, uh, syntax based testing

and graph based testing and so on.

Um, I'd say it probably uh, is a handy I

handy idea to, uh, make sure you keep some sort

of notes on, um, definitions or rules or symbols that

we're using, Um, so that they're easy to refer to.

So looking at grammars and syntax, these are actually a

lot more common than you might think.

So, um, one place that they turn up is when

you're looking at formats for, uh, inputs or outputs things

like dates or, uh, uh, email addresses or, uh, user

names.

Um, all sorts of those, uh, all sorts of things

like that whenever you see a requirement like, um, dates

should be in the format.

Four digit year, two digit month, two digit day.

Uh, we're making use of a grammar.

So it's a set of rules about, um, what sorts

of strings are valid or invalid.

We say that So according to the definitions we're gonna

look at, uh, we basically say that, um, a rule

like this defines a very little language.

Uh, and it specifies what strings are in that language

and what ones aren't.

So we'll say the strings in the language are valid

and the strings outside it are invalid.

So when you see something like that?

So, uh, it's quite common when you're writing, uh, database

queries.

Uh, they'll often say that, uh, there's some way of

expressing, uh, dates.

So if you ask for, I don't know, all student

enrollments after such and such a date.

Uh, any database that you use like s Q light

or Oracle or my SQL or something, uh, will have

some sort of rules about how dates are expressed in

SQL queries.

Uh, and they might say something like this.

So y y y y MD, uh, What they mean

there is any of the Ys or the m's or

the DS can be replaced by a digit in the

range 0 to 9.

So they're describing what we're gonna call a syntactic rule

about, uh, what makes, uh, a date valid or invalid.

So the simple rule they've said there is any of

these can be replaced by, uh, a digit in the

range of 0 to 9.

There's a difference between, um, what tends to be called

syntax errors, uh, and what tend to be called, um,

semantic errors or semantic constraints.

So, in syntax based testing, we're looking at, um uh

the first sort, so things that you could describe as,

uh, syntactical constraints.

So they're basically, uh, fairly simple ways of describing things

like dates.

So we say here, each one of those can be

can be changed, uh, can be replaced by a digit

from 0 to 9.

Um, when you're trying to decide if something is a

valid date, whether it's syntactically right is just the first

step.

So if someone put a A Z or a Q

or AD somewhere in there, then that's, um, that's failed

the first step.

It's not even syntactically right.

It couldn't possibly be a date because we expect digits

to go there.

They might pass that step.

Uh, but it still might not be a sensible date

because we might have said something like, I don't know

the 45th, uh, so it might say, uh, 2023 11

45 the 45th of November.

So that's also not a valid date.

But it's not that it's invalid because of the what

we'll look at here.

The syntax rules.

It's not that someone's put something in there.

That, uh, isn't a digit.

It's just because, as it happens, there is no such

thing as the 45th of November.

So, uh, syntax based testing looks at these, uh, simple

rules that describe, uh, syntax errors or syntactic constraints.

Um, there are other sorts of more complicated things that

it doesn't look at, and they're called, uh, the semantics

or semantic constraints.

Uh, so it gives an example here, Uh, one is,

uh, so something that, uh, syntax is the syntax, as

we look at come to express is, um, saying, uh,

if the first M here is replaced by a one,

uh, the second M here can only be in the

range 0 to 2.

OK, so, grammars give us a way of saying that,

um, something is, uh, either syntactically correct or not.

Uh, and every grammar describes, uh, a sort of a

a language.

Sometimes it's a very little language, and sometimes it's not

a necessarily very interesting one for a set of acceptable

strings.

So for the date, here's what our grandma might look

like.

So, uh, a grammar is made up of rules.

Each one of these things here will call a rule.

A rule has got a left hand side and a

right hand side, and this colon colon equals in the

middle.

Uh, and you can read it as, uh, you can

read that colon colon equals as meaning something like is

defined as or can be replaced by.

So this says, uh, digit can be defined as 012

et cetera, et cetera.

Up to nine.

So digit is one of these sort of literal strings.

Uh, and then this rule says that date can be

defined as four digits, a dash, two digits, a dash,

and then another two digits.

If you are writing these for, um hm, if you're

writing these to be automatically checked by our programme, uh,

then it may also have some rules, uh, that you

need to think about about where we space goes.

We'll usually tend to be, um, a bit sort of

sloppy about white space If, uh, we're writing these for

other people to read, but I'll, uh, I'll go into

that later.

All right, Uh, for any one language or any one

grammar, there's always, or nearly always multiple ways of, uh

of expressing it.

So, uh, every grammar defines a set of strings that

are valid, and it says all the other possible strings

are invalid, but there's multiple grammars that will all come

out as defining the same language.

So here's one that is exactly equivalent to the last

one.

But, uh, instead of two rules, it's got 12345 rules.

So it's still got a rule defining a digit.

Uh, but it also breaks down a bit what a

date is.

So it says a date is year hyphen month, hyphen

day.

And it's got, um, uh, then definitions for what?

A year, a month and a day are.

So it's exactly equivalent to the last one.

Uh, but it gives a a few more hints to

the reader as to what the intended meaning of those,

uh, bits of the, uh of the grammar are so

the syntax or the notation that we're using here is

something called back now form B N F.

So, as I said, the dot dot equals means is

defined as or can be expended to.

And the single vertical bar the pipeline character, uh, means

or so, um also things on the on the left

Here, uh, so things that can be expanded, uh, always

have angle brackets around them.

Uh, and normally, when we come down to the, um,

sort of the very bottom level, so things that can't

be expanded anymore uh, we'll usually put those in quotes.

So their literal strings, uh, the things in strings, the

bits in strings are what we call, uh, terminal symbols.

So they're things that can't be expanded anymore.

Uh, terminal in the sense is sense of you've got

to the end.

Uh, so they're a bit like the equivalent of words

in our language.

Uh, there sometimes called atoms, Uh, in that they're the

smallest, indivisible parts of our language.

Uh, here, each one happens to be a character, but

they don't have to be.

So if we wanted, uh, if we wanted to write

a grammar that describes all the ways that you can

run the docker command, uh, then the, uh, literal string

docker might be one of the atoms, one of the

terminal symbols in our language.

So, in other words, you don't go any further.

You don't analyse docker or look into it.

Uh, that's as far as you go.

Damn right.

OK, so when you're invoking a command like docker, uh,

you give the name of the command.

So Docker and then a subcommandante might be something like,

uh, list things that are running.

Uh, actually, no, I think it's called, um, list available

things to run.

Uh, it is called something like images list things that

are running.

It's called P s.

There's a whole range of, um, possible sub command you

could give, uh, and each one of those is a

terminal in our language, so we don't analyse it any

further.

We just say that's the string.

Uh, if you are typing this, they'd actually be, uh,

a bunch of white space going that could that would

go between, uh, particular terminal.

So you'd type docker, then space, then a sub command,

Um, something like B N f if you're using it

and you wanna make a change to, um, what the

notation means, then you should do so.

If you're the one writing a specification for a grammar,

Uh, then you can feel free to say, after every

terminal, uh, there's compulsory weight space.

One or more spaces.

That's fine.

You can say for my purposes modelling the modelling, the

dock, a command.

I I have no interest in white space.

I just know it's got to be there.

Uh, so you can you can say that you can

say, uh, after every terminal, assume that there's one or

more white space characters and we're just not gonna model

them as part of the grammar.

That's fine.

So that's why I said, um, for some purposes, you

might, um you might want to be a bit kind

of, um, sloppy in your treatment of white space.

Um, if you write something to, uh when you come

to writing tests to, um, uh, actually test the grammar,

uh, you'll have to sort of translate your sloppy version

into, um uh, more formal tests.

Uh, but that shouldn't be an issue.

OK, so here we've got, um, our five rules of

the grammar we've said, uh, the bits in, uh, quotes

are terminals are the bits between angle brackets are what

we call non terminals.

So those are things that can be expanded.

Uh, and each of the big bits that has a

left hand side and the right hand side, uh, is

a rule.

Uh, the textbook calls each of these.

It doesn't call them rules.

It calls them productions.

Uh, that is I think that's slightly unusual terminology.

Um, normally, I've seen production used to mean, uh, something

that is on the right hand side and potentially is,

um, sort of combined with other things as an or

so it's a, um it's one of the options on

the right-hand side.

OK, so that's the terminology that we'll use, Uh, and

in all the sorts of grammar that we're gonna consider,

every rule is non terminal on the left.

Uh, our colon colon equals so is defined as And

then, uh, sequence of terminals and non terminals.

Uh, and you might put them straight after each other.

Uh, or you might join them with oars.

Uh, so technically, this, um, this class of, um, syntax

that we're looking at, uh, this is an exam, but,

um, they're called, um context free grammars.

Uh, and they're probably the most, uh, common sort of

grammar for defining syntax of programming languages.

So when uh, some kaya says, uh, you've made a

syntax error.

Uh, usually, it's relying on, uh, this sort of a

grammar to define, uh, what makes us in tactically valid,

say Java programme.

And what doesn't so context.

Free grammars are, uh, the most common sort.

Um, and usually if you come up with a language

that, uh uh doesn't have a context free grammar describing

it people will tend to say your language is, uh,

uh, overly complex to pars.

So C plus plus is, uh, one of the languages

like that.

So, uh, when you try and compile a java programme,

uh, sometimes the errors you see will be syntax errors.

So if you, for instance have, um, left off a

brace, uh, right, curly brace from a class, Uh, that's

a syntax error.

So there's a a very, very big grammar like this

defining the Java language.

Uh, and if you leave off a, uh, an ending

brace that gets detected by this, um, uh, it gets

detected as falling outside of, um outside of the grammar.

Uh, other sorts of errors that the Java compiler will

give you, uh, aren't syntax errors.

They're what we call semantic errors.

So, for instance, um uh, the fact that you're using

a variable without initialising it or or without declaring it,

um is a semantic error.

You can't write a grammar that detects it, but the

PSA.

So it's an additional constraint that, um, Java will, um,

use when analysing your programme.

So a little more detail, uh, on the right hand

side, one thing you might have is just a a

sequence of terminals and non terminals together.

So here we have date, which is composed of year,

then a terminal month, another terminal and day, Uh, or

you might have, um, vertical bars to indicate.

Or and there's a couple of other things that you

occasionally might see So you might see an asterisk, which

means a zero or more of the preceding thing.

So let's see an example.

Um, so the vertical bar we've already seen.

So if we wanted to say something can be expanded

to dog or cat, we'd use the vertical bar, Uh,

a star after a literal means.

A zero or more of that, uh, we can put

the star after anything.

We could put it after, uh, a literal after a

a non terminal.

Anything we like, uh, plus means one or more.

Uh, a short hand that you often see is a

hyphen.

So it's sort of leaving it to the reader to

fill in.

We might say, um, zero through to seven.

Uh, the reader is supposed to know that that just

means, uh, all the digits from 03 to seven inclusive,

uh, and we can use parentheses to group things, so

this might seem like a lot to remember.

But in the labs, uh, there's an online tool that

lets you, um, work with grammars.

Define your own, change them, see how they operate.

Uh, and it's a lot easier to, um, remember these

when you've had a chance to play around with them.

OK, so let's see an example.

Um, one thing that you often find in programming languages

is some sort of a a syntax rule for what

makes a valid identifier a variable name, uh, a variable

or a method or a function name?

Uh, you usually can't have just anything that you like.

So, for instance, in most languages, uh, you can't have

hyphens in your variable name.

Uh, co hyphens will get interpreted as a minus.

Sign some languages.

You can So, uh, lisp and scheme and closure.

I think, uh, will let you put high in variable

names, But, uh, most languages don't, uh, most languages won't

let you start a variable name with a letter, Uh,

with a a digit.

So the rule for, uh, many modern languages is, uh,

the first thing in a variable name can't be a

digit.

It has to be either a letter or an underscore.

Uh, everything after that, uh, we can have zero or

more of letter or underscore or digit, and we define

digit and letter and underscore in the typical sort of

way.

Uh, occasionally, you'll be allowed to put a few other

things in, so some languages let you put, um, uh,

single quotes in variable names.

But, um, this is probably the most common.

So this syntax says an identifier starts with a letter

or underscore, and it's followed by any number, possibly zero

characters drawn from the set of letters, digits and underscore.

So, uh, said, uh, grammars turn up in a lot

of spots where you might not think about them.

Uh, one very common place is, uh, when you're validating

entries for Web forms or databases.

Nearly always, you've got, uh, some idea of what a

valid name or user name or email or something like

that.

Uh, what a valid entry could be, uh, and, uh,

you'll often end up defining a syntax to represent that,

uh, you may not have thought that was what you

were doing, but that that is effectively, uh, what validation

does.

So one place where syntax based testing comes in useful.

So this is, um I gave the example of the,

uh, the docker command used for running docker containers.

Uh, a Z is the command, uh, for running, um,

virtual machines in, uh, Microsoft's azure cloud computing system.

Um, so it's got a command A Z, uh, after

that, come a whole heap of sub commands.

So there's like, um, a Z account for checking.

Sort of what the details are of your, um uh,

budget or account with, uh, Microsoft.

How much has been spent on running virtual machines?

Uh, configuring applications.

There's, I think many dozens of these sub commands, uh,

and each the command as a whole.

What you can validly type.

Uh, you can define using a grammar.

And in most of the programmes that you've written so

far, if you ever had to analyse, uh, arguments passed

in, uh, at the command line.

Uh, you've probably just done it by hand, so you

might have written programmes that say, you know, the user

should invoke this programme and give, uh, the name of

a file to read, or maybe the name of a

file to read and, I don't know, a number of

lines to read.

Uh, so often for simple programmes.

Uh, you just, um, analyse those arguments by hand.

You say I'm expecting two arguments.

If there's less than two or more than two, give

some kind of an error message.

Look at the first one.

Uh, we'll assume that that's a file.

Look at the second one.

We'll assume that that's a number.

So that works for simple programmes for things like docker

or azure that have got, uh, hundreds of sub commands,

usually dozens of different sort of flags that you can

pass in, uh, altering the behaviour of those sub command.

Um, it's far too labour intensive to analyse those by

hand.

Uh, we usually use what's called a command line argument

parsa, uh, to work out whether a user has supplied

a valid set of arguments and what to do with

them.

So now the details of how you use one of

those command line passes, um, varies a bit, but, uh,

in general you're doing something pretty much like what we've

seen in the grammars.

You're saying?

Well, you usually leave off the first thing because you

know what programme you're running.

Uh, but you'll say something like, uh, I think the

first argument should be a one of some list of

strings that I've got here.

Uh, you might say if I know that the the

first argument was images.

Uh, then here's what the rest of the command might

look like.

So you'll end up coding something like one of these

grammars.

Uh, and the programme that we play around with in

the labs will, uh, uh, show you how you can

do that.

So validation is, uh, the big place where we use

this, um, emails, HTML pages, email addresses.

All of those have syntax that go with them.

Uh, sometimes, uh, so another example.

You might not make use of this in your, uh,

career, but some people do, uh, is for effectively writing

your own languages.

So sometimes you've got a programme that's complicated enough that

you need to write your own custom format for what?

The input looks like.

So make files are an example of that, uh, for

anyone who's seen them, Uh, make files are, um, files

containing rules that say how to build your software.

So, for instance, they say things like, I'll leave off

the details, but they might say, um, my programme is

made up of class files.

Uh, to get a class file, you need to compile

a java file, uh, to get, uh, to compile it.

You, uh, run the command java.

And then there's a little, uh, bit of syntax to

say.

Exactly what order the arguments to Java C come in.

So, uh, this is an example of, um uh, a

make file is, uh, a custom file format that someone

had to come up with.

So it turned out to be, uh, very useful.

And every language has, uh, some equivalent of it.

So in Java, uh, people often use, uh, gradle.

Gradle is the programme that they use for defining.

Um, how a bit of software is put together.

Uh, it's also used for, uh, android apps.

Uh, they use Gradel as well.

Uh, programmes in, uh, sea and C plus plus use

this make file format.

Um, so occasionally you'll come across a situation where, uh

you have to invent your own new file format.

And, um, knowing how to do grammar based testing is

extremely useful if you ever need to do that.

So how are we going for time?

Um, usually in software development, Uh, we say simple is

best.

If someone already has a file format that I can

use, I should probably use that.

So if I, uh, if I need a format for

a configuration file, I should probably use a format that

someone else has, um, already come up with I should

use make files.

Or, uh, for people who've done any Web programming, you

might say my configuration file will be written as Jason.

So JavaScript object notation.

Um, so, uh, if there is an already existing format,

usually the best solution is to use that, uh, but

occasionally that will end up being, uh, not really fitting

our needs.

You might need to write your own custom format.

Uh, and syntax based testing, uh, will let you ensure

that your new format works the way that you think

it should.

OK, it is 4.

48.

So almost 10 2.

So I will finish there, and, um, we will finish

off grammar based testing after the break.

So, uh, have a good break.

Hopefully, you don't have too much work to do, and

I will see you.

Uh, yeah.

Week seven, right?

Yeah.

So yeah, Mother, that would happen.

Trouble Hospital four.

You still is.

OK, say 80 big time.

Yeah, OK, you right The time.

Then sometimes you get water because we have a 100

not publish said country, right?

