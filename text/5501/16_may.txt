OK, all right.

I will make a start.

So first of all a few things about the, uh,

the project, Um, so I extended the due date a

bit.

That's due next week.

Uh, Thursday, five PM.

Uh, so submit via mood.

I'll be opening up a final submission area.

The reason it's different from the sandbox is, uh, if

we've got a question that's like with, um, four marks

and there's two marks for coding and two marks for

style and clarity.

Uh, Myrtle makes me do those as, uh, two questions.

So I would have had to insert a bunch of

pointless questions there.

So I'll be, um, opening up the final submission area

either this evening or tomorrow.

Um, so there will be three or four questions that

you don't need to submit anything for.

It'll just say, leave this blank.

Um, if you do, leave it blank.

Mood does, uh, issue a warning.

And it says you have unanswered questions.

Uh, if you want, just type anything into those, um,

and it'll stop warning you, so that will close Thursday

at five.

PM.

Um, I also had a few comments about queries I've

had via email or on the forum on topics that

people seem to be misunderstanding.

So first of these is preconditions.

So, uh, I've said this multiple times and I've said

I'll ask questions about it, and I and I've said

you'll get very poor marks.

Uh, if you say something that contradicts this, But, um,

if a precondition is violated, there's only one thing that

follows from that and that is that the behaviour of

the code for which that's a precondition.

Uh, it's, uh its effect is undefined.

It has undefined behaviour.

You cannot say anything about it.

You can't say anything about it.

You can't test it.

Uh, you can't say it's good or bad.

It could do anything it likes.

It could delete your hard drive.

It could launch missiles.

Uh, you can't complain.

The responsibility for obeying preconditions is on the colour of

the code.

Uh, if you write any answer to any question in

the project, which claims a precondition is something else, you'll

get bad marks.

OK, so I've I've said it multiple times in previous

lectures.

I reiterate it again so that no one is surprised,

um, for partitioning, um and well, for all of the,

uh, English language questions.

Make sure that you proofread your work.

Make sure that it's spelled correctly.

Make sure that it's grammatical.

Uh, you're welcome to say the library has, uh, uh,

workshops and help available for people who want assistance writing

English essays.

These are essays.

They're very small ones.

They're like 500 words, But, uh, they are essays.

Uh, so they have to be in correct English.

Or you will not get, um, full marks If you're

talking about partitioning.

If you're talking about a a characteristic, you have to

actually tell me what the characteristic is.

You can't just say my partition is I don't know,

things called Alice and things called Bob.

That's not a partition that doesn't demonstrate that, Um, whatever

you're partitioning on, uh, your your partitions cover the cover,

the universe cover the scope of that, that parameter, and

it doesn't demonstrate that they don't overlap.

Maybe someone is called Bob Alice.

They have both names.

You have to tell me what the characteristic is.

OK.

In an English language sentence, you could say I am

partitioning the parameter name by value of name or by

first letter of the name OK, so that's what partitions

should look like.

And you've seen a bunch of them in.

Um, we'll have some lectures.

So and there's many, many more in the man and

off textbook.

So, um uh, yeah, you have lots of good examples.

Uh, make use of them, uh, when you're justifying an

answer, if you say we won't do this because it

would be very be a lot of work, I won't

believe you.

OK, that's not a good reason.

Uh, there's no reason for me to take your word

for the fact that something is a lot of work.

You have to put some some numbers behind it.

Alright.

So, uh, people in the past have said things like

this approach to testing would be infeasible because it's a

lot of work.

And I've said, actually, you'd only have to write three

tests.

So, uh, if you don't justify your answers, there's no

reason for a market to actually believe what you're saying.

Uh, you if you say something is infeasible, tell me

how infeasible you you would.

You have to write millions of tests, trillions, an infinite

number.

What is it?

Uh, because if it's only 100 then, uh, I'm not

sure.

I'm gonna believe that it's infeasible.

You know, uh, I might say it's a lot of

work.

It might not be worth the effort, but it's not

infeasible.

So that's justifications.

Um, the other thing is that, um if you are

having trouble with any project questions, uh, or concepts relating

to them, you should be asking about them, uh, in

labs and lectures.

Uh, the last lab is this week.

If you don't ask, uh, you will just have to

tackle the project on your own without assistance.

Uh, because I I don't cover lecture topics via email.

Uh, and I've got, uh, limited meeting times available.

So, uh, if you leave it till next week and,

uh, you are still confused about something and have trouble,

then that's just the way it's gonna be.

So, uh, I will talk a bit about specification languages

today, and, uh, and we'll probably have a short break

around for, um, if there are questions relating to the

project, I might get people to ask them, uh, you

can ask them during the break and I'll answer them

after, or I'll get people to ask them uh, just

after the break, Uh, and we'll see how we go

with this material.

OK, so there are a bunch of specification languages in

the world.

Um, and there's at least a dozen that are kind

of popular.

Um, there is actually a a blog post last week

about, um, some of the the five or seven most

popular.

And I'll put that up in the forum.

Uh, due to time constraints, we're only gonna look at

one.

We're gonna look at the alloy specification language and a

tool that goes with it called the Alloy Analyzer.

So the idea of allo A is that it lets

you capture the essence of a design at a very

high level.

Uh, so if you are coding in Java and you

wanna say I don't know, you know, you're trading the

the typical example of a an address book and you

wanna say an address book has multiple contacts or multiple

people in it.

Uh, if you're writing in Java or lots of other

languages, you have to put in all sorts of needless

well, for the purpose of design.

You have to put all sorts of needless details in

that you have to say, uh, what kind of a

list is this?

You know?

Is is there a set of people?

Is it a Is it a list?

Is it a set?

Uh, is it an array list?

Is it a hash set?

Uh, all sorts of other details.

You have to write a constructor.

Ah, there's all sorts of things which for trying to

sketch out the design of something you don't really need.

So alloy sort of abstracts away a lot of the

details, and it lets you specify just the bare minimum

about what's in a what's in a system.

And hopefully it lets you identify particularly tricky or risky

parts of the design.

Um, and it lets you build up a model bit

by bit, and it lets you simulate and analyse portions

of the model as you go.

So the idea is that, um, before you start implementing

a system, uh, you can start specifying the entities that

make it up and, uh, sort of how they connect

together.

Uh, what constraints are there?

So in in Java, sometimes you've got, um, uh, classes

that have a singleton object that can only ever be,

uh, one instance of those classes.

So that's a kind of extra constraint you might express.

You might have constraints, like, I don't know, students can

take at most six units a semester or some number

of points or something.

Uh, that's a constraint.

All sorts of constraints like that you put into your

model.

Um, and you can then sort of, uh, before you

start writing classes, you can at least get an idea

of what's going to be involved.

And often, uh, often you may discover that things you

thought you had a good grasp of, uh aren't as

perhaps obvious or as clear as or as simple as

you thought.

Uh, places things where this works.

Well, um, so there's quite a lot of systems that,

um, seem maybe like they shouldn't be that hard to

programme, But there's a lot of hidden complexities to them.

One of those is, uh, package managers.

So on, um, any computer on mac or on windows

or on Linux?

Uh, if you've got some way of installing software, uh,

and listing what's already installed, Uh, some things that you

install have prerequisites.

They have things that they they require, uh, some things.

You'll have installed some things.

If it has prerequisites and you uninstall it, you expect

all the pre prerequisites to be uninstalled as well.

So I don't know.

You install chrome or something.

Uh, chrome has a bunch of libraries it has to

install.

If you uninstall chrome, it should also remove things that

went with it.

Uh, unless those are required by something else, or unless

you deliberately installed them yourself.

So, uh, you sort of think something like, um, uh,

a software package manager is kind of simple, but, um,

for each one of those things that gets installed, there's

gonna be a version of the software.

There's gonna be other bits of software that it can,

uh, say, Well, some it will require.

So, like I said, it can have prerequisites some it

will conflict with.

So you can say you can.

You can't install this bit of software on the same

computer as this other bit.

You know, they're they're gonna conflict.

Um, So starting to sketch out a design for that

before you start coding can, uh, lead to you resolving,

uh, problems much earlier on than if you just leap

into the coding So that's one example.

Um, other things that seem easy or easy at first

glance are, uh, tickets and queues or anything where you've

got a system that lets people, uh, put in, I

don't know, requests or bug reports and so on and

lets them get dealt with.

Uh, those are often trickier than you think of than

you think they are.

Uh, anything involving timetable timetabling when you've got, um, multiple

multiple people schedules to consider, um, those are actually in

the general in the general sense.

Those are intractable.

It's, uh it's a hard problem to find things like,

say, er exam times that, uh, everyone can attend.

Um, so for those sorts of systems, it's especially beneficial

to, uh, yeah, start sketching out design of those first,

um, one that, uh, I have seen used in practise

was actually, um, scheduling maintenance for oil rigs, uh, gas

and oil rigs.

Uh, so that that, uh, again is a timetabling problem.

Uh, you've got sort of maintenance staff.

Uh, you've got places they have to be at that.

You you've got periods by which sort of main regular

maintenance should be done.

Uh, and once you start to add in all those

constraints, it starts to get much more complicated than you

might think.

OK, so what is alloy?

Uh, it's a language for describing structures and how they

interrelate.

Uh, it can describe sort of a static picture of

structures.

So how things are at one point in time and

also it can describe, uh, how structures change over time.

Uh, another.

There's another language that I mentioned T l a, uh,

temporal logic of applications.

I think it stands for, um that is particularly good

at these dynamic behaviours.

So, um, alloy is, um, probably better at static structures

than dynamic changing things.

So dynamic, changing things are properties where you want to

say, I don't know, uh, we have these things in

a queue, and at some point in the future, they'll

we we know that they'll all get seen and all

get all get cleared or attended to, uh, and there's

an extension of Alloy called electrum, which is kind of

a a competitor to t l.

A.

But we'll mostly look at the the fairly simple static

structures.

So, um, the idea is to give you an idea

of what the language looks like and what it can

do.

And, uh, if it turns out to be useful, you

can always look at the extensions to it in more

detail.

So is a language for describing things, and it comes

with a tool, uh, the analyzer, which, uh, tries to

generate examples or counter examples of, uh, things that you've

described or things that you think should be true.

So we'll see what that means later.

Um, advantages of alloy compared to some of the other

specification languages that exist are, uh, it's a fairly small

and simple language.

It's, um, into about its fifth or so version, and

it's had things added to it, but it's still reasonably

small and reasonably simple.

Um, it's got, uh, very simple and uniform semantics.

Uh, so it's, uh, simpler than t l a, which

I said is a sort of competitor to it.

Uh, and it produces models that are, uh, easy to

analyse using automated tools.

Um, it's got a few similarities to U M L

for anyone who's seen u M l.

It's got a a graphical notation that looks a bit

like U M l.

Um, it's got, uh, the way that you express fact

and constraints is a bit similar to, uh, something that

u m l came up with called the, uh, the

object constraint language.

Uh, but differences are that u M l he does

not have a very precise semantics.

Uh, it's, uh, open to customization and interpretation.

Uh, so alloy is much more precise.

Uh, and l o A is a lot smaller and

simpler than u m l.

So u m l allows for all sorts of things

like, uh, flow charts and state charts and use cases

that, uh, don't have an equivalent in alloy alloy mostly

is similar to, uh, u MLS object and class diagrams.

So the analyzer is written in Java, so it runs

on.

Uh uh, pretty much any sort of machine that you've

got.

You can run it on Mac or Linux or windows.

You just need to, uh, download a jar file and

you can run it in a terminal.

Uh, and I've also set it up so that, uh,

you should be able to run it on the web

as well.

So where are we?

5900.

Open browser.

Okey doke.

There we are.

So, uh, you can just, um, run it, Uh, so

it's a little different to other things you've seen in

in that, um uh, because it runs a graphical programme

that isn't, uh, Microsoft.

Uh, visual studio code.

Uh, it opens alloy in a separate pane.

So you see a message popping up that says, um,

something is available on port?

I forget what?

Port 60 80 or something.

Uh, do you want to open that?

And you say this?

Yes.

And it will pop up and show you the analyzer

here, and you can start saving, uh, saving ex examples

in the workspace and, uh uh, trying them out.

So we'll, um, have a look at that in more

detail in the labs.

So, uh, the idea is that, um you express, uh,

properties about the the things you're trying to model.

So for Java, these will often be, uh, classes, uh,

in your system.

So here we've got an example of a file system.

So we often create simple, uh, simple models of file

systems by saying, uh, they consist of two sorts of

things.

Files and directories.

Uh, directories can contain, uh, either files or more directories.

Uh, every file system is supposed to have one route.

So, for instance, on, uh, on Linux, every file system

has a a single point.

That's the root file route of the file system.

Uh, on windows, the route is usually the drive.

Uh, so, uh, if you're take a bit of a

look, you can see some of the some of the

alloy code used to produce this, uh, so it says,

uh, that we have, uh, files.

Um, uh, it says that, uh, files appear in directory

contents.

Uh, there's directories in there, a few other bits and

pieces.

Uh, so we use the analyzer to show us, uh,

examples of what our structure would look like.

Um, so it, uh and we can specify things like,

I want you to show me a file system with

maybe, say, at least three files and three directories and,

uh, at least one route or something, and it'll show

you what that looks like.

Uh, and that's handy, because when you see things that,

uh, don't make any sense or, you know are, uh

are not the way the system is supposed to work.

Uh, it means your specifications are a bit too loose.

They've been They've been too broad.

They allow in sort of bad examples, and you have

to tighten them up a bit.

Uh, and if Alloy says I can't show you any

examples, then that means that you've made your specifications too

tight.

You've actually contradicted yourself.

So, uh, alloy will try and construct sort of examples

of the sort of system that you've described.

Uh, but sometimes you've specified that, um, you've specified requirements

that, uh, contradict each other, and alloy will just say

that's impossible.

There are no examples.

It can't be done.

And in that case, you know, you've got, uh, some

sort of a contradiction, uh, and you're gonna have to

loosen your specification up a bit.

So he said that, um, uh, contradictions are one of

the problems that can arise when you write natural language

requirements and specifications.

You may not spot that, uh, two bits of a

specification contradict each other.

Um, and, uh, doing some kind of specification first, uh,

in a language like alloy can help you spot that

earlier instead of later.

Ok, so the idea in alloy is that we declare

rules about a sort of a mini universe.

We say all the sorts of things that can exist

in it, Uh, and all the properties that should be

true of them.

And, uh uh, it's a bit like we declare what

the laws are, what the sort of like the equivalent

of the laws of physics for that universe.

Uh, and then Alloy, like I said, gives examples of,

uh, sort of, uh, simple universes that follow those rules.

So for declaring that things that exist, um, so in

Java and a lot of object oriented languages, uh, you

declare things with, um, the key word class, uh, in

alloy.

Uh, you use the keyword sig.

It's short for signature.

Uh, it comes from an area of mathematics called abstract

algebra.

Uh, so it's not terribly important why it's called a

sig, But it does differ from, uh, from the Java

way of doing things.

So to say that some sort of thing exists, the

simplest declaration you can make is just to say, sig

name of a thing and a body of the thing,

uh, which we can just leave empty, so sort of

properties of it would go in the braces.

Uh, so that's the the simplest sort of declaration of

an entity.

Uh, so it's similar to the simplest possible Java class,

which just says something like class animal and empty braces.

Um, alloy has something quite similar to, uh, inheritance in

Java.

So you can say one thing is a type of

another thing.

So cats are a type of animal.

You would say sig cat extends animal.

Uh, so that's actually, uh, the same keyword that Java

uses the extends keyword.

So that's very similar.

Um, so that's the way you declare things.

Uh, and you can add properties to those things.

We'll see those in, uh, in a few slides, more

so you declare things, you declare properties of those things.

Uh, and there's two other sorts of, uh, bits and

pieces that you can write in.

A You can write, um, what are called facts.

So these are sort of our laws of the universe.

Uh, so these force something to be true of the

model.

So there are constraints on the model, and, uh, Alloa

won't generate any instances of the model in which the

facts don't hold.

Uh, so the fact is part of our specification.

We say something like, um uh, a file system has

files and directories in it.

If you say there is exactly one route to every

file system, Uh, that might be something you would express

as a fact.

So it's part of the specification.

OK, there's a second thing that you can write.

Uh, that isn't part of the specification.

Uh, it's more like, uh, a way of debugging and

testing your specification.

And that's assertions.

Uh, so these are similar to assertions in Daphne or

other languages.

Uh, when you write an assertion, if everything is sort

of, um, perfect and correct about your code, uh, the

assertion will never get triggered because you write assertions in

code cos you think they're always true.

So, um, uh, if you write in a session in

in Python, uh, ideally, you expect it never to get

triggered.

Uh, if you have an assertion in l.

A.

And you say, check this assertion, ideally, it will say,

Yeah, it's fine.

I I can't find any any issues with that.

Um so it's not part of the model.

It's something you use to check the model.

It's a bit like a, uh, a debugging tool.

Also like adding print lens to your code.

It lets you see, uh, it lets you sort of

query the state of your model and find out, uh,

whether something seems to be true or not.

So your sigs and your facts make up the specification.

The assertions are just kind of, um, checks on your

specification.

Alright.

So, uh, we will, in labs and in the exam

get you to write some simple models using alloy.

Um, and the idea when you're writing alloy models is

to generally you try and include the absolute minimum properties.

You need to show how your system, how your entities

work with other entities, how your system hangs together.

Um, so in reality, if you were, um, making up

an address book, then maybe you'd say, I don't know.

The address book has multiple people in it.

Every person has, uh, uh, name and address and so

on and so forth.

Um, but the fact that people have a name and

address is actually actually might be irrelevant to the design.

So the design of an address book all you might

need to know about, uh, there's an address book and

there's people in it, Nothing else.

So you don't add on extra properties about the people

for realism or anything like that.

You just add whatever you need.

So, um, if addresses were something important in themselves, So

maybe if if people can have multiple addresses, uh, and

maybe I don't know if people share an address and

you change the address, it should get updated for both

people.

Then that's something that you should be modelling.

So you'd probably make an address.

An entity of its own.

You'd say there's an address book.

An address book has multiple people.

Uh, each person can have multiple addresses.

Uh, two people can share the same address, so you

model what's needed and no more and no less.

So we're going to look at file systems.

We're gonna look at a simple file system model.

Uh, it's based on, uh, an online alloy tutorial.

Uh, so we can see that, um, as I said

before, Alloy looks reasonably like java.

You've got your declarations and things inside those declarations.

So let's have a quick look at what sort of

things can appear here.

Uh, so for things in a file system, uh, the

main property that, uh, we want a model about things

in file systems is that they contain other things.

So directories contain things, and they are contained in other

things.

So, uh, after a bit of fiddling with all, we

probably work out that an important, important property of, uh

uh, anything in our file system is it has a

parent.

It has some directory that it sits in, uh, and

in simple models, uh, there is only there's at most

one parent.

So more complicated models might have things like, um, what

are called symbolic links or hard links?

Uh, or maybe things that can appear in multiple directories

at once.

But for a simple model, Um, we would say that,

uh, every file or directory, uh, has at most one

parent.

So loan means, uh, zero or one.

Some things have no parent because in a file system,

eventually you get to the root.

So something like the C drive for windows.

Uh, and that has no parent.

So we have file system objects, and we have two

sorts of things that, uh, extend file system object.

So this is like inheritance.

Uh, we say directory is a type of file system

object, and a file is a type of file system

object.

And for directories, uh, we give them, uh, a set

of contents, things that they hold.

So you can see that, Uh, this is definitely more

concise than java.

It leaves out, uh, like I said, lots of details

that Java would make you specify that are irrelevant to

the design.

So, um, and it also expresses a lot of things

that Java is not good at expressing.

So, uh, we say the DI Direct directory has a

set of things that, um is its contents.

We don't have to say this is a hash set

or a tree set or whatever we just say It's

a set.

Um, we can also say things like, uh has zero

or one of or has exactly three of, uh and

those are more difficult to model in Java.

So there's a few.

There's a few ways of thinking about a lot.

One way is you can sort of think of it

as being, uh, a java.

I sort of language.

Um, So, to a first approximation, you can look at

an l O specification and think of it as being

very similar to Java.

So it's got these, um, these sigs and properties and,

uh, attributes of sigs, um, to do, to understand it

more fully and to do some sorts of complicated things.

Uh, you need to know how all I works in

our in all, everything is made up of atoms and

relations.

So relations are sort of sets, and atoms are things

that can appear in sets, so we'll go back a

bit.

Let's have a look here.

So, um uh, these boxes here, these are atoms.

So they're like instances of objects.

Uh, and relations are everything else.

They're things like, uh, the types.

So if you have, um, you've declared some sig animal.

Uh, you've you've effectively declared a set of things that

are all animals.

That's a sort of a relation.

Uh, if you've declared that I don't know, animals have,

uh, a property of either having fur or not having

fur.

Uh, you've made a slightly more complicated relation, but, um,

everything in alloy falls into being one of those two

things.

So the atoms, uh, you don't actually ever deal with

those yourself.

So, unlike java in java, you might say, Um uh,

make me a new object of type, whatever string or

list or something like that.

Um, you know, you never do that.

The, uh the atoms all get made by the analyzer

for you, so you'll ask.

Um, you'll ask the analyzer to show you examples of

your model.

Uh, and it will construct atoms that sort of fit

into the, uh uh, the design that you've specified.

So a relation is what groups atoms together or says

this thing is, uh, related to another atom.

So this atom is, um, has a relation, like contains

or, uh is the parent of something like that.

So we'll see examples of that.

So a simple example might be you could have a

very simple sig, Uh, and you might call it, uh,

just person so we can write this out.

So, uh, the simplest thing of all is not to

give our person, uh, any properties at all, But we

could also say shares an office with, uh And you

could say a person shares an office with a set

of other people.

Can anybody spot something about that?

That, uh, might not be part of our intended meaning

if I say you share, uh, so each person has

this property shares an office with, and there's a set

of people in there.

Uh, is there anything about that that might give rise

to something I I don't intend or that we wouldn't

normally mean?

Uh, possibly I mean, one thing is, can you share

an office with yourself?

Does that make sense?

Would we normally say that?

No.

So, uh, once you try modelling this with alloy, uh,

in fact, uh, we'll we'll do that in a little

while.

Um, it'll it'll come up with sort of sample universes

and you'll see you share an office with yourself.

You'll see it'll generate a person and have a a

sort of a link going from a person back to

themselves, and you'll say, Well, that's not what I meant.

What I meant was, uh, a person shares an office

with other people.

Uh, another thing that's not in that model is that

if you share an office with another person, it's also

true that they share an office with you.

And that's not always the case.

So, uh, not all relations work that way.

Like, uh is the parent of only goes one way.

If someone is my parent, I'm not their parent.

But if I share an office with someone, necessarily, they

share an office with me.

So, uh, here, uh, we haven't put that constraint on

things.

So if we asked Alloy to show us a model

it would come up with it would generate some sort

of simple people.

And it would say, you know, Alice shares an office

with Bob and Bob shares an office with Carol, and

you say, Well, that's not what I meant.

What I meant was, uh, that this has to be,

uh uh, this has to go both ways.

It's, uh, what we call a symmetric relation.

Um, so we'd have to add some additional sort of,

uh, laws to narrow that down some facts.

But, um, it gives us a good example of, uh,

what relations are so relations.

You can think of them as being just like, uh,

rose in a spreadsheet.

So, for every relation, uh, it's as if you've got

a table somewhere, uh, with columns, and you could think

of, um shares an office with, uh as being a

table with two columns in it.

Person A and person B.

So here it happens that we say Alice shares an

office with Bob, and it happens that Bob shares an

office with Alice.

So whoever sort of design this, um, specification has obviously

taken the trouble to make sure that, um uh, if

it goes one way, if there's an entry that says

Alice and Bob, there's also an entry that says Bob

and Ellis.

So it goes both ways.

But if you don't specify that, it won't happen.

You'll just have sort of links from person to person

and not necessarily anything coming the way, uh, the other

way back.

Uh, so each row of things is called a topple,

Uh, and a person makes up a couple themselves, So

you'll have, uh, we declared that there is sorts of

things called person.

So that means somewhere there's a big list of all

people.

Oh, that Bob.

And, you know, we probably would want to give them

user friendly names, but, um uh, alloy is not going

to do so.

All o is probably gonna give them names, like P

zero p one p two.

Uh, when it generates, uh, sample universes for us to

look at.

Uh, So what do we have here?

Yeah, so it says, um, things like de entry zero

du one et cetera, et cetera.

So if we declared a type person, it would say

person zero person, one So on and so forth.

So a relation is the table, and it has some

number of columns, and it has some number of rows,

and a single row is called a topple.

So you can have a table which has, uh, two

columns like this shares an office with, uh so that's

what typically happens.

Uh, when you specify something as a property.

So you say, uh, one person shares an office with

another person, Uh, you've sort of immediately created, uh, uh,

a kind of two column table, the original person and

the person that they share an office with, um And

you can have columns.

You can have tables which only have one column.

So person itself would be a table with one column,

a relation with a single property.

Uh, and you can have tables with many, many more

properties.

So in other languages, um, we often have a lot

more types than alloy does, uh, if you need them.

Alloy does have things that are, uh, a bit like

INTs.

Actually, I don't know if it has anything like doubles,

but, um, it certainly has things that are a bit

like yin.

It's got things that are a bit like lists.

Um, but in in alloy, all of those are just

relations.

There's just the one type of thing.

So this is actually simpler than java in Java.

Uh, at a minimum, we've got two types of things

we've got primitive types, like, uh, in and bully and

and double.

And we've got relation.

And we've got reference types like classes and arrays, but,

uh, in alloy, there's just one type of thing.

Everything is a relation.

So it is definitely, uh, simpler than java in that

sense.

Um, so everything that we want to talk about is,

um, some sort of, uh, some sort of relation.

OK, so it is almost 10 to 4, so we

will take a 10 minute break.

Um, I would suggest if you haven't already, uh, think

about And I talk with someone else, uh, about, uh,

how you're getting on with the project.

And, uh, after the break If there's, um, particular things

that people are finding tricky or questions You, uh, think

you need answers to, Then, uh, uh, we'll talk briefly

about those.

Um, also next week is down as being a revision

lecture, which is usually where I talk about the exam.

I will have to cover a bit of alloy stuff

as well, I think because I don't think we're gonna,

uh we're unlikely to finish it today, but I'll try

and leave at least half of, uh, next week for

talking about, um uh, the exam.

Um, yeah.

So also, if you've got questions about the exam, then,

uh, feel free to, uh uh, you know, think about

those write them down beforehand.

But, um, uh, if you've seen once you've seen the

tests and you've seen the workshop we did where we

marked a an e a long English answer.

And, um, uh, you've seen the project.

Then you'll have seen all the kinds of questions that

we're likely to ask.

Maybe not every topic.

Uh, because, for instance, we've had no questions on Alloy,

but you've see, you'll have seen you'll have a a

pretty good idea of what uh, kinds of things we

might ask.

All right, so let's have a break and have a

think about the project.

I assume everyone started with the project here.

Well, what are you guys have over to my office?

I'll be back.

OK, so were there any project queries?

Right.

OK, I stop there.

Said my OK.

Project queries.

Yes.

Um, so when you're actually looking at it Oh, does

it?

OK, then.

That's a mistake in the specification.

Uh, can you email me and, uh and I'll fix

that?

Uh, let's have a look now.

Actually, I'll, uh, bring that up.

Uh, where is assessment?

Oh, yeah.

So it does.

Oh, hang on.

No, that that's correct, because that's got nothing to do

with the classes.

That's what people type.

So the idea is so you can't type an enum

you type, you know, particular keys on a keyboard.

And this is just saying, uh, what the person types

is, uh, one of the strings One way or return,

So that's completely correct.

Uh, it just so happens that, you know, in Java

a good way to represent that is by a need,

because there's only limited possibilities, but uh, if if that's

the bit you're meaning, then it's It's still fine.

Yeah, yeah, it's impossible to type something That's not a

string.

The only thing that we would say, uh so, technically.

So you've said a number from 0 to 20 dumb

in, you know, really?

For a very tight specification, We should have said, uh,

digits.

And these are the correct digits.

But, uh, it's, uh, assumed that people can interpret, uh,

an English language specification.

So that's fine.

Um, yeah, yeah, Yeah, exactly.

So the idea is that, um uh, research in gladius

has suggested that, you know, for experienced people much quicker

to type than to use A, which is true.

Uh, and they've come up with these commands which are

horrible and, uh, are all based on, uh, real commands

from a real, uh, uh, flight booking system.

So, uh, it's based on Sabre, which is one of

the, uh, organisations that, uh, has almost a monopoly on,

uh, flight booking systems, uh, across the world.

Uh, and, uh, if you ever look at their software,

it's just disgusting.

It's, uh, it I mean, it's existed since the I

don't know it was created by I b m in

the seventies or eighties or something, and, uh, there's sort

of multiple inconsistent versions of it, and multiple API s

with all sorts of API s, ranging from, uh, I

think the earliest sorts of web API that existed, uh,

which were soap.

Sort of an XML kind of thing to more modern

things.

And there's, uh, yeah, bizarre things like, uh, cabin type.

I wouldn't have called that cabin type.

I would have called that passenger class, but I've actually

stuck to what Sabre uses.

Sabre says that, you know, economy and business and so

on are cabin types.

So, uh, this gives you, uh, uh, a little of

the flavour of what?

Working with a real legacy.

Uh, system is like, uh, which, uh, after all, is

what many people will be having to do.

You will, uh, often have to look at other people's

already existing systems and, uh, maintain or fix them.

Uh, were there any sorry?

Well, you think so?

Except that, um, uh, it's easy to use.

It's not actually, uh, well, who pays for the software

in a, uh uh, let's say, a travel agency.

Is it the people who use the system?

Or is it the person who owns the company or

owns the franchise is the person who owns the franchise?

Uh, if you say to them this is much easier

to use and more user friendly.

Uh, also, No-one has ever used it before, and it's

different to the thing that 99% of other travel agents

use.

Are they gonna buy it from you?

The answer.

It depends on the price.

If it's amazingly cheap, maybe they will, because, I mean,

you know, people do make inroads.

Once upon a time, Amazon had just started and everyone

thought it was a a terrible A.

Well, actually, people thought it was a good idea, but

they didn't think that it would necessarily make any money.

Um, so yeah, there is.

There is.

There are some.

There are some uphill battles to be fought.

If you wanted to introduce something, something better.

Uh, any other queries about the the spec at all?

No.

OK, we will go back to the stuff.

OK, so we said in l.

A.

Everything is a relation.

Well, everything you can make is a relation.

No, that is all, uh so there are atoms as

well, but everything that you deal with will be some

sort of a relation.

So, uh, if you have, like, what's called a scaler

a single thing?

Uh, that just means, um uh, so a single thing

with no properties, that's just a table with one row

and one column.

So everything in alloy is gonna be, uh, a table

of some sort of relation.

Uh, it subsumes, uh, all the other sorts of things

like classes and structures and arrays that you find in

other languages.

So let us have a look at some sample relations.

So is less than is an example of a relation.

Uh, if I have numbers, I can say two is

less than four.

I can say 10 is less than nine.

It won't be true, but I can.

I can try and say it.

Uh, that is a relation that takes two things.

So there'd be two columns in our table.

Number one, number two.

If there's a row in the column, then they're less

than how many rows would I have in the table

for less than and for integers.

Gentleman at the front.

How many rows would I have in my table for

the less than relation?

How many rows would there be in the table?

How many interviews are there in the world?

OK, it's infinite.

OK, it would be an infinitely large table in, uh,

if we are just talking about INTS and they don't

have any specific, uh uh with any sort of particular

memory that they have to be expressed in, Uh, the

set of integers is infinite.

So the relation this is less than that is a

table which has an infinite number of things.

Uh, compared to an infinite number of other things.

Uh, is the blood relative of Alice is the blood

relative of Bob.

That's another relation again.

It's got, um, two columns in it.

We've got person one and person two shares an office

with another two column one So we can say Bob

shares an office with Callum Carol.

Uh, so they're all binary relations.

Binary, meaning two of, uh, statements about two entities.

Uh, and they can be true or false.

So, uh, if we're representing those in Alloy Alloy has

got a table.

If something is in the table, then it's true.

If it's not in the table.

It's false.

Uh, we I said that we can have relations that

are unary.

So in other words, tables of one column, Uh, so

that includes sets.

So I said, um, person is, uh, effectively a relation

of one column.

Uh, but there's a few others as well.

Uh, if you have something that is just true or

false of, uh of things like, uh is even, uh,

that is a unary relation.

So if we wanted, we could imagine that we have

a list of all even numbers.

There would be, uh, it would have an infinite number

of rows in it, but there would be just one

column.

It would just have, um all the numbers that are

even, uh is an employee.

So Dan is an employee.

Uh, that's a unary relation.

Uh, and we can also have more complicated relations.

These turn up, uh, a lot when you've got things

like, uh, say I don't know, uh, things in a

an online store that are shipped to a person via

some particular shipping company.

So via Australia Post or via, uh, some other organisation.

Uh, so we could have a three column table to

represent, uh is delivered to We could say the blue

Book was delivered to Alice by Bob, and there'd be

sort of spots in there for 33 things.

So it's a a turn relation, and we can have

as many columns as we like.

Uh, usually usually in nice systems.

You rarely end up with, uh, more than three or

four once you do, it's usually a good rule of

thumb to try and, uh, break things down somehow if

you can So usually, uh, 10 or or uh, is

about as complicated as you uh, usually will get.

So you can think of predicates as being a bit

like functions in that, um uh, if I if I

tell you a predicate So if I tell you less

than or uh shares an office with is not something

that's true, like less than on its own is not

true.

It needs some arguments.

So you need two numbers for less than you, and

then you can say two less than four.

Now, I've got something that, uh, uh is true or

false.

Uh, I said that our relations can be finite or

infinite.

Uh o a alloy always will make you specify a

maximum size.

It can't sort of search forever.

When you're, um when you're getting alloy to create sort

of simple universes, you you give it a maximum size.

Uh, it actually includes, uh, numbers.

So if you specify that you don't want anything in

your nothing in your universe, So no relation in your

universe should have more than I don't know four things

in it.

Um, I think alloy from Recollection, uh, limits the number

of bits in every number to four.

So it'll also never give you a number that is

bigger than 16.

Uh, if you said sort of four is my maximum

size of things for this universe, uh, then if something

happens to have a number of a property, So I

don't know, you've got animals and you specify a number

of limbs.

No animal will have more than 16 limbs in your

universe.

So just to, uh, just to, uh, re emphasise what

I've said, uh, sets are gonna be one column relations

so we could have a set of names or a

set of people scale, uh, things with, uh, just, uh,

one column and one row and everything else is gonna

be some sort of binary or turn relation.

So we declare a sick animal.

Uh, we've immediately created a unary relation animal, so things

can either be an animal or not.

And there will be a, uh, you can think of

alloy as having an imaginary table of all animals.

Um, Sig extend sig cat extends animal.

You can think of this as saying, um, if we

know something is an animal so it appears in the

table of all animals, it might also appear in a

table labelled cats.

So, uh, c is just creating another relation.

Uh, and it's got a restriction on that relation.

It says, uh, everything that appears in that table has

to be something that's already in that table.

Uh, but I like I said for, uh, for a

sort of a simple reading of it, you can also

interpret this not in terms of relations and tables, But

you could just say, Well, you know, it's it's pretty

much like Java.

It declares this this thing is a subtype of another

thing.

Um, so it's It's pretty similar to, um, Java's subtypes,

and you can add on extra properties of cat.

So you could say, you know, cat is a subtype

of animal.

Uh, and every cat has, I don't know, a breed

or something.

That would be fine.

So in the braces here, you could say, uh, every

cat has a breed, maybe, Uh so for most intents

and purposes, it's like java subtyping.

Uh, here is an example of it.

So from our file system example, we've said, um, uh,

everything in a file system is some sort of file

system object.

And, uh, here are two sort of subtypes, uh, directories

and files.

So directory is a type of file system.

Object file is another type.

Uh, and when you say, uh, extends like that, uh,

alloy considers these to be, um, mutually disjoint sets.

In other words, they don't overlap.

Something can't be both a file and a directory if

we use, uh, extends.

But it doesn't say that, um, those are the only

types of file system object.

So we've said, um uh, there are dear.

So those are a type of object.

We've got files.

Those are another type of object.

But we haven't said, um, that's the totality of file

system objects.

Maybe there could be other things.

So unless we tell our alloy, uh, everything has to

be one of those two types.

It'll assume it's allowed to make up, uh, other file

system objects as well.

So, uh, if we want to say, uh, these are

subtypes of a type and there can be no other

sorts, uh, we'll have to add that in.

We'll have to probably add it in as a fact.

Uh, so adding a little more detail, Uh, we might

add in some properties for each of these.

So we might say every file system object.

Uh, either it has a parent or it doesn't have

a parent, so a loan is zero or one.

So if it has a parent, uh, its parent is

some sort of directory, so you can't have files containing

other files.

Uh, and if it's a directory, uh, then it'll have

a contents.

So a set of things that is in it, But,

uh, at the moment, uh, we haven't This is a

pretty loose specification.

And if we try and ask alloy to give us

examples of this, um, it's gonna come up with all

sorts of things that we didn't mean.

So one of those will be, uh, a directory containing

itself.

We probably want to rule that out.

Uh, even if we rule out directories containing themselves, what

about one directory contains another directory which contains the first

directory again, or a bigger loop.

So, in normal file systems, uh, for various reasons, it's

a It's impossible to have some kind of circular loop

like that.

Uh, you can have something that is, uh, similar to

a loop.

So you might have shortcuts or sim links.

Those can make a loop.

But, um, you can't ever have, uh, things that are

really, really in a directory.

Uh, that form some kind of a cycle in the

system.

So we'll look at how you rule that out from

happening.

Um, so that's one issue is that, um uh, when

we come to playing with this model, we'll see.

It allows things we don't intend.

Uh, it, uh, lets things be a, uh, part of

their own contents.

Uh, it also doesn't join parent and contents at all.

So, really, what we want is that parent is kind

of the inverse of contents.

Uh, if a thing is part of the contents.

So if directory A has its contents File Z, then

file Z, it's parent should point back to directory A.

So we haven't specified those things yet.

Um, so our properties is we normally would write them

just in the braces there inside the sig.

Uh, but again, they they What they represent is relations.

So tables.

So you could read this as being a bit like

Java and it says, uh, file system objects are a

sort of thing.

They have zero or one parents, or you could read

it as saying, uh, file system objects are a sort

of relation.

Parent is a relation between two file system objects.

So in addition to the loan, we've got a few

other ways of specifying how many things there can be.

So, uh, loan is a cardinality, um, cardinality just meaning

size of a size of a set or a relation.

Uh, some of the others that come in handy are,

uh, one exactly one.

So you might say that, um, uh, a file system

object has to have exactly one parent.

Uh, but then you discover you're running into problems because

if you rule out.

Um, uh, because if everything has to have a parent,

there can be no route.

Uh, there must be cycles.

And if you rule out cycles, you'll discover that you've

given a contradiction.

Uh, so you can have things that are exactly one.

You can have some.

So one or more, at least one or or set,

which is zero or more.

Uh, and there is another one here, which is none,

Uh, so that comes in handy.

Well, it does come in handy.

So, for instance, you might wanna say, uh, we have

false system objects and directories.

Um, there is nothing else.

Those are the only types of things there are.

You could say that by saying, um, if you start

with file systems and you take away directories and you

take away files, nothing is left.

So you could use none for that.

Uh, sometimes you might have a parent object, and you've

said, uh, I mean, this is not a good way

of doing it, but maybe you say file system objects.

Maybe instead of putting contents in the directory, you put

it in file system objects, Uh, and then you want

to specifically say uh, for file you could add as

a constraint.

Um, its contents is always none.

It wouldn't be the, uh the way I'd choose of

representing things, but it is, uh it is possible.

Uh, so if you don't specify a cardinality at all,

then the default, uh, the default cardinality or multiplicity is

one.

So we can also put that so alloy is pretty

flexible.

Um, it it tries to, uh, be fairly general in

how it works.

Uh, we said, um, these canal let you specify the

size, size of tables, the size of relations.

Uh, and we said a sig is just another sort

of table.

So that means that you can specify the size of

a sig as well.

So you might want to say, uh, a root deer

is a special kind of deer, and there is only

one of it.

In fact, there is exactly one of it.

No more, no less.

So you could put, uh, one or set or many

or whatever it is, uh, in front of the sig

as well.

That would work.

OK, so if I wanted to say the following, Let's,

uh so there are things called games games can be

board games or field games.

There may be other sorts of games.

Uh, how would I do that in?

L I s.

So if I want to say there are games, what

do I need to write time for?

Uh, no, not quite, but close.

Uh, we just start with, um, with game.

So we just say sig game.

And no one's told us any other properties of a

game, so we don't need to put anything in the

braces.

Uh, and for board game?

Yeah, We use extends here.

So sig board game extends game and a sig field

game extends game.

And we also want to say there may be other

sorts of games.

Do we need to?

If we want that to be true, there may be

other sorts of games.

Uh, do we need to say anything else, or is

that enough?

According to what we've said about how our lawyer works,

who says we need something more?

OK, OK, it's actually fine as it is, cos we

said, um, if you use extends, that means there'll never

be any overlap here, so something can't be a board

game and a field game But it doesn't rule out

that there are other sorts of games.

So there may be other sorts of games.

We don't need anything extra.

Uh, we don't need to add anything extra to say

that.

If we wanna say there aren't any other sorts of

games, then we do need to games rather.

Then we do need to specify that.

Uh So, Well, the easiest way to do that is

to add a fact.

I said facts are sort of like laws of the

universe that you add extra constraints.

Um, and we could just say that, um, board, game

plus feel equals game.

I think that will work.

Um, I would have to double check by.

So there's an alloy cheat sheet.

Uh, and I'll, uh, for the exam.

Uh, I'll give you access to to that.

So, uh, you're so in the exam.

It I mentioned it's held in the labs and you'll

have access to, uh, uh, all of the lecture notes

and, uh, all of the, uh, lab worksheets.

Uh, I'll also add in the, uh and you'll have

access to mood, obviously.

So that's something to do with mood.

I'll add in the alloy cheat sheet because I can

never remember the details of it.

Um, but I've you might have to say something like,

uh, cardinality board game plus cardinality field game equals game.

But I think, uh, I sort of won't bother checking

now, but I think you can just say board game

and field game equals game.

And that's enough because, um, by default, given that everything

in l.

A is a relation by default, Uh oh.

In fact, yeah, you don't You don't even need to

say anything about size here at all.

Um so by default, alloy reads that reads the plus

as being, um uh, set union.

So it says the Union of board game and field

game is the set game, and that's exactly the restriction

we want.

If we want to say there may not be other

sorts of games, uh, then we just have to say

those two together make up all the games there are.

So that's how we would do that.

A l o.

Um, it's a good idea to comment.

Oh, yeah, so I think I might be a bit

confused, but you said that, um, boards are set each

one of them is a set.

Yes.

Um, and that one, uh, for properties, not for sets.

So for for.

For sigs, the default cardinality is actually set zero or

more, uh, for properties.

Uh, so something that goes in the braces here, Uh,

it assumes one, but it doesn't assume one for, uh,

for these For sigs, that wouldn't make much sense, because

we we obviously have, um uh, as many of these

as as our universe is, uh, so that that default

cardinality is only true for things you write inside the

braces.

Uh, and you can always change it to anything else.

So set or learn, uh, for sig.

Uh, the default is I think, set.

Um, it could be many, but it's probably set.

Uh, and if you want to change that, then you

can specify it by writing one or loan or, uh

or none.

Even though I don't know why you'd do that, Um,

in front of sig.

Uh, you.

Yeah.

So you should comment.

Uh uh.

You should comment each sig a bit way the same

the same way that we tend to write, uh, java

dot comments for classes.

We would write, uh, some kind of a comment, Uh,

for every type of sig that we make, uh, if

we've got any particularly complicated, uh, facts or properties, we

would probably write comments about those, uh, the default way

of writing a comment, uh, is just with, um is

like, java One line comments Java or C or JavaScript.

So two forward slashes.

Um, you can also use a double hyphen.

So that's the style of comment that comes from, uh,

A and Pascal and SQL that will work as well.

Uh, and you can also use C or Java style

multi line comments, So slash star and another slash star

at the end.

So I said, Oh, I did get it right.

Good.

Um, so a typical thing that you often want to

do when you've said, um, uh, these sorts of things

are subtypes of another.

Uh, if you want to say and there's nothing else,

um, so that's a constraint.

Uh, and you specify constraints using this fact keyword, uh,

facts.

You can give them names because sometimes it's useful to

not only, uh, like I said, these are kind of

the laws of the universe for your your mini universe.

you're creating, Uh, and sometimes you want to actually refer

to them so you can put a a name there

in between, just like a between fact.

And the braces, um, or you can have anonymous facts

like these that don't have any particular name.

Uh, so, uh, to exclude or to to say that

those make up all possible file system objects?

Yeah, just that.

Plus that equals file system object.

So the general syntax for a fact is fact an

optional name, and then some bunch of formulas, uh, you

can I think you can put more than one formula

in there and end it with a, uh, a semi

colon.

And by putting them in a fact, you're saying those

have to be true, so alloy will never generate example

Universes for you?

Uh, that don't obey those facts.

So there is another way of doing it.

Uh, which is, uh, we could make f s object

what's called, uh, an abstract sig.

So if you've used abstract objects in Java, it's much

the same kind of thing.

Uh, in Java, when you say an object is abstract,

it means, uh, you can't instantiate it on its own.

You can't make new objects of that class.

Uh, you can only make objects of subclasses of it.

Uh, so we could do the same thing here.

We could say abstract sig file system object.

Uh, and that would have the same effect as, uh,

as our little fact here, because if deers and files

extend file, system, object and file system object is abstract.

So you can never make, uh, atoms that are just

a bare file system object that that's doing the same

thing as our fact.

It's just saying these are the only sorts of, uh,

file system object you can have.

So there are.

There are often is more than one way of doing

things in, um So when we, uh, work with it

in the lab this week, you'll get a chance to,

um, play around with it.

Yeah, OK, so we want to, uh, we want ways

of, uh, expressing these facts.

Uh, the the constraints that go in the facts.

Usually these are going to be, um, uh, a bunch

of a bunch of our SGS and a few operators,

so we want to say things like, I don't know,

Uh, well, um I said there's more than one way

of doing things extends.

You could also rewrite as a fact.

Uh, but you often want to say things like, uh,

this is a subset of this or, uh, these 26

unions are the same as this, so they'll always be

They'll always tend to be, uh, sigs or properties.

So sometimes because it because a property really is, uh,

just another type of table.

Uh, you can also talk about the size of properties.

So, uh, for example, having said that, um, uh, a

person can share an office with another person, and the

property has, uh, cardinality set.

I could make an additional fact, maybe call it office

size, and I could say, person shit an office with,

uh and I forget the syntax for saying size of.

But you I'll assume for the moment that it's vertical

braces.

Um, you might want to say there's a maximum limit

on that set.

Uh, and, uh, it's usually easiest to put that.

In a separate fact, you could say shares offices can

be zero or more, but there is a a maximum.

It has to be.

I don't know less than eight or something.

So you could say, uh, one set is a subset

of another.

Uh, that's one thing you can say that would, um,

often just be the same, uh, the same as writing

extends.

So extends is often an easier way of saying that.

But, um, sometimes, for whatever reason, extends might not be

the best way to write it.

So you could add in some kind of a fact.

Uh, that says one set is a subset of another,

uh, subset in a means, Uh, it doesn't mean it's

a strict subset, so it doesn't mean, uh uh, this

thing is smaller than this thing.

It means it's smaller than all the same as so

if we say a cat extends animal, uh, it could

be that every animal is a cat.

Uh, we can say two subs.

Two sets are equal, and we can say if we

happen to have a scalar, which I said is just

a a one row, one column, uh, thing.

We can also give it a value.

So, uh, because alloy is fairly flexible, uh, instead of

extends, uh, we can also say extends but could overlap

with, uh is probably a good way of thinking about

this.

So instead of extends, you could just use in.

Uh, so it's the same type of thing.

It's saying, Uh, this subset is, uh, a subset of

another.

But unlike extends, it could overlap.

So I don't know, we could have, um, Male is

in person, and computer scientist is in person, and you

can have, uh, cases where those overlap.

So, uh, if you've used in, then it's not necessarily

disjoint.

So here is an example of that.

So we might say, uh, animals exist.

Cats are a subtype of animal.

Dog is another subtype of animal.

Uh, we could also, So we can also make up

sets that, uh, are just composed of, uh, other sets

we've talked about.

So we might want to talk about pets that have

fur, and we could just say, um, it's a subset

of cat and dog together.

So some cats have fur, some dogs have fur, and

a furry pet is a subset of the union.

So again, fairly flexible, you can, uh, in addition to

saying one sig is, uh, extends another sig.

You could actually put, uh, almost anything there instead of

animal as long as it turns out to be, uh,

a relation.

And since almost everything in alloy is a relation Ah,

it means there's yeah, not too many limits.

You can actually put, uh, all sorts of expression here

and say something extends from another.

Uh, so then if we wanted to constrain this a

bit more and say, uh, all, uh, all dogs and

cats are furry, we could just say, uh, actually, furry

pets is, uh, the whole thing is all cats and

dogs together.

So in this, in this model, we could say, Can

there be other animals besides cats and dogs?

Who says Yes?

OK, yes, it's correct.

There can be.

So we said, this extends animal.

This extends animal, but we haven't constrained those two together

to be animals, so there can be other sorts of

animal.

And we haven't made animal abstract a furry pet, uh,

by default.

Um uh, A is not going to put things into

fairy pet.

Besides, uh, what we what we said So by default,

uh, you'll never have any other sort of thing turning

up in furry pet.

Uh, so a few other bullying connectives that we can

use, uh, we can use, uh, normal logical connectives so

and an or and not so we could say a

and B equals C X and y equals Z, uh,

and joining them.

Uh, a few less typical bullying connectives are implies, And

if so, uh, implies means, uh, if the first thing

is true, then the second thing must be true.

And if is, like implies in both directions.

So if you put implies between two, uh, expressions you've

said, uh, they either have to both be true or

both be false.

So a plus b equals C if and only FX

plus y equals Z So either they're both true or

they're both false.

Um, a few other things worth thinking about is, um,

if we've said that, um, a property is of multiplicity

one.

So and and I I said, that's the default.

If we don't, um, say anything else, it'll be assumed

that that's a default.

Uh, then we've effectively come up with AAA function because

for every student, uh, we can always So here we've

said things called students.

A student has exactly one name.

That means that there is, uh, a function going from

student to name.

It doesn't mean there's necessarily, uh, a function going the

other way back because there could be, uh, uh, a

name that multiple students happen to have.

But for every student we can get from student to,

uh, a single name, Uh, if we've got a loan

zero or one, then it's something people may have.

So maybe that could be driver's licence.

Uh, student, uh, may have a driver's licence.

You can never have more than one, but you may

have zero, or you may have one.

Uh, if you have shared types, So you've got a

bunch of things that are all, uh, the same, uh,

the same type.

You can just separate them with commas.

So if, um, you have a person and there are

multiple properties, uh, which effectively point to other people, uh,

you can just declare them all in the one line.

Uh, I think usually that it's clearer to give them

their own line.

But you could say I don't know is parent of

and shares an office with, uh and, uh, just put

them all together on the one line and person afterwards.

Uh, it doesn't matter.

what order?

You declare things in either.

So, typically, for ease of reading, uh, we try and,

uh, kind of put things in some kind of logical

order, so we might want to sort of introduce file

systems first, but, uh, file systems are allowed to refer

to deers, even though deers were defer were defined down

here, uh, and we could put these in any order

we like.

So Alloy doesn't care what order things go in.

Uh, nor does it declare what order of properties go

in inside, Uh, inside a sig.

Uh uh.

There's a few more examples, but I'll skip those for

the moment.

I will probably have to finish this off next week,

but I will just mention I said, um, one problem

with our file system example was there's nothing.

Um, there's nothing as yet connecting parent and content.

So what we really want is if, um, this directory

is the parent of some file, uh, or rather, if

if file has some directory as a parent, then the

file is part of the content.

So we want those to kind of, uh, be, uh,

sort of mirror images of things.

Uh, there is a way of saying that it requires

a quantifier all, uh, so I'll leave that until next

week.

So we will, um we will look at more complicated

constraints, uh, in, uh, next week's lecture, and then we'll

just talk about revision in the exam.

And, uh, if people don't have too many exam questions,

we will finish early.

And you can, uh, just work on the project or

work on other units.

So, uh, it might be a short lecture.

We will see how we go.

Thanks very much.

